// -----------------------------------------------------------------------------
// NOTE: This file was generated from Microsoft's Language Server Protocol (LSP)
// specification. Please do not edit it by hand.
// -----------------------------------------------------------------------------

#include <cmath>
#include <stdexcept>

#include <lsp/specification.h>
#include <lsp/lsp_exception.h>
#include <lsp/lsp_transformer.h>

namespace LCompilers::LanguageServerProtocol {

  LspTransformer::LspTransformer(lsl::Logger &logger)
    : logger(logger)
  {
    // empty
  }

  // ============ //
  // Copy Methods //
  // ============ //

  auto LspTransformer::copy(const std::unique_ptr<LSPAny> &any) const -> std::unique_ptr<LSPAny> {
    std::unique_ptr<LSPAny> clone = std::make_unique<LSPAny>();
    switch (static_cast<LSPAnyType>(any->index())) {
    case LSPAnyType::OBJECT_TYPE: {
      (*clone) = copy(std::get<LSPObject>(*any));
      break;
    }
    case LSPAnyType::ARRAY_TYPE: {
      (*clone) = copy(std::get<LSPArray>(*any));
      break;
    }
    case LSPAnyType::STRING_TYPE: {
      (*clone) = std::get<string_t>(*any);
      break;
    }
    case LSPAnyType::INTEGER_TYPE: {
      (*clone) = std::get<integer_t>(*any);
      break;
    }
    case LSPAnyType::UINTEGER_TYPE: {
      (*clone) = std::get<uinteger_t>(*any);
      break;
    }
    case LSPAnyType::DECIMAL_TYPE: {
      (*clone) = std::get<decimal_t>(*any);
      break;
    }
    case LSPAnyType::BOOLEAN_TYPE: {
      (*clone) = std::get<boolean_t>(*any);
      break;
    }
    case LSPAnyType::NULL_TYPE: {
      (*clone) = std::get<null_t>(*any);
      break;
    }
    }
    return clone;
  }

  auto LspTransformer::copy(const LSPObject &object) const -> LSPObject {
    LSPObject clone;
    for (const auto &[key, value] : object) {
      clone.emplace(key, copy(value));
    }
    return clone;
  }

  auto LspTransformer::copy(const LSPArray &array) const -> LSPArray {
    LSPArray clone;
    for (const std::unique_ptr<LSPAny> &elem : array) {
      clone.push_back(copy(elem));
    }
    return clone;
  }

  auto LspTransformer::anyToSemanticTokenTypes(
    const LSPAny &any
  ) const -> SemanticTokenTypes {
    try {
      switch (static_cast<LSPAnyType>(any.index())) {
      case LSPAnyType::STRING_TYPE: {
        const string_t &value = std::get<std::string>(any);
        return semanticTokenTypesByValue(value);
        break;
      }
      default: {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          ("LSPAnyType for a(n) SemanticTokenTypes must be of type LSPAnyType::STRING_TYPE but received type " +
           LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
        );
      }
      }
    } catch (std::invalid_argument &e) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        e.what()
      );
    }
  }

  auto LspTransformer::semanticTokenTypesToAny(
    SemanticTokenTypes enumerator
  ) const -> std::unique_ptr<LSPAny> {
    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = SemanticTokenTypesValues.at(enumerator);
    return any;
  }

  auto LspTransformer::anyToSemanticTokenModifiers(
    const LSPAny &any
  ) const -> SemanticTokenModifiers {
    try {
      switch (static_cast<LSPAnyType>(any.index())) {
      case LSPAnyType::STRING_TYPE: {
        const string_t &value = std::get<std::string>(any);
        return semanticTokenModifiersByValue(value);
        break;
      }
      default: {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          ("LSPAnyType for a(n) SemanticTokenModifiers must be of type LSPAnyType::STRING_TYPE but received type " +
           LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
        );
      }
      }
    } catch (std::invalid_argument &e) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        e.what()
      );
    }
  }

  auto LspTransformer::semanticTokenModifiersToAny(
    SemanticTokenModifiers enumerator
  ) const -> std::unique_ptr<LSPAny> {
    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = SemanticTokenModifiersValues.at(enumerator);
    return any;
  }

  auto LspTransformer::anyToDocumentDiagnosticReportKind(
    const LSPAny &any
  ) const -> DocumentDiagnosticReportKind {
    try {
      switch (static_cast<LSPAnyType>(any.index())) {
      case LSPAnyType::STRING_TYPE: {
        const string_t &value = std::get<std::string>(any);
        return documentDiagnosticReportKindByValue(value);
        break;
      }
      default: {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          ("LSPAnyType for a(n) DocumentDiagnosticReportKind must be of type LSPAnyType::STRING_TYPE but received type " +
           LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
        );
      }
      }
    } catch (std::invalid_argument &e) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        e.what()
      );
    }
  }

  auto LspTransformer::documentDiagnosticReportKindToAny(
    DocumentDiagnosticReportKind enumerator
  ) const -> std::unique_ptr<LSPAny> {
    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = DocumentDiagnosticReportKindValues.at(enumerator);
    return any;
  }

  auto LspTransformer::anyToErrorCodes(
    const LSPAny &any
  ) const -> ErrorCodes {
    try {
      switch (static_cast<LSPAnyType>(any.index())) {
      case LSPAnyType::INTEGER_TYPE: {
        integer_t value = std::get<integer_t>(any);
        return errorCodesByValue(value);
        break;
      }
      case LSPAnyType::UINTEGER_TYPE: {
        integer_t value = static_cast<integer_t>(
          std::get<uinteger_t>(any)
        );
        return errorCodesByValue(value);
        break;
      }
      default: {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          ("LSPAnyType for a(n) ErrorCodes must be of type LSPAnyType::INTEGER_TYPE but received type " +
           LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
        );
      }
      }
    } catch (std::invalid_argument &e) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        e.what()
      );
    }
  }

  auto LspTransformer::errorCodesToAny(
    ErrorCodes enumerator
  ) const -> std::unique_ptr<LSPAny> {
    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = static_cast<integer_t>(enumerator);
    return any;
  }

  auto LspTransformer::anyToLSPErrorCodes(
    const LSPAny &any
  ) const -> LSPErrorCodes {
    try {
      switch (static_cast<LSPAnyType>(any.index())) {
      case LSPAnyType::INTEGER_TYPE: {
        integer_t value = std::get<integer_t>(any);
        return lspErrorCodesByValue(value);
        break;
      }
      case LSPAnyType::UINTEGER_TYPE: {
        integer_t value = static_cast<integer_t>(
          std::get<uinteger_t>(any)
        );
        return lspErrorCodesByValue(value);
        break;
      }
      default: {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          ("LSPAnyType for a(n) LSPErrorCodes must be of type LSPAnyType::INTEGER_TYPE but received type " +
           LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
        );
      }
      }
    } catch (std::invalid_argument &e) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        e.what()
      );
    }
  }

  auto LspTransformer::lspErrorCodesToAny(
    LSPErrorCodes enumerator
  ) const -> std::unique_ptr<LSPAny> {
    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = static_cast<integer_t>(enumerator);
    return any;
  }

  auto LspTransformer::anyToFoldingRangeKind(
    const LSPAny &any
  ) const -> FoldingRangeKind {
    try {
      switch (static_cast<LSPAnyType>(any.index())) {
      case LSPAnyType::STRING_TYPE: {
        const string_t &value = std::get<std::string>(any);
        return foldingRangeKindByValue(value);
        break;
      }
      default: {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          ("LSPAnyType for a(n) FoldingRangeKind must be of type LSPAnyType::STRING_TYPE but received type " +
           LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
        );
      }
      }
    } catch (std::invalid_argument &e) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        e.what()
      );
    }
  }

  auto LspTransformer::foldingRangeKindToAny(
    FoldingRangeKind enumerator
  ) const -> std::unique_ptr<LSPAny> {
    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = FoldingRangeKindValues.at(enumerator);
    return any;
  }

  auto LspTransformer::anyToSymbolKind(
    const LSPAny &any
  ) const -> SymbolKind {
    try {
      switch (static_cast<LSPAnyType>(any.index())) {
      case LSPAnyType::UINTEGER_TYPE: {
        uinteger_t value = std::get<uinteger_t>(any);
        return symbolKindByValue(value);
        break;
      }
      case LSPAnyType::INTEGER_TYPE: {
        uinteger_t value = static_cast<uinteger_t>(
          std::get<integer_t>(any)
        );
        return symbolKindByValue(value);
        break;
      }
      default: {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          ("LSPAnyType for a(n) SymbolKind must be of type LSPAnyType::UINTEGER_TYPE but received type " +
           LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
        );
      }
      }
    } catch (std::invalid_argument &e) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        e.what()
      );
    }
  }

  auto LspTransformer::symbolKindToAny(
    SymbolKind enumerator
  ) const -> std::unique_ptr<LSPAny> {
    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = static_cast<uinteger_t>(enumerator);
    return any;
  }

  auto LspTransformer::anyToSymbolTag(
    const LSPAny &any
  ) const -> SymbolTag {
    try {
      switch (static_cast<LSPAnyType>(any.index())) {
      case LSPAnyType::UINTEGER_TYPE: {
        uinteger_t value = std::get<uinteger_t>(any);
        return symbolTagByValue(value);
        break;
      }
      case LSPAnyType::INTEGER_TYPE: {
        uinteger_t value = static_cast<uinteger_t>(
          std::get<integer_t>(any)
        );
        return symbolTagByValue(value);
        break;
      }
      default: {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          ("LSPAnyType for a(n) SymbolTag must be of type LSPAnyType::UINTEGER_TYPE but received type " +
           LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
        );
      }
      }
    } catch (std::invalid_argument &e) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        e.what()
      );
    }
  }

  auto LspTransformer::symbolTagToAny(
    SymbolTag enumerator
  ) const -> std::unique_ptr<LSPAny> {
    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = static_cast<uinteger_t>(enumerator);
    return any;
  }

  auto LspTransformer::anyToUniquenessLevel(
    const LSPAny &any
  ) const -> UniquenessLevel {
    try {
      switch (static_cast<LSPAnyType>(any.index())) {
      case LSPAnyType::STRING_TYPE: {
        const string_t &value = std::get<std::string>(any);
        return uniquenessLevelByValue(value);
        break;
      }
      default: {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          ("LSPAnyType for a(n) UniquenessLevel must be of type LSPAnyType::STRING_TYPE but received type " +
           LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
        );
      }
      }
    } catch (std::invalid_argument &e) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        e.what()
      );
    }
  }

  auto LspTransformer::uniquenessLevelToAny(
    UniquenessLevel enumerator
  ) const -> std::unique_ptr<LSPAny> {
    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = UniquenessLevelValues.at(enumerator);
    return any;
  }

  auto LspTransformer::anyToMonikerKind(
    const LSPAny &any
  ) const -> MonikerKind {
    try {
      switch (static_cast<LSPAnyType>(any.index())) {
      case LSPAnyType::STRING_TYPE: {
        const string_t &value = std::get<std::string>(any);
        return monikerKindByValue(value);
        break;
      }
      default: {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          ("LSPAnyType for a(n) MonikerKind must be of type LSPAnyType::STRING_TYPE but received type " +
           LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
        );
      }
      }
    } catch (std::invalid_argument &e) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        e.what()
      );
    }
  }

  auto LspTransformer::monikerKindToAny(
    MonikerKind enumerator
  ) const -> std::unique_ptr<LSPAny> {
    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = MonikerKindValues.at(enumerator);
    return any;
  }

  auto LspTransformer::anyToInlayHintKind(
    const LSPAny &any
  ) const -> InlayHintKind {
    try {
      switch (static_cast<LSPAnyType>(any.index())) {
      case LSPAnyType::UINTEGER_TYPE: {
        uinteger_t value = std::get<uinteger_t>(any);
        return inlayHintKindByValue(value);
        break;
      }
      case LSPAnyType::INTEGER_TYPE: {
        uinteger_t value = static_cast<uinteger_t>(
          std::get<integer_t>(any)
        );
        return inlayHintKindByValue(value);
        break;
      }
      default: {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          ("LSPAnyType for a(n) InlayHintKind must be of type LSPAnyType::UINTEGER_TYPE but received type " +
           LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
        );
      }
      }
    } catch (std::invalid_argument &e) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        e.what()
      );
    }
  }

  auto LspTransformer::inlayHintKindToAny(
    InlayHintKind enumerator
  ) const -> std::unique_ptr<LSPAny> {
    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = static_cast<uinteger_t>(enumerator);
    return any;
  }

  auto LspTransformer::anyToMessageType(
    const LSPAny &any
  ) const -> MessageType {
    try {
      switch (static_cast<LSPAnyType>(any.index())) {
      case LSPAnyType::UINTEGER_TYPE: {
        uinteger_t value = std::get<uinteger_t>(any);
        return messageTypeByValue(value);
        break;
      }
      case LSPAnyType::INTEGER_TYPE: {
        uinteger_t value = static_cast<uinteger_t>(
          std::get<integer_t>(any)
        );
        return messageTypeByValue(value);
        break;
      }
      default: {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          ("LSPAnyType for a(n) MessageType must be of type LSPAnyType::UINTEGER_TYPE but received type " +
           LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
        );
      }
      }
    } catch (std::invalid_argument &e) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        e.what()
      );
    }
  }

  auto LspTransformer::messageTypeToAny(
    MessageType enumerator
  ) const -> std::unique_ptr<LSPAny> {
    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = static_cast<uinteger_t>(enumerator);
    return any;
  }

  auto LspTransformer::anyToTextDocumentSyncKind(
    const LSPAny &any
  ) const -> TextDocumentSyncKind {
    try {
      switch (static_cast<LSPAnyType>(any.index())) {
      case LSPAnyType::UINTEGER_TYPE: {
        uinteger_t value = std::get<uinteger_t>(any);
        return textDocumentSyncKindByValue(value);
        break;
      }
      case LSPAnyType::INTEGER_TYPE: {
        uinteger_t value = static_cast<uinteger_t>(
          std::get<integer_t>(any)
        );
        return textDocumentSyncKindByValue(value);
        break;
      }
      default: {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          ("LSPAnyType for a(n) TextDocumentSyncKind must be of type LSPAnyType::UINTEGER_TYPE but received type " +
           LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
        );
      }
      }
    } catch (std::invalid_argument &e) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        e.what()
      );
    }
  }

  auto LspTransformer::textDocumentSyncKindToAny(
    TextDocumentSyncKind enumerator
  ) const -> std::unique_ptr<LSPAny> {
    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = static_cast<uinteger_t>(enumerator);
    return any;
  }

  auto LspTransformer::anyToTextDocumentSaveReason(
    const LSPAny &any
  ) const -> TextDocumentSaveReason {
    try {
      switch (static_cast<LSPAnyType>(any.index())) {
      case LSPAnyType::UINTEGER_TYPE: {
        uinteger_t value = std::get<uinteger_t>(any);
        return textDocumentSaveReasonByValue(value);
        break;
      }
      case LSPAnyType::INTEGER_TYPE: {
        uinteger_t value = static_cast<uinteger_t>(
          std::get<integer_t>(any)
        );
        return textDocumentSaveReasonByValue(value);
        break;
      }
      default: {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          ("LSPAnyType for a(n) TextDocumentSaveReason must be of type LSPAnyType::UINTEGER_TYPE but received type " +
           LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
        );
      }
      }
    } catch (std::invalid_argument &e) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        e.what()
      );
    }
  }

  auto LspTransformer::textDocumentSaveReasonToAny(
    TextDocumentSaveReason enumerator
  ) const -> std::unique_ptr<LSPAny> {
    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = static_cast<uinteger_t>(enumerator);
    return any;
  }

  auto LspTransformer::anyToCompletionItemKind(
    const LSPAny &any
  ) const -> CompletionItemKind {
    try {
      switch (static_cast<LSPAnyType>(any.index())) {
      case LSPAnyType::UINTEGER_TYPE: {
        uinteger_t value = std::get<uinteger_t>(any);
        return completionItemKindByValue(value);
        break;
      }
      case LSPAnyType::INTEGER_TYPE: {
        uinteger_t value = static_cast<uinteger_t>(
          std::get<integer_t>(any)
        );
        return completionItemKindByValue(value);
        break;
      }
      default: {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          ("LSPAnyType for a(n) CompletionItemKind must be of type LSPAnyType::UINTEGER_TYPE but received type " +
           LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
        );
      }
      }
    } catch (std::invalid_argument &e) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        e.what()
      );
    }
  }

  auto LspTransformer::completionItemKindToAny(
    CompletionItemKind enumerator
  ) const -> std::unique_ptr<LSPAny> {
    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = static_cast<uinteger_t>(enumerator);
    return any;
  }

  auto LspTransformer::anyToCompletionItemTag(
    const LSPAny &any
  ) const -> CompletionItemTag {
    try {
      switch (static_cast<LSPAnyType>(any.index())) {
      case LSPAnyType::UINTEGER_TYPE: {
        uinteger_t value = std::get<uinteger_t>(any);
        return completionItemTagByValue(value);
        break;
      }
      case LSPAnyType::INTEGER_TYPE: {
        uinteger_t value = static_cast<uinteger_t>(
          std::get<integer_t>(any)
        );
        return completionItemTagByValue(value);
        break;
      }
      default: {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          ("LSPAnyType for a(n) CompletionItemTag must be of type LSPAnyType::UINTEGER_TYPE but received type " +
           LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
        );
      }
      }
    } catch (std::invalid_argument &e) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        e.what()
      );
    }
  }

  auto LspTransformer::completionItemTagToAny(
    CompletionItemTag enumerator
  ) const -> std::unique_ptr<LSPAny> {
    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = static_cast<uinteger_t>(enumerator);
    return any;
  }

  auto LspTransformer::anyToInsertTextFormat(
    const LSPAny &any
  ) const -> InsertTextFormat {
    try {
      switch (static_cast<LSPAnyType>(any.index())) {
      case LSPAnyType::UINTEGER_TYPE: {
        uinteger_t value = std::get<uinteger_t>(any);
        return insertTextFormatByValue(value);
        break;
      }
      case LSPAnyType::INTEGER_TYPE: {
        uinteger_t value = static_cast<uinteger_t>(
          std::get<integer_t>(any)
        );
        return insertTextFormatByValue(value);
        break;
      }
      default: {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          ("LSPAnyType for a(n) InsertTextFormat must be of type LSPAnyType::UINTEGER_TYPE but received type " +
           LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
        );
      }
      }
    } catch (std::invalid_argument &e) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        e.what()
      );
    }
  }

  auto LspTransformer::insertTextFormatToAny(
    InsertTextFormat enumerator
  ) const -> std::unique_ptr<LSPAny> {
    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = static_cast<uinteger_t>(enumerator);
    return any;
  }

  auto LspTransformer::anyToInsertTextMode(
    const LSPAny &any
  ) const -> InsertTextMode {
    try {
      switch (static_cast<LSPAnyType>(any.index())) {
      case LSPAnyType::UINTEGER_TYPE: {
        uinteger_t value = std::get<uinteger_t>(any);
        return insertTextModeByValue(value);
        break;
      }
      case LSPAnyType::INTEGER_TYPE: {
        uinteger_t value = static_cast<uinteger_t>(
          std::get<integer_t>(any)
        );
        return insertTextModeByValue(value);
        break;
      }
      default: {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          ("LSPAnyType for a(n) InsertTextMode must be of type LSPAnyType::UINTEGER_TYPE but received type " +
           LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
        );
      }
      }
    } catch (std::invalid_argument &e) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        e.what()
      );
    }
  }

  auto LspTransformer::insertTextModeToAny(
    InsertTextMode enumerator
  ) const -> std::unique_ptr<LSPAny> {
    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = static_cast<uinteger_t>(enumerator);
    return any;
  }

  auto LspTransformer::anyToDocumentHighlightKind(
    const LSPAny &any
  ) const -> DocumentHighlightKind {
    try {
      switch (static_cast<LSPAnyType>(any.index())) {
      case LSPAnyType::UINTEGER_TYPE: {
        uinteger_t value = std::get<uinteger_t>(any);
        return documentHighlightKindByValue(value);
        break;
      }
      case LSPAnyType::INTEGER_TYPE: {
        uinteger_t value = static_cast<uinteger_t>(
          std::get<integer_t>(any)
        );
        return documentHighlightKindByValue(value);
        break;
      }
      default: {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          ("LSPAnyType for a(n) DocumentHighlightKind must be of type LSPAnyType::UINTEGER_TYPE but received type " +
           LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
        );
      }
      }
    } catch (std::invalid_argument &e) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        e.what()
      );
    }
  }

  auto LspTransformer::documentHighlightKindToAny(
    DocumentHighlightKind enumerator
  ) const -> std::unique_ptr<LSPAny> {
    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = static_cast<uinteger_t>(enumerator);
    return any;
  }

  auto LspTransformer::anyToCodeActionKind(
    const LSPAny &any
  ) const -> CodeActionKind {
    try {
      switch (static_cast<LSPAnyType>(any.index())) {
      case LSPAnyType::STRING_TYPE: {
        const string_t &value = std::get<std::string>(any);
        return codeActionKindByValue(value);
        break;
      }
      default: {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          ("LSPAnyType for a(n) CodeActionKind must be of type LSPAnyType::STRING_TYPE but received type " +
           LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
        );
      }
      }
    } catch (std::invalid_argument &e) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        e.what()
      );
    }
  }

  auto LspTransformer::codeActionKindToAny(
    CodeActionKind enumerator
  ) const -> std::unique_ptr<LSPAny> {
    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = CodeActionKindValues.at(enumerator);
    return any;
  }

  auto LspTransformer::anyToTraceValues(
    const LSPAny &any
  ) const -> TraceValues {
    try {
      switch (static_cast<LSPAnyType>(any.index())) {
      case LSPAnyType::STRING_TYPE: {
        const string_t &value = std::get<std::string>(any);
        return traceValuesByValue(value);
        break;
      }
      default: {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          ("LSPAnyType for a(n) TraceValues must be of type LSPAnyType::STRING_TYPE but received type " +
           LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
        );
      }
      }
    } catch (std::invalid_argument &e) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        e.what()
      );
    }
  }

  auto LspTransformer::traceValuesToAny(
    TraceValues enumerator
  ) const -> std::unique_ptr<LSPAny> {
    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = TraceValuesValues.at(enumerator);
    return any;
  }

  auto LspTransformer::anyToMarkupKind(
    const LSPAny &any
  ) const -> MarkupKind {
    try {
      switch (static_cast<LSPAnyType>(any.index())) {
      case LSPAnyType::STRING_TYPE: {
        const string_t &value = std::get<std::string>(any);
        return markupKindByValue(value);
        break;
      }
      default: {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          ("LSPAnyType for a(n) MarkupKind must be of type LSPAnyType::STRING_TYPE but received type " +
           LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
        );
      }
      }
    } catch (std::invalid_argument &e) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        e.what()
      );
    }
  }

  auto LspTransformer::markupKindToAny(
    MarkupKind enumerator
  ) const -> std::unique_ptr<LSPAny> {
    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = MarkupKindValues.at(enumerator);
    return any;
  }

  auto LspTransformer::anyToInlineCompletionTriggerKind(
    const LSPAny &any
  ) const -> InlineCompletionTriggerKind {
    try {
      switch (static_cast<LSPAnyType>(any.index())) {
      case LSPAnyType::UINTEGER_TYPE: {
        uinteger_t value = std::get<uinteger_t>(any);
        return inlineCompletionTriggerKindByValue(value);
        break;
      }
      case LSPAnyType::INTEGER_TYPE: {
        uinteger_t value = static_cast<uinteger_t>(
          std::get<integer_t>(any)
        );
        return inlineCompletionTriggerKindByValue(value);
        break;
      }
      default: {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          ("LSPAnyType for a(n) InlineCompletionTriggerKind must be of type LSPAnyType::UINTEGER_TYPE but received type " +
           LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
        );
      }
      }
    } catch (std::invalid_argument &e) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        e.what()
      );
    }
  }

  auto LspTransformer::inlineCompletionTriggerKindToAny(
    InlineCompletionTriggerKind enumerator
  ) const -> std::unique_ptr<LSPAny> {
    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = static_cast<uinteger_t>(enumerator);
    return any;
  }

  auto LspTransformer::anyToPositionEncodingKind(
    const LSPAny &any
  ) const -> PositionEncodingKind {
    try {
      switch (static_cast<LSPAnyType>(any.index())) {
      case LSPAnyType::STRING_TYPE: {
        const string_t &value = std::get<std::string>(any);
        return positionEncodingKindByValue(value);
        break;
      }
      default: {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          ("LSPAnyType for a(n) PositionEncodingKind must be of type LSPAnyType::STRING_TYPE but received type " +
           LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
        );
      }
      }
    } catch (std::invalid_argument &e) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        e.what()
      );
    }
  }

  auto LspTransformer::positionEncodingKindToAny(
    PositionEncodingKind enumerator
  ) const -> std::unique_ptr<LSPAny> {
    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = PositionEncodingKindValues.at(enumerator);
    return any;
  }

  auto LspTransformer::anyToFileChangeType(
    const LSPAny &any
  ) const -> FileChangeType {
    try {
      switch (static_cast<LSPAnyType>(any.index())) {
      case LSPAnyType::UINTEGER_TYPE: {
        uinteger_t value = std::get<uinteger_t>(any);
        return fileChangeTypeByValue(value);
        break;
      }
      case LSPAnyType::INTEGER_TYPE: {
        uinteger_t value = static_cast<uinteger_t>(
          std::get<integer_t>(any)
        );
        return fileChangeTypeByValue(value);
        break;
      }
      default: {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          ("LSPAnyType for a(n) FileChangeType must be of type LSPAnyType::UINTEGER_TYPE but received type " +
           LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
        );
      }
      }
    } catch (std::invalid_argument &e) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        e.what()
      );
    }
  }

  auto LspTransformer::fileChangeTypeToAny(
    FileChangeType enumerator
  ) const -> std::unique_ptr<LSPAny> {
    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = static_cast<uinteger_t>(enumerator);
    return any;
  }

  auto LspTransformer::anyToWatchKind(
    const LSPAny &any
  ) const -> WatchKind {
    try {
      switch (static_cast<LSPAnyType>(any.index())) {
      case LSPAnyType::UINTEGER_TYPE: {
        uinteger_t value = std::get<uinteger_t>(any);
        return watchKindByValue(value);
        break;
      }
      case LSPAnyType::INTEGER_TYPE: {
        uinteger_t value = static_cast<uinteger_t>(
          std::get<integer_t>(any)
        );
        return watchKindByValue(value);
        break;
      }
      default: {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          ("LSPAnyType for a(n) WatchKind must be of type LSPAnyType::UINTEGER_TYPE but received type " +
           LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
        );
      }
      }
    } catch (std::invalid_argument &e) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        e.what()
      );
    }
  }

  auto LspTransformer::watchKindToAny(
    WatchKind enumerator
  ) const -> std::unique_ptr<LSPAny> {
    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = static_cast<uinteger_t>(enumerator);
    return any;
  }

  auto LspTransformer::anyToDiagnosticSeverity(
    const LSPAny &any
  ) const -> DiagnosticSeverity {
    try {
      switch (static_cast<LSPAnyType>(any.index())) {
      case LSPAnyType::UINTEGER_TYPE: {
        uinteger_t value = std::get<uinteger_t>(any);
        return diagnosticSeverityByValue(value);
        break;
      }
      case LSPAnyType::INTEGER_TYPE: {
        uinteger_t value = static_cast<uinteger_t>(
          std::get<integer_t>(any)
        );
        return diagnosticSeverityByValue(value);
        break;
      }
      default: {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          ("LSPAnyType for a(n) DiagnosticSeverity must be of type LSPAnyType::UINTEGER_TYPE but received type " +
           LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
        );
      }
      }
    } catch (std::invalid_argument &e) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        e.what()
      );
    }
  }

  auto LspTransformer::diagnosticSeverityToAny(
    DiagnosticSeverity enumerator
  ) const -> std::unique_ptr<LSPAny> {
    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = static_cast<uinteger_t>(enumerator);
    return any;
  }

  auto LspTransformer::anyToDiagnosticTag(
    const LSPAny &any
  ) const -> DiagnosticTag {
    try {
      switch (static_cast<LSPAnyType>(any.index())) {
      case LSPAnyType::UINTEGER_TYPE: {
        uinteger_t value = std::get<uinteger_t>(any);
        return diagnosticTagByValue(value);
        break;
      }
      case LSPAnyType::INTEGER_TYPE: {
        uinteger_t value = static_cast<uinteger_t>(
          std::get<integer_t>(any)
        );
        return diagnosticTagByValue(value);
        break;
      }
      default: {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          ("LSPAnyType for a(n) DiagnosticTag must be of type LSPAnyType::UINTEGER_TYPE but received type " +
           LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
        );
      }
      }
    } catch (std::invalid_argument &e) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        e.what()
      );
    }
  }

  auto LspTransformer::diagnosticTagToAny(
    DiagnosticTag enumerator
  ) const -> std::unique_ptr<LSPAny> {
    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = static_cast<uinteger_t>(enumerator);
    return any;
  }

  auto LspTransformer::anyToCompletionTriggerKind(
    const LSPAny &any
  ) const -> CompletionTriggerKind {
    try {
      switch (static_cast<LSPAnyType>(any.index())) {
      case LSPAnyType::UINTEGER_TYPE: {
        uinteger_t value = std::get<uinteger_t>(any);
        return completionTriggerKindByValue(value);
        break;
      }
      case LSPAnyType::INTEGER_TYPE: {
        uinteger_t value = static_cast<uinteger_t>(
          std::get<integer_t>(any)
        );
        return completionTriggerKindByValue(value);
        break;
      }
      default: {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          ("LSPAnyType for a(n) CompletionTriggerKind must be of type LSPAnyType::UINTEGER_TYPE but received type " +
           LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
        );
      }
      }
    } catch (std::invalid_argument &e) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        e.what()
      );
    }
  }

  auto LspTransformer::completionTriggerKindToAny(
    CompletionTriggerKind enumerator
  ) const -> std::unique_ptr<LSPAny> {
    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = static_cast<uinteger_t>(enumerator);
    return any;
  }

  auto LspTransformer::anyToSignatureHelpTriggerKind(
    const LSPAny &any
  ) const -> SignatureHelpTriggerKind {
    try {
      switch (static_cast<LSPAnyType>(any.index())) {
      case LSPAnyType::UINTEGER_TYPE: {
        uinteger_t value = std::get<uinteger_t>(any);
        return signatureHelpTriggerKindByValue(value);
        break;
      }
      case LSPAnyType::INTEGER_TYPE: {
        uinteger_t value = static_cast<uinteger_t>(
          std::get<integer_t>(any)
        );
        return signatureHelpTriggerKindByValue(value);
        break;
      }
      default: {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          ("LSPAnyType for a(n) SignatureHelpTriggerKind must be of type LSPAnyType::UINTEGER_TYPE but received type " +
           LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
        );
      }
      }
    } catch (std::invalid_argument &e) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        e.what()
      );
    }
  }

  auto LspTransformer::signatureHelpTriggerKindToAny(
    SignatureHelpTriggerKind enumerator
  ) const -> std::unique_ptr<LSPAny> {
    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = static_cast<uinteger_t>(enumerator);
    return any;
  }

  auto LspTransformer::anyToCodeActionTriggerKind(
    const LSPAny &any
  ) const -> CodeActionTriggerKind {
    try {
      switch (static_cast<LSPAnyType>(any.index())) {
      case LSPAnyType::UINTEGER_TYPE: {
        uinteger_t value = std::get<uinteger_t>(any);
        return codeActionTriggerKindByValue(value);
        break;
      }
      case LSPAnyType::INTEGER_TYPE: {
        uinteger_t value = static_cast<uinteger_t>(
          std::get<integer_t>(any)
        );
        return codeActionTriggerKindByValue(value);
        break;
      }
      default: {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          ("LSPAnyType for a(n) CodeActionTriggerKind must be of type LSPAnyType::UINTEGER_TYPE but received type " +
           LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
        );
      }
      }
    } catch (std::invalid_argument &e) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        e.what()
      );
    }
  }

  auto LspTransformer::codeActionTriggerKindToAny(
    CodeActionTriggerKind enumerator
  ) const -> std::unique_ptr<LSPAny> {
    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = static_cast<uinteger_t>(enumerator);
    return any;
  }

  auto LspTransformer::anyToFileOperationPatternKind(
    const LSPAny &any
  ) const -> FileOperationPatternKind {
    try {
      switch (static_cast<LSPAnyType>(any.index())) {
      case LSPAnyType::STRING_TYPE: {
        const string_t &value = std::get<std::string>(any);
        return fileOperationPatternKindByValue(value);
        break;
      }
      default: {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          ("LSPAnyType for a(n) FileOperationPatternKind must be of type LSPAnyType::STRING_TYPE but received type " +
           LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
        );
      }
      }
    } catch (std::invalid_argument &e) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        e.what()
      );
    }
  }

  auto LspTransformer::fileOperationPatternKindToAny(
    FileOperationPatternKind enumerator
  ) const -> std::unique_ptr<LSPAny> {
    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = FileOperationPatternKindValues.at(enumerator);
    return any;
  }

  auto LspTransformer::anyToNotebookCellKind(
    const LSPAny &any
  ) const -> NotebookCellKind {
    try {
      switch (static_cast<LSPAnyType>(any.index())) {
      case LSPAnyType::UINTEGER_TYPE: {
        uinteger_t value = std::get<uinteger_t>(any);
        return notebookCellKindByValue(value);
        break;
      }
      case LSPAnyType::INTEGER_TYPE: {
        uinteger_t value = static_cast<uinteger_t>(
          std::get<integer_t>(any)
        );
        return notebookCellKindByValue(value);
        break;
      }
      default: {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          ("LSPAnyType for a(n) NotebookCellKind must be of type LSPAnyType::UINTEGER_TYPE but received type " +
           LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
        );
      }
      }
    } catch (std::invalid_argument &e) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        e.what()
      );
    }
  }

  auto LspTransformer::notebookCellKindToAny(
    NotebookCellKind enumerator
  ) const -> std::unique_ptr<LSPAny> {
    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = static_cast<uinteger_t>(enumerator);
    return any;
  }

  auto LspTransformer::anyToResourceOperationKind(
    const LSPAny &any
  ) const -> ResourceOperationKind {
    try {
      switch (static_cast<LSPAnyType>(any.index())) {
      case LSPAnyType::STRING_TYPE: {
        const string_t &value = std::get<std::string>(any);
        return resourceOperationKindByValue(value);
        break;
      }
      default: {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          ("LSPAnyType for a(n) ResourceOperationKind must be of type LSPAnyType::STRING_TYPE but received type " +
           LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
        );
      }
      }
    } catch (std::invalid_argument &e) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        e.what()
      );
    }
  }

  auto LspTransformer::resourceOperationKindToAny(
    ResourceOperationKind enumerator
  ) const -> std::unique_ptr<LSPAny> {
    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = ResourceOperationKindValues.at(enumerator);
    return any;
  }

  auto LspTransformer::anyToFailureHandlingKind(
    const LSPAny &any
  ) const -> FailureHandlingKind {
    try {
      switch (static_cast<LSPAnyType>(any.index())) {
      case LSPAnyType::STRING_TYPE: {
        const string_t &value = std::get<std::string>(any);
        return failureHandlingKindByValue(value);
        break;
      }
      default: {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          ("LSPAnyType for a(n) FailureHandlingKind must be of type LSPAnyType::STRING_TYPE but received type " +
           LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
        );
      }
      }
    } catch (std::invalid_argument &e) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        e.what()
      );
    }
  }

  auto LspTransformer::failureHandlingKindToAny(
    FailureHandlingKind enumerator
  ) const -> std::unique_ptr<LSPAny> {
    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = FailureHandlingKindValues.at(enumerator);
    return any;
  }

  auto LspTransformer::anyToPrepareSupportDefaultBehavior(
    const LSPAny &any
  ) const -> PrepareSupportDefaultBehavior {
    try {
      switch (static_cast<LSPAnyType>(any.index())) {
      case LSPAnyType::UINTEGER_TYPE: {
        uinteger_t value = std::get<uinteger_t>(any);
        return prepareSupportDefaultBehaviorByValue(value);
        break;
      }
      case LSPAnyType::INTEGER_TYPE: {
        uinteger_t value = static_cast<uinteger_t>(
          std::get<integer_t>(any)
        );
        return prepareSupportDefaultBehaviorByValue(value);
        break;
      }
      default: {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          ("LSPAnyType for a(n) PrepareSupportDefaultBehavior must be of type LSPAnyType::UINTEGER_TYPE but received type " +
           LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
        );
      }
      }
    } catch (std::invalid_argument &e) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        e.what()
      );
    }
  }

  auto LspTransformer::prepareSupportDefaultBehaviorToAny(
    PrepareSupportDefaultBehavior enumerator
  ) const -> std::unique_ptr<LSPAny> {
    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = static_cast<uinteger_t>(enumerator);
    return any;
  }

  auto LspTransformer::anyToTokenFormat(
    const LSPAny &any
  ) const -> TokenFormat {
    try {
      switch (static_cast<LSPAnyType>(any.index())) {
      case LSPAnyType::STRING_TYPE: {
        const string_t &value = std::get<std::string>(any);
        return tokenFormatByValue(value);
        break;
      }
      default: {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          ("LSPAnyType for a(n) TokenFormat must be of type LSPAnyType::STRING_TYPE but received type " +
           LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
        );
      }
      }
    } catch (std::invalid_argument &e) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        e.what()
      );
    }
  }

  auto LspTransformer::tokenFormatToAny(
    TokenFormat enumerator
  ) const -> std::unique_ptr<LSPAny> {
    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = TokenFormatValues.at(enumerator);
    return any;
  }

  // =================================== //
  // LSPAny <-> LSP Structure Transforms //
  // =================================== //

  auto LspTransformer::anyToMessage(
    const LSPAny &any
  ) const -> std::unique_ptr<Message> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) Message must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<Message> value =
      std::make_unique<Message>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) Message: " + std::to_string(object.size())
      );
    }

    iter = object.find("jsonrpc");
    if (iter != object.end()) {
      value->jsonrpc = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required Message attribute: jsonrpc"
      );
    }

    return value;
  }

  auto LspTransformer::messageToAny(
    const Message &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("jsonrpc", stringToAny(structure.jsonrpc));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToRequestMessage(
    const LSPAny &any
  ) const -> std::unique_ptr<RequestMessage> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) RequestMessage must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<RequestMessage> value =
      std::make_unique<RequestMessage>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 4) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) RequestMessage: " + std::to_string(object.size())
      );
    }

    iter = object.find("id");
    if (iter != object.end()) {
      value->id = anyToRequestId(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required RequestMessage attribute: id"
      );
    }

    iter = object.find("method");
    if (iter != object.end()) {
      value->method = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required RequestMessage attribute: method"
      );
    }

    iter = object.find("params");
    if (iter != object.end()) {
      value->params = anyToMessageParams(*iter->second);
    }

    iter = object.find("jsonrpc");
    if (iter != object.end()) {
      value->jsonrpc = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required RequestMessage attribute: jsonrpc"
      );
    }

    return value;
  }

  auto LspTransformer::requestMessageToAny(
    const RequestMessage &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("id", requestIdToAny(structure.id));
    object.emplace("method", stringToAny(structure.method));
    if (structure.params.has_value()) {
      object.emplace("params", messageParamsToAny(structure.params.value()));
    }
    object.emplace("jsonrpc", stringToAny(structure.jsonrpc));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToNotificationMessage(
    const LSPAny &any
  ) const -> std::unique_ptr<NotificationMessage> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) NotificationMessage must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<NotificationMessage> value =
      std::make_unique<NotificationMessage>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) NotificationMessage: " + std::to_string(object.size())
      );
    }

    iter = object.find("method");
    if (iter != object.end()) {
      value->method = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required NotificationMessage attribute: method"
      );
    }

    iter = object.find("params");
    if (iter != object.end()) {
      value->params = anyToMessageParams(*iter->second);
    }

    iter = object.find("jsonrpc");
    if (iter != object.end()) {
      value->jsonrpc = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required NotificationMessage attribute: jsonrpc"
      );
    }

    return value;
  }

  auto LspTransformer::notificationMessageToAny(
    const NotificationMessage &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("method", stringToAny(structure.method));
    if (structure.params.has_value()) {
      object.emplace("params", messageParamsToAny(structure.params.value()));
    }
    object.emplace("jsonrpc", stringToAny(structure.jsonrpc));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToResponseError(
    const LSPAny &any
  ) const -> std::unique_ptr<ResponseError> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) ResponseError must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<ResponseError> value =
      std::make_unique<ResponseError>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) ResponseError: " + std::to_string(object.size())
      );
    }

    iter = object.find("code");
    if (iter != object.end()) {
      value->code = anyToInteger(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required ResponseError attribute: code"
      );
    }

    iter = object.find("message");
    if (iter != object.end()) {
      value->message = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required ResponseError attribute: message"
      );
    }

    iter = object.find("data");
    if (iter != object.end()) {
      value->data = copy(iter->second);
    }

    return value;
  }

  auto LspTransformer::responseErrorToAny(
    const ResponseError &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("code", integerToAny(structure.code));
    object.emplace("message", stringToAny(structure.message));
    if (structure.data.has_value()) {
      object.emplace("data", copy(structure.data.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToResponseMessage(
    const LSPAny &any
  ) const -> std::unique_ptr<ResponseMessage> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) ResponseMessage must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<ResponseMessage> value =
      std::make_unique<ResponseMessage>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 4) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) ResponseMessage: " + std::to_string(object.size())
      );
    }

    iter = object.find("id");
    if (iter != object.end()) {
      value->id = anyToResponseId(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required ResponseMessage attribute: id"
      );
    }

    iter = object.find("result");
    if (iter != object.end()) {
      value->result = copy(iter->second);
    }

    iter = object.find("error");
    if (iter != object.end()) {
      value->error = anyToResponseError(*iter->second);
    }

    iter = object.find("jsonrpc");
    if (iter != object.end()) {
      value->jsonrpc = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required ResponseMessage attribute: jsonrpc"
      );
    }

    return value;
  }

  auto LspTransformer::responseMessageToAny(
    const ResponseMessage &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("id", responseIdToAny(structure.id));
    if (structure.result.has_value()) {
      object.emplace("result", copy(structure.result.value()));
    }
    if (structure.error.has_value()) {
      object.emplace("error", responseErrorToAny(*structure.error.value()));
    }
    object.emplace("jsonrpc", stringToAny(structure.jsonrpc));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToImplementationParams(
    const LSPAny &any
  ) const -> std::unique_ptr<ImplementationParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) ImplementationParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<ImplementationParams> value =
      std::make_unique<ImplementationParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 4) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) ImplementationParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("textDocument");
    if (iter != object.end()) {
      value->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required ImplementationParams attribute: textDocument"
      );
    }

    iter = object.find("position");
    if (iter != object.end()) {
      value->position = anyToPosition(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required ImplementationParams attribute: position"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      value->workDoneToken = anyToProgressToken(*iter->second);
    }

    iter = object.find("partialResultToken");
    if (iter != object.end()) {
      value->partialResultToken = anyToProgressToken(*iter->second);
    }

    return value;
  }

  auto LspTransformer::implementationParamsToAny(
    const ImplementationParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("textDocument", textDocumentIdentifierToAny(*structure.textDocument));
    object.emplace("position", positionToAny(*structure.position));
    if (structure.workDoneToken.has_value()) {
      object.emplace("workDoneToken", progressTokenToAny(structure.workDoneToken.value()));
    }
    if (structure.partialResultToken.has_value()) {
      object.emplace("partialResultToken", progressTokenToAny(structure.partialResultToken.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToLocation(
    const LSPAny &any
  ) const -> std::unique_ptr<Location> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) Location must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<Location> value =
      std::make_unique<Location>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) Location: " + std::to_string(object.size())
      );
    }

    iter = object.find("uri");
    if (iter != object.end()) {
      value->uri = anyToDocumentUri(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required Location attribute: uri"
      );
    }

    iter = object.find("range");
    if (iter != object.end()) {
      value->range = anyToRange(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required Location attribute: range"
      );
    }

    return value;
  }

  auto LspTransformer::locationToAny(
    const Location &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("uri", documentUriToAny(structure.uri));
    object.emplace("range", rangeToAny(*structure.range));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToImplementationRegistrationOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<ImplementationRegistrationOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) ImplementationRegistrationOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<ImplementationRegistrationOptions> value =
      std::make_unique<ImplementationRegistrationOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) ImplementationRegistrationOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("documentSelector");
    if (iter != object.end()) {
      value->documentSelector = anyToTextDocumentRegistrationOptions_documentSelector(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required ImplementationRegistrationOptions attribute: documentSelector"
      );
    }

    iter = object.find("id");
    if (iter != object.end()) {
      value->id = anyToString(*iter->second);
    }

    iter = object.find("workDoneProgress");
    if (iter != object.end()) {
      value->workDoneProgress = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::implementationRegistrationOptionsToAny(
    const ImplementationRegistrationOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("documentSelector", textDocumentRegistrationOptions_documentSelectorToAny(structure.documentSelector));
    if (structure.id.has_value()) {
      object.emplace("id", stringToAny(structure.id.value()));
    }
    if (structure.workDoneProgress.has_value()) {
      object.emplace("workDoneProgress", booleanToAny(structure.workDoneProgress.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToTypeDefinitionParams(
    const LSPAny &any
  ) const -> std::unique_ptr<TypeDefinitionParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) TypeDefinitionParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<TypeDefinitionParams> value =
      std::make_unique<TypeDefinitionParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 4) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) TypeDefinitionParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("textDocument");
    if (iter != object.end()) {
      value->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required TypeDefinitionParams attribute: textDocument"
      );
    }

    iter = object.find("position");
    if (iter != object.end()) {
      value->position = anyToPosition(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required TypeDefinitionParams attribute: position"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      value->workDoneToken = anyToProgressToken(*iter->second);
    }

    iter = object.find("partialResultToken");
    if (iter != object.end()) {
      value->partialResultToken = anyToProgressToken(*iter->second);
    }

    return value;
  }

  auto LspTransformer::typeDefinitionParamsToAny(
    const TypeDefinitionParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("textDocument", textDocumentIdentifierToAny(*structure.textDocument));
    object.emplace("position", positionToAny(*structure.position));
    if (structure.workDoneToken.has_value()) {
      object.emplace("workDoneToken", progressTokenToAny(structure.workDoneToken.value()));
    }
    if (structure.partialResultToken.has_value()) {
      object.emplace("partialResultToken", progressTokenToAny(structure.partialResultToken.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToTypeDefinitionRegistrationOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<TypeDefinitionRegistrationOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) TypeDefinitionRegistrationOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<TypeDefinitionRegistrationOptions> value =
      std::make_unique<TypeDefinitionRegistrationOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) TypeDefinitionRegistrationOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("documentSelector");
    if (iter != object.end()) {
      value->documentSelector = anyToTextDocumentRegistrationOptions_documentSelector(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required TypeDefinitionRegistrationOptions attribute: documentSelector"
      );
    }

    iter = object.find("id");
    if (iter != object.end()) {
      value->id = anyToString(*iter->second);
    }

    iter = object.find("workDoneProgress");
    if (iter != object.end()) {
      value->workDoneProgress = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::typeDefinitionRegistrationOptionsToAny(
    const TypeDefinitionRegistrationOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("documentSelector", textDocumentRegistrationOptions_documentSelectorToAny(structure.documentSelector));
    if (structure.id.has_value()) {
      object.emplace("id", stringToAny(structure.id.value()));
    }
    if (structure.workDoneProgress.has_value()) {
      object.emplace("workDoneProgress", booleanToAny(structure.workDoneProgress.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToWorkspaceFolder(
    const LSPAny &any
  ) const -> std::unique_ptr<WorkspaceFolder> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) WorkspaceFolder must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<WorkspaceFolder> value =
      std::make_unique<WorkspaceFolder>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) WorkspaceFolder: " + std::to_string(object.size())
      );
    }

    iter = object.find("uri");
    if (iter != object.end()) {
      value->uri = anyToURI(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required WorkspaceFolder attribute: uri"
      );
    }

    iter = object.find("name");
    if (iter != object.end()) {
      value->name = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required WorkspaceFolder attribute: name"
      );
    }

    return value;
  }

  auto LspTransformer::workspaceFolderToAny(
    const WorkspaceFolder &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("uri", uriToAny(structure.uri));
    object.emplace("name", stringToAny(structure.name));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToDidChangeWorkspaceFoldersParams(
    const LSPAny &any
  ) const -> std::unique_ptr<DidChangeWorkspaceFoldersParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) DidChangeWorkspaceFoldersParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<DidChangeWorkspaceFoldersParams> value =
      std::make_unique<DidChangeWorkspaceFoldersParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) DidChangeWorkspaceFoldersParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("event");
    if (iter != object.end()) {
      value->event = anyToWorkspaceFoldersChangeEvent(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DidChangeWorkspaceFoldersParams attribute: event"
      );
    }

    return value;
  }

  auto LspTransformer::didChangeWorkspaceFoldersParamsToAny(
    const DidChangeWorkspaceFoldersParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("event", workspaceFoldersChangeEventToAny(*structure.event));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToConfigurationParams(
    const LSPAny &any
  ) const -> std::unique_ptr<ConfigurationParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) ConfigurationParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<ConfigurationParams> value =
      std::make_unique<ConfigurationParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) ConfigurationParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("items");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<std::unique_ptr<ConfigurationItem>> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToConfigurationItem(*elem));
      }
      value->items = std::move(values);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required ConfigurationParams attribute: items"
      );
    }

    return value;
  }

  auto LspTransformer::configurationParamsToAny(
    const ConfigurationParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    {
      LSPArray array;
      for (const std::unique_ptr<ConfigurationItem> &elem : structure.items) {
        array.push_back(configurationItemToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("items", std::move(any));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToDocumentColorParams(
    const LSPAny &any
  ) const -> std::unique_ptr<DocumentColorParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) DocumentColorParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<DocumentColorParams> value =
      std::make_unique<DocumentColorParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) DocumentColorParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("textDocument");
    if (iter != object.end()) {
      value->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DocumentColorParams attribute: textDocument"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      value->workDoneToken = anyToProgressToken(*iter->second);
    }

    iter = object.find("partialResultToken");
    if (iter != object.end()) {
      value->partialResultToken = anyToProgressToken(*iter->second);
    }

    return value;
  }

  auto LspTransformer::documentColorParamsToAny(
    const DocumentColorParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("textDocument", textDocumentIdentifierToAny(*structure.textDocument));
    if (structure.workDoneToken.has_value()) {
      object.emplace("workDoneToken", progressTokenToAny(structure.workDoneToken.value()));
    }
    if (structure.partialResultToken.has_value()) {
      object.emplace("partialResultToken", progressTokenToAny(structure.partialResultToken.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToColorInformation(
    const LSPAny &any
  ) const -> std::unique_ptr<ColorInformation> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) ColorInformation must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<ColorInformation> value =
      std::make_unique<ColorInformation>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) ColorInformation: " + std::to_string(object.size())
      );
    }

    iter = object.find("range");
    if (iter != object.end()) {
      value->range = anyToRange(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required ColorInformation attribute: range"
      );
    }

    iter = object.find("color");
    if (iter != object.end()) {
      value->color = anyToColor(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required ColorInformation attribute: color"
      );
    }

    return value;
  }

  auto LspTransformer::colorInformationToAny(
    const ColorInformation &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("range", rangeToAny(*structure.range));
    object.emplace("color", colorToAny(*structure.color));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToDocumentColorRegistrationOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<DocumentColorRegistrationOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) DocumentColorRegistrationOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<DocumentColorRegistrationOptions> value =
      std::make_unique<DocumentColorRegistrationOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) DocumentColorRegistrationOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("documentSelector");
    if (iter != object.end()) {
      value->documentSelector = anyToTextDocumentRegistrationOptions_documentSelector(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DocumentColorRegistrationOptions attribute: documentSelector"
      );
    }

    iter = object.find("id");
    if (iter != object.end()) {
      value->id = anyToString(*iter->second);
    }

    iter = object.find("workDoneProgress");
    if (iter != object.end()) {
      value->workDoneProgress = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::documentColorRegistrationOptionsToAny(
    const DocumentColorRegistrationOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("documentSelector", textDocumentRegistrationOptions_documentSelectorToAny(structure.documentSelector));
    if (structure.id.has_value()) {
      object.emplace("id", stringToAny(structure.id.value()));
    }
    if (structure.workDoneProgress.has_value()) {
      object.emplace("workDoneProgress", booleanToAny(structure.workDoneProgress.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToColorPresentationParams(
    const LSPAny &any
  ) const -> std::unique_ptr<ColorPresentationParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) ColorPresentationParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<ColorPresentationParams> value =
      std::make_unique<ColorPresentationParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 5) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) ColorPresentationParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("textDocument");
    if (iter != object.end()) {
      value->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required ColorPresentationParams attribute: textDocument"
      );
    }

    iter = object.find("color");
    if (iter != object.end()) {
      value->color = anyToColor(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required ColorPresentationParams attribute: color"
      );
    }

    iter = object.find("range");
    if (iter != object.end()) {
      value->range = anyToRange(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required ColorPresentationParams attribute: range"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      value->workDoneToken = anyToProgressToken(*iter->second);
    }

    iter = object.find("partialResultToken");
    if (iter != object.end()) {
      value->partialResultToken = anyToProgressToken(*iter->second);
    }

    return value;
  }

  auto LspTransformer::colorPresentationParamsToAny(
    const ColorPresentationParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("textDocument", textDocumentIdentifierToAny(*structure.textDocument));
    object.emplace("color", colorToAny(*structure.color));
    object.emplace("range", rangeToAny(*structure.range));
    if (structure.workDoneToken.has_value()) {
      object.emplace("workDoneToken", progressTokenToAny(structure.workDoneToken.value()));
    }
    if (structure.partialResultToken.has_value()) {
      object.emplace("partialResultToken", progressTokenToAny(structure.partialResultToken.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToColorPresentation(
    const LSPAny &any
  ) const -> std::unique_ptr<ColorPresentation> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) ColorPresentation must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<ColorPresentation> value =
      std::make_unique<ColorPresentation>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) ColorPresentation: " + std::to_string(object.size())
      );
    }

    iter = object.find("label");
    if (iter != object.end()) {
      value->label = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required ColorPresentation attribute: label"
      );
    }

    iter = object.find("textEdit");
    if (iter != object.end()) {
      value->textEdit = anyToTextEdit(*iter->second);
    }

    iter = object.find("additionalTextEdits");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<std::unique_ptr<TextEdit>> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToTextEdit(*elem));
      }
      value->additionalTextEdits = std::move(values);
    }

    return value;
  }

  auto LspTransformer::colorPresentationToAny(
    const ColorPresentation &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("label", stringToAny(structure.label));
    if (structure.textEdit.has_value()) {
      object.emplace("textEdit", textEditToAny(*structure.textEdit.value()));
    }
    if (structure.additionalTextEdits.has_value()) {
      LSPArray array;
      for (const std::unique_ptr<TextEdit> &elem : structure.additionalTextEdits.value()) {
        array.push_back(textEditToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("additionalTextEdits", std::move(any));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToWorkDoneProgressOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<WorkDoneProgressOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) WorkDoneProgressOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<WorkDoneProgressOptions> value =
      std::make_unique<WorkDoneProgressOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) WorkDoneProgressOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("workDoneProgress");
    if (iter != object.end()) {
      value->workDoneProgress = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::workDoneProgressOptionsToAny(
    const WorkDoneProgressOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.workDoneProgress.has_value()) {
      object.emplace("workDoneProgress", booleanToAny(structure.workDoneProgress.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToTextDocumentRegistrationOptions_documentSelector(
    const LSPAny &any
  ) const -> TextDocumentRegistrationOptions_documentSelector {
    TextDocumentRegistrationOptions_documentSelector value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::ARRAY_TYPE: {
      try {
        std::vector<DocumentFilter> values;
        for (const std::unique_ptr<LSPAny> &elem
            : std::get<LSPArray>(any)) {
          values.push_back(anyToDocumentFilter(*elem));
        }
        value = std::move(values);
      } catch (LspException &e) {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          "Failed to transform LSPAny to array"
        );
      }
      break;
    }
    case LSPAnyType::NULL_TYPE: {
      value = anyToNull(any);
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) TextDocumentRegistrationOptions_documentSelector: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::textDocumentRegistrationOptions_documentSelectorToAny(
    const TextDocumentRegistrationOptions_documentSelector &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<TextDocumentRegistrationOptions_documentSelectorType>(variant.index())) {
    case TextDocumentRegistrationOptions_documentSelectorType::DOCUMENT_SELECTOR: {
      return documentSelectorToAny(
        std::get<DocumentSelector>(variant)
      );
    }
    case TextDocumentRegistrationOptions_documentSelectorType::NULL_TYPE: {
      return nullToAny(
        std::get<null_t>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported TextDocumentRegistrationOptions_documentSelectorType: " +
         TextDocumentRegistrationOptions_documentSelectorTypeNames.at(static_cast<TextDocumentRegistrationOptions_documentSelectorType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToTextDocumentRegistrationOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<TextDocumentRegistrationOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) TextDocumentRegistrationOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<TextDocumentRegistrationOptions> value =
      std::make_unique<TextDocumentRegistrationOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) TextDocumentRegistrationOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("documentSelector");
    if (iter != object.end()) {
      value->documentSelector = anyToTextDocumentRegistrationOptions_documentSelector(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required TextDocumentRegistrationOptions attribute: documentSelector"
      );
    }

    return value;
  }

  auto LspTransformer::textDocumentRegistrationOptionsToAny(
    const TextDocumentRegistrationOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("documentSelector", textDocumentRegistrationOptions_documentSelectorToAny(structure.documentSelector));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToFoldingRangeParams(
    const LSPAny &any
  ) const -> std::unique_ptr<FoldingRangeParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) FoldingRangeParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<FoldingRangeParams> value =
      std::make_unique<FoldingRangeParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) FoldingRangeParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("textDocument");
    if (iter != object.end()) {
      value->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required FoldingRangeParams attribute: textDocument"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      value->workDoneToken = anyToProgressToken(*iter->second);
    }

    iter = object.find("partialResultToken");
    if (iter != object.end()) {
      value->partialResultToken = anyToProgressToken(*iter->second);
    }

    return value;
  }

  auto LspTransformer::foldingRangeParamsToAny(
    const FoldingRangeParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("textDocument", textDocumentIdentifierToAny(*structure.textDocument));
    if (structure.workDoneToken.has_value()) {
      object.emplace("workDoneToken", progressTokenToAny(structure.workDoneToken.value()));
    }
    if (structure.partialResultToken.has_value()) {
      object.emplace("partialResultToken", progressTokenToAny(structure.partialResultToken.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToFoldingRange(
    const LSPAny &any
  ) const -> std::unique_ptr<FoldingRange> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) FoldingRange must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<FoldingRange> value =
      std::make_unique<FoldingRange>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 6) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) FoldingRange: " + std::to_string(object.size())
      );
    }

    iter = object.find("startLine");
    if (iter != object.end()) {
      value->startLine = anyToUInteger(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required FoldingRange attribute: startLine"
      );
    }

    iter = object.find("startCharacter");
    if (iter != object.end()) {
      value->startCharacter = anyToUInteger(*iter->second);
    }

    iter = object.find("endLine");
    if (iter != object.end()) {
      value->endLine = anyToUInteger(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required FoldingRange attribute: endLine"
      );
    }

    iter = object.find("endCharacter");
    if (iter != object.end()) {
      value->endCharacter = anyToUInteger(*iter->second);
    }

    iter = object.find("kind");
    if (iter != object.end()) {
      value->kind = anyToFoldingRangeKind(*iter->second);
    }

    iter = object.find("collapsedText");
    if (iter != object.end()) {
      value->collapsedText = anyToString(*iter->second);
    }

    return value;
  }

  auto LspTransformer::foldingRangeToAny(
    const FoldingRange &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("startLine", uintegerToAny(structure.startLine));
    if (structure.startCharacter.has_value()) {
      object.emplace("startCharacter", uintegerToAny(structure.startCharacter.value()));
    }
    object.emplace("endLine", uintegerToAny(structure.endLine));
    if (structure.endCharacter.has_value()) {
      object.emplace("endCharacter", uintegerToAny(structure.endCharacter.value()));
    }
    if (structure.kind.has_value()) {
      object.emplace("kind", foldingRangeKindToAny(structure.kind.value()));
    }
    if (structure.collapsedText.has_value()) {
      object.emplace("collapsedText", stringToAny(structure.collapsedText.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToFoldingRangeRegistrationOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<FoldingRangeRegistrationOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) FoldingRangeRegistrationOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<FoldingRangeRegistrationOptions> value =
      std::make_unique<FoldingRangeRegistrationOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) FoldingRangeRegistrationOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("documentSelector");
    if (iter != object.end()) {
      value->documentSelector = anyToTextDocumentRegistrationOptions_documentSelector(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required FoldingRangeRegistrationOptions attribute: documentSelector"
      );
    }

    iter = object.find("id");
    if (iter != object.end()) {
      value->id = anyToString(*iter->second);
    }

    iter = object.find("workDoneProgress");
    if (iter != object.end()) {
      value->workDoneProgress = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::foldingRangeRegistrationOptionsToAny(
    const FoldingRangeRegistrationOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("documentSelector", textDocumentRegistrationOptions_documentSelectorToAny(structure.documentSelector));
    if (structure.id.has_value()) {
      object.emplace("id", stringToAny(structure.id.value()));
    }
    if (structure.workDoneProgress.has_value()) {
      object.emplace("workDoneProgress", booleanToAny(structure.workDoneProgress.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToDeclarationParams(
    const LSPAny &any
  ) const -> std::unique_ptr<DeclarationParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) DeclarationParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<DeclarationParams> value =
      std::make_unique<DeclarationParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 4) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) DeclarationParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("textDocument");
    if (iter != object.end()) {
      value->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DeclarationParams attribute: textDocument"
      );
    }

    iter = object.find("position");
    if (iter != object.end()) {
      value->position = anyToPosition(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DeclarationParams attribute: position"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      value->workDoneToken = anyToProgressToken(*iter->second);
    }

    iter = object.find("partialResultToken");
    if (iter != object.end()) {
      value->partialResultToken = anyToProgressToken(*iter->second);
    }

    return value;
  }

  auto LspTransformer::declarationParamsToAny(
    const DeclarationParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("textDocument", textDocumentIdentifierToAny(*structure.textDocument));
    object.emplace("position", positionToAny(*structure.position));
    if (structure.workDoneToken.has_value()) {
      object.emplace("workDoneToken", progressTokenToAny(structure.workDoneToken.value()));
    }
    if (structure.partialResultToken.has_value()) {
      object.emplace("partialResultToken", progressTokenToAny(structure.partialResultToken.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToDeclarationRegistrationOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<DeclarationRegistrationOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) DeclarationRegistrationOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<DeclarationRegistrationOptions> value =
      std::make_unique<DeclarationRegistrationOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) DeclarationRegistrationOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("documentSelector");
    if (iter != object.end()) {
      value->documentSelector = anyToTextDocumentRegistrationOptions_documentSelector(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DeclarationRegistrationOptions attribute: documentSelector"
      );
    }

    iter = object.find("id");
    if (iter != object.end()) {
      value->id = anyToString(*iter->second);
    }

    iter = object.find("workDoneProgress");
    if (iter != object.end()) {
      value->workDoneProgress = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::declarationRegistrationOptionsToAny(
    const DeclarationRegistrationOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("documentSelector", textDocumentRegistrationOptions_documentSelectorToAny(structure.documentSelector));
    if (structure.id.has_value()) {
      object.emplace("id", stringToAny(structure.id.value()));
    }
    if (structure.workDoneProgress.has_value()) {
      object.emplace("workDoneProgress", booleanToAny(structure.workDoneProgress.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToSelectionRangeParams(
    const LSPAny &any
  ) const -> std::unique_ptr<SelectionRangeParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) SelectionRangeParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<SelectionRangeParams> value =
      std::make_unique<SelectionRangeParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 4) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) SelectionRangeParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("textDocument");
    if (iter != object.end()) {
      value->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required SelectionRangeParams attribute: textDocument"
      );
    }

    iter = object.find("positions");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<std::unique_ptr<Position>> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToPosition(*elem));
      }
      value->positions = std::move(values);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required SelectionRangeParams attribute: positions"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      value->workDoneToken = anyToProgressToken(*iter->second);
    }

    iter = object.find("partialResultToken");
    if (iter != object.end()) {
      value->partialResultToken = anyToProgressToken(*iter->second);
    }

    return value;
  }

  auto LspTransformer::selectionRangeParamsToAny(
    const SelectionRangeParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("textDocument", textDocumentIdentifierToAny(*structure.textDocument));
    {
      LSPArray array;
      for (const std::unique_ptr<Position> &elem : structure.positions) {
        array.push_back(positionToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("positions", std::move(any));
    }
    if (structure.workDoneToken.has_value()) {
      object.emplace("workDoneToken", progressTokenToAny(structure.workDoneToken.value()));
    }
    if (structure.partialResultToken.has_value()) {
      object.emplace("partialResultToken", progressTokenToAny(structure.partialResultToken.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToSelectionRange(
    const LSPAny &any
  ) const -> std::unique_ptr<SelectionRange> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) SelectionRange must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<SelectionRange> value =
      std::make_unique<SelectionRange>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) SelectionRange: " + std::to_string(object.size())
      );
    }

    iter = object.find("range");
    if (iter != object.end()) {
      value->range = anyToRange(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required SelectionRange attribute: range"
      );
    }

    iter = object.find("parent");
    if (iter != object.end()) {
      value->parent = anyToSelectionRange(*iter->second);
    }

    return value;
  }

  auto LspTransformer::selectionRangeToAny(
    const SelectionRange &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("range", rangeToAny(*structure.range));
    if (structure.parent.has_value()) {
      object.emplace("parent", selectionRangeToAny(*structure.parent.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToSelectionRangeRegistrationOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<SelectionRangeRegistrationOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) SelectionRangeRegistrationOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<SelectionRangeRegistrationOptions> value =
      std::make_unique<SelectionRangeRegistrationOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) SelectionRangeRegistrationOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("documentSelector");
    if (iter != object.end()) {
      value->documentSelector = anyToTextDocumentRegistrationOptions_documentSelector(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required SelectionRangeRegistrationOptions attribute: documentSelector"
      );
    }

    iter = object.find("id");
    if (iter != object.end()) {
      value->id = anyToString(*iter->second);
    }

    iter = object.find("workDoneProgress");
    if (iter != object.end()) {
      value->workDoneProgress = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::selectionRangeRegistrationOptionsToAny(
    const SelectionRangeRegistrationOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("documentSelector", textDocumentRegistrationOptions_documentSelectorToAny(structure.documentSelector));
    if (structure.id.has_value()) {
      object.emplace("id", stringToAny(structure.id.value()));
    }
    if (structure.workDoneProgress.has_value()) {
      object.emplace("workDoneProgress", booleanToAny(structure.workDoneProgress.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToWorkDoneProgressCreateParams(
    const LSPAny &any
  ) const -> std::unique_ptr<WorkDoneProgressCreateParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) WorkDoneProgressCreateParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<WorkDoneProgressCreateParams> value =
      std::make_unique<WorkDoneProgressCreateParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) WorkDoneProgressCreateParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("token");
    if (iter != object.end()) {
      value->token = anyToProgressToken(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required WorkDoneProgressCreateParams attribute: token"
      );
    }

    return value;
  }

  auto LspTransformer::workDoneProgressCreateParamsToAny(
    const WorkDoneProgressCreateParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("token", progressTokenToAny(structure.token));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToWorkDoneProgressCancelParams(
    const LSPAny &any
  ) const -> std::unique_ptr<WorkDoneProgressCancelParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) WorkDoneProgressCancelParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<WorkDoneProgressCancelParams> value =
      std::make_unique<WorkDoneProgressCancelParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) WorkDoneProgressCancelParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("token");
    if (iter != object.end()) {
      value->token = anyToProgressToken(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required WorkDoneProgressCancelParams attribute: token"
      );
    }

    return value;
  }

  auto LspTransformer::workDoneProgressCancelParamsToAny(
    const WorkDoneProgressCancelParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("token", progressTokenToAny(structure.token));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToCallHierarchyPrepareParams(
    const LSPAny &any
  ) const -> std::unique_ptr<CallHierarchyPrepareParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) CallHierarchyPrepareParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<CallHierarchyPrepareParams> value =
      std::make_unique<CallHierarchyPrepareParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) CallHierarchyPrepareParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("textDocument");
    if (iter != object.end()) {
      value->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required CallHierarchyPrepareParams attribute: textDocument"
      );
    }

    iter = object.find("position");
    if (iter != object.end()) {
      value->position = anyToPosition(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required CallHierarchyPrepareParams attribute: position"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      value->workDoneToken = anyToProgressToken(*iter->second);
    }

    return value;
  }

  auto LspTransformer::callHierarchyPrepareParamsToAny(
    const CallHierarchyPrepareParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("textDocument", textDocumentIdentifierToAny(*structure.textDocument));
    object.emplace("position", positionToAny(*structure.position));
    if (structure.workDoneToken.has_value()) {
      object.emplace("workDoneToken", progressTokenToAny(structure.workDoneToken.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToCallHierarchyItem(
    const LSPAny &any
  ) const -> std::unique_ptr<CallHierarchyItem> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) CallHierarchyItem must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<CallHierarchyItem> value =
      std::make_unique<CallHierarchyItem>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 8) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) CallHierarchyItem: " + std::to_string(object.size())
      );
    }

    iter = object.find("name");
    if (iter != object.end()) {
      value->name = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required CallHierarchyItem attribute: name"
      );
    }

    iter = object.find("kind");
    if (iter != object.end()) {
      value->kind = anyToSymbolKind(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required CallHierarchyItem attribute: kind"
      );
    }

    iter = object.find("tags");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<SymbolTag> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToSymbolTag(*elem));
      }
      value->tags = std::move(values);
    }

    iter = object.find("detail");
    if (iter != object.end()) {
      value->detail = anyToString(*iter->second);
    }

    iter = object.find("uri");
    if (iter != object.end()) {
      value->uri = anyToDocumentUri(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required CallHierarchyItem attribute: uri"
      );
    }

    iter = object.find("range");
    if (iter != object.end()) {
      value->range = anyToRange(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required CallHierarchyItem attribute: range"
      );
    }

    iter = object.find("selectionRange");
    if (iter != object.end()) {
      value->selectionRange = anyToRange(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required CallHierarchyItem attribute: selectionRange"
      );
    }

    iter = object.find("data");
    if (iter != object.end()) {
      value->data = copy(iter->second);
    }

    return value;
  }

  auto LspTransformer::callHierarchyItemToAny(
    const CallHierarchyItem &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("name", stringToAny(structure.name));
    object.emplace("kind", symbolKindToAny(structure.kind));
    if (structure.tags.has_value()) {
      LSPArray array;
      for (const SymbolTag &elem : structure.tags.value()) {
        array.push_back(symbolTagToAny(elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("tags", std::move(any));
    }
    if (structure.detail.has_value()) {
      object.emplace("detail", stringToAny(structure.detail.value()));
    }
    object.emplace("uri", documentUriToAny(structure.uri));
    object.emplace("range", rangeToAny(*structure.range));
    object.emplace("selectionRange", rangeToAny(*structure.selectionRange));
    if (structure.data.has_value()) {
      object.emplace("data", copy(structure.data.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToCallHierarchyRegistrationOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<CallHierarchyRegistrationOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) CallHierarchyRegistrationOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<CallHierarchyRegistrationOptions> value =
      std::make_unique<CallHierarchyRegistrationOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) CallHierarchyRegistrationOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("documentSelector");
    if (iter != object.end()) {
      value->documentSelector = anyToTextDocumentRegistrationOptions_documentSelector(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required CallHierarchyRegistrationOptions attribute: documentSelector"
      );
    }

    iter = object.find("id");
    if (iter != object.end()) {
      value->id = anyToString(*iter->second);
    }

    iter = object.find("workDoneProgress");
    if (iter != object.end()) {
      value->workDoneProgress = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::callHierarchyRegistrationOptionsToAny(
    const CallHierarchyRegistrationOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("documentSelector", textDocumentRegistrationOptions_documentSelectorToAny(structure.documentSelector));
    if (structure.id.has_value()) {
      object.emplace("id", stringToAny(structure.id.value()));
    }
    if (structure.workDoneProgress.has_value()) {
      object.emplace("workDoneProgress", booleanToAny(structure.workDoneProgress.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToCallHierarchyIncomingCallsParams(
    const LSPAny &any
  ) const -> std::unique_ptr<CallHierarchyIncomingCallsParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) CallHierarchyIncomingCallsParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<CallHierarchyIncomingCallsParams> value =
      std::make_unique<CallHierarchyIncomingCallsParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) CallHierarchyIncomingCallsParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("item");
    if (iter != object.end()) {
      value->item = anyToCallHierarchyItem(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required CallHierarchyIncomingCallsParams attribute: item"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      value->workDoneToken = anyToProgressToken(*iter->second);
    }

    iter = object.find("partialResultToken");
    if (iter != object.end()) {
      value->partialResultToken = anyToProgressToken(*iter->second);
    }

    return value;
  }

  auto LspTransformer::callHierarchyIncomingCallsParamsToAny(
    const CallHierarchyIncomingCallsParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("item", callHierarchyItemToAny(*structure.item));
    if (structure.workDoneToken.has_value()) {
      object.emplace("workDoneToken", progressTokenToAny(structure.workDoneToken.value()));
    }
    if (structure.partialResultToken.has_value()) {
      object.emplace("partialResultToken", progressTokenToAny(structure.partialResultToken.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToCallHierarchyIncomingCall(
    const LSPAny &any
  ) const -> std::unique_ptr<CallHierarchyIncomingCall> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) CallHierarchyIncomingCall must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<CallHierarchyIncomingCall> value =
      std::make_unique<CallHierarchyIncomingCall>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) CallHierarchyIncomingCall: " + std::to_string(object.size())
      );
    }

    iter = object.find("from");
    if (iter != object.end()) {
      value->from = anyToCallHierarchyItem(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required CallHierarchyIncomingCall attribute: from"
      );
    }

    iter = object.find("fromRanges");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<std::unique_ptr<Range>> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToRange(*elem));
      }
      value->fromRanges = std::move(values);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required CallHierarchyIncomingCall attribute: fromRanges"
      );
    }

    return value;
  }

  auto LspTransformer::callHierarchyIncomingCallToAny(
    const CallHierarchyIncomingCall &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("from", callHierarchyItemToAny(*structure.from));
    {
      LSPArray array;
      for (const std::unique_ptr<Range> &elem : structure.fromRanges) {
        array.push_back(rangeToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("fromRanges", std::move(any));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToCallHierarchyOutgoingCallsParams(
    const LSPAny &any
  ) const -> std::unique_ptr<CallHierarchyOutgoingCallsParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) CallHierarchyOutgoingCallsParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<CallHierarchyOutgoingCallsParams> value =
      std::make_unique<CallHierarchyOutgoingCallsParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) CallHierarchyOutgoingCallsParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("item");
    if (iter != object.end()) {
      value->item = anyToCallHierarchyItem(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required CallHierarchyOutgoingCallsParams attribute: item"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      value->workDoneToken = anyToProgressToken(*iter->second);
    }

    iter = object.find("partialResultToken");
    if (iter != object.end()) {
      value->partialResultToken = anyToProgressToken(*iter->second);
    }

    return value;
  }

  auto LspTransformer::callHierarchyOutgoingCallsParamsToAny(
    const CallHierarchyOutgoingCallsParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("item", callHierarchyItemToAny(*structure.item));
    if (structure.workDoneToken.has_value()) {
      object.emplace("workDoneToken", progressTokenToAny(structure.workDoneToken.value()));
    }
    if (structure.partialResultToken.has_value()) {
      object.emplace("partialResultToken", progressTokenToAny(structure.partialResultToken.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToCallHierarchyOutgoingCall(
    const LSPAny &any
  ) const -> std::unique_ptr<CallHierarchyOutgoingCall> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) CallHierarchyOutgoingCall must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<CallHierarchyOutgoingCall> value =
      std::make_unique<CallHierarchyOutgoingCall>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) CallHierarchyOutgoingCall: " + std::to_string(object.size())
      );
    }

    iter = object.find("to");
    if (iter != object.end()) {
      value->to = anyToCallHierarchyItem(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required CallHierarchyOutgoingCall attribute: to"
      );
    }

    iter = object.find("fromRanges");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<std::unique_ptr<Range>> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToRange(*elem));
      }
      value->fromRanges = std::move(values);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required CallHierarchyOutgoingCall attribute: fromRanges"
      );
    }

    return value;
  }

  auto LspTransformer::callHierarchyOutgoingCallToAny(
    const CallHierarchyOutgoingCall &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("to", callHierarchyItemToAny(*structure.to));
    {
      LSPArray array;
      for (const std::unique_ptr<Range> &elem : structure.fromRanges) {
        array.push_back(rangeToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("fromRanges", std::move(any));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToSemanticTokensParams(
    const LSPAny &any
  ) const -> std::unique_ptr<SemanticTokensParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) SemanticTokensParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<SemanticTokensParams> value =
      std::make_unique<SemanticTokensParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) SemanticTokensParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("textDocument");
    if (iter != object.end()) {
      value->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required SemanticTokensParams attribute: textDocument"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      value->workDoneToken = anyToProgressToken(*iter->second);
    }

    iter = object.find("partialResultToken");
    if (iter != object.end()) {
      value->partialResultToken = anyToProgressToken(*iter->second);
    }

    return value;
  }

  auto LspTransformer::semanticTokensParamsToAny(
    const SemanticTokensParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("textDocument", textDocumentIdentifierToAny(*structure.textDocument));
    if (structure.workDoneToken.has_value()) {
      object.emplace("workDoneToken", progressTokenToAny(structure.workDoneToken.value()));
    }
    if (structure.partialResultToken.has_value()) {
      object.emplace("partialResultToken", progressTokenToAny(structure.partialResultToken.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToSemanticTokens(
    const LSPAny &any
  ) const -> std::unique_ptr<SemanticTokens> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) SemanticTokens must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<SemanticTokens> value =
      std::make_unique<SemanticTokens>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) SemanticTokens: " + std::to_string(object.size())
      );
    }

    iter = object.find("resultId");
    if (iter != object.end()) {
      value->resultId = anyToString(*iter->second);
    }

    iter = object.find("data");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<uinteger_t> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToUInteger(*elem));
      }
      value->data = std::move(values);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required SemanticTokens attribute: data"
      );
    }

    return value;
  }

  auto LspTransformer::semanticTokensToAny(
    const SemanticTokens &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.resultId.has_value()) {
      object.emplace("resultId", stringToAny(structure.resultId.value()));
    }
    {
      LSPArray array;
      for (const uinteger_t &elem : structure.data) {
        array.push_back(uintegerToAny(elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("data", std::move(any));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToSemanticTokensPartialResult(
    const LSPAny &any
  ) const -> std::unique_ptr<SemanticTokensPartialResult> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) SemanticTokensPartialResult must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<SemanticTokensPartialResult> value =
      std::make_unique<SemanticTokensPartialResult>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) SemanticTokensPartialResult: " + std::to_string(object.size())
      );
    }

    iter = object.find("data");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<uinteger_t> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToUInteger(*elem));
      }
      value->data = std::move(values);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required SemanticTokensPartialResult attribute: data"
      );
    }

    return value;
  }

  auto LspTransformer::semanticTokensPartialResultToAny(
    const SemanticTokensPartialResult &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    {
      LSPArray array;
      for (const uinteger_t &elem : structure.data) {
        array.push_back(uintegerToAny(elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("data", std::move(any));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToSemanticTokensRegistrationOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<SemanticTokensRegistrationOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) SemanticTokensRegistrationOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<SemanticTokensRegistrationOptions> value =
      std::make_unique<SemanticTokensRegistrationOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 6) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) SemanticTokensRegistrationOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("documentSelector");
    if (iter != object.end()) {
      value->documentSelector = anyToTextDocumentRegistrationOptions_documentSelector(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required SemanticTokensRegistrationOptions attribute: documentSelector"
      );
    }

    iter = object.find("legend");
    if (iter != object.end()) {
      value->legend = anyToSemanticTokensLegend(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required SemanticTokensRegistrationOptions attribute: legend"
      );
    }

    iter = object.find("range");
    if (iter != object.end()) {
      value->range = anyToSemanticTokensOptions_range(*iter->second);
    }

    iter = object.find("full");
    if (iter != object.end()) {
      value->full = anyToSemanticTokensOptions_full(*iter->second);
    }

    iter = object.find("id");
    if (iter != object.end()) {
      value->id = anyToString(*iter->second);
    }

    iter = object.find("workDoneProgress");
    if (iter != object.end()) {
      value->workDoneProgress = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::semanticTokensRegistrationOptionsToAny(
    const SemanticTokensRegistrationOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("documentSelector", textDocumentRegistrationOptions_documentSelectorToAny(structure.documentSelector));
    object.emplace("legend", semanticTokensLegendToAny(*structure.legend));
    if (structure.range.has_value()) {
      object.emplace("range", semanticTokensOptions_rangeToAny(structure.range.value()));
    }
    if (structure.full.has_value()) {
      object.emplace("full", semanticTokensOptions_fullToAny(structure.full.value()));
    }
    if (structure.id.has_value()) {
      object.emplace("id", stringToAny(structure.id.value()));
    }
    if (structure.workDoneProgress.has_value()) {
      object.emplace("workDoneProgress", booleanToAny(structure.workDoneProgress.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToSemanticTokensDeltaParams(
    const LSPAny &any
  ) const -> std::unique_ptr<SemanticTokensDeltaParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) SemanticTokensDeltaParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<SemanticTokensDeltaParams> value =
      std::make_unique<SemanticTokensDeltaParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 4) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) SemanticTokensDeltaParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("textDocument");
    if (iter != object.end()) {
      value->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required SemanticTokensDeltaParams attribute: textDocument"
      );
    }

    iter = object.find("previousResultId");
    if (iter != object.end()) {
      value->previousResultId = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required SemanticTokensDeltaParams attribute: previousResultId"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      value->workDoneToken = anyToProgressToken(*iter->second);
    }

    iter = object.find("partialResultToken");
    if (iter != object.end()) {
      value->partialResultToken = anyToProgressToken(*iter->second);
    }

    return value;
  }

  auto LspTransformer::semanticTokensDeltaParamsToAny(
    const SemanticTokensDeltaParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("textDocument", textDocumentIdentifierToAny(*structure.textDocument));
    object.emplace("previousResultId", stringToAny(structure.previousResultId));
    if (structure.workDoneToken.has_value()) {
      object.emplace("workDoneToken", progressTokenToAny(structure.workDoneToken.value()));
    }
    if (structure.partialResultToken.has_value()) {
      object.emplace("partialResultToken", progressTokenToAny(structure.partialResultToken.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToSemanticTokensDelta(
    const LSPAny &any
  ) const -> std::unique_ptr<SemanticTokensDelta> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) SemanticTokensDelta must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<SemanticTokensDelta> value =
      std::make_unique<SemanticTokensDelta>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) SemanticTokensDelta: " + std::to_string(object.size())
      );
    }

    iter = object.find("resultId");
    if (iter != object.end()) {
      value->resultId = anyToString(*iter->second);
    }

    iter = object.find("edits");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<std::unique_ptr<SemanticTokensEdit>> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToSemanticTokensEdit(*elem));
      }
      value->edits = std::move(values);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required SemanticTokensDelta attribute: edits"
      );
    }

    return value;
  }

  auto LspTransformer::semanticTokensDeltaToAny(
    const SemanticTokensDelta &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.resultId.has_value()) {
      object.emplace("resultId", stringToAny(structure.resultId.value()));
    }
    {
      LSPArray array;
      for (const std::unique_ptr<SemanticTokensEdit> &elem : structure.edits) {
        array.push_back(semanticTokensEditToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("edits", std::move(any));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToSemanticTokensDeltaPartialResult(
    const LSPAny &any
  ) const -> std::unique_ptr<SemanticTokensDeltaPartialResult> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) SemanticTokensDeltaPartialResult must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<SemanticTokensDeltaPartialResult> value =
      std::make_unique<SemanticTokensDeltaPartialResult>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) SemanticTokensDeltaPartialResult: " + std::to_string(object.size())
      );
    }

    iter = object.find("edits");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<std::unique_ptr<SemanticTokensEdit>> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToSemanticTokensEdit(*elem));
      }
      value->edits = std::move(values);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required SemanticTokensDeltaPartialResult attribute: edits"
      );
    }

    return value;
  }

  auto LspTransformer::semanticTokensDeltaPartialResultToAny(
    const SemanticTokensDeltaPartialResult &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    {
      LSPArray array;
      for (const std::unique_ptr<SemanticTokensEdit> &elem : structure.edits) {
        array.push_back(semanticTokensEditToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("edits", std::move(any));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToSemanticTokensRangeParams(
    const LSPAny &any
  ) const -> std::unique_ptr<SemanticTokensRangeParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) SemanticTokensRangeParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<SemanticTokensRangeParams> value =
      std::make_unique<SemanticTokensRangeParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 4) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) SemanticTokensRangeParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("textDocument");
    if (iter != object.end()) {
      value->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required SemanticTokensRangeParams attribute: textDocument"
      );
    }

    iter = object.find("range");
    if (iter != object.end()) {
      value->range = anyToRange(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required SemanticTokensRangeParams attribute: range"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      value->workDoneToken = anyToProgressToken(*iter->second);
    }

    iter = object.find("partialResultToken");
    if (iter != object.end()) {
      value->partialResultToken = anyToProgressToken(*iter->second);
    }

    return value;
  }

  auto LspTransformer::semanticTokensRangeParamsToAny(
    const SemanticTokensRangeParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("textDocument", textDocumentIdentifierToAny(*structure.textDocument));
    object.emplace("range", rangeToAny(*structure.range));
    if (structure.workDoneToken.has_value()) {
      object.emplace("workDoneToken", progressTokenToAny(structure.workDoneToken.value()));
    }
    if (structure.partialResultToken.has_value()) {
      object.emplace("partialResultToken", progressTokenToAny(structure.partialResultToken.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToShowDocumentParams(
    const LSPAny &any
  ) const -> std::unique_ptr<ShowDocumentParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) ShowDocumentParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<ShowDocumentParams> value =
      std::make_unique<ShowDocumentParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 4) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) ShowDocumentParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("uri");
    if (iter != object.end()) {
      value->uri = anyToURI(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required ShowDocumentParams attribute: uri"
      );
    }

    iter = object.find("external");
    if (iter != object.end()) {
      value->external = anyToBoolean(*iter->second);
    }

    iter = object.find("takeFocus");
    if (iter != object.end()) {
      value->takeFocus = anyToBoolean(*iter->second);
    }

    iter = object.find("selection");
    if (iter != object.end()) {
      value->selection = anyToRange(*iter->second);
    }

    return value;
  }

  auto LspTransformer::showDocumentParamsToAny(
    const ShowDocumentParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("uri", uriToAny(structure.uri));
    if (structure.external.has_value()) {
      object.emplace("external", booleanToAny(structure.external.value()));
    }
    if (structure.takeFocus.has_value()) {
      object.emplace("takeFocus", booleanToAny(structure.takeFocus.value()));
    }
    if (structure.selection.has_value()) {
      object.emplace("selection", rangeToAny(*structure.selection.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToShowDocumentResult(
    const LSPAny &any
  ) const -> std::unique_ptr<ShowDocumentResult> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) ShowDocumentResult must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<ShowDocumentResult> value =
      std::make_unique<ShowDocumentResult>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) ShowDocumentResult: " + std::to_string(object.size())
      );
    }

    iter = object.find("success");
    if (iter != object.end()) {
      value->success = anyToBoolean(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required ShowDocumentResult attribute: success"
      );
    }

    return value;
  }

  auto LspTransformer::showDocumentResultToAny(
    const ShowDocumentResult &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("success", booleanToAny(structure.success));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToLinkedEditingRangeParams(
    const LSPAny &any
  ) const -> std::unique_ptr<LinkedEditingRangeParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) LinkedEditingRangeParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<LinkedEditingRangeParams> value =
      std::make_unique<LinkedEditingRangeParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) LinkedEditingRangeParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("textDocument");
    if (iter != object.end()) {
      value->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required LinkedEditingRangeParams attribute: textDocument"
      );
    }

    iter = object.find("position");
    if (iter != object.end()) {
      value->position = anyToPosition(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required LinkedEditingRangeParams attribute: position"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      value->workDoneToken = anyToProgressToken(*iter->second);
    }

    return value;
  }

  auto LspTransformer::linkedEditingRangeParamsToAny(
    const LinkedEditingRangeParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("textDocument", textDocumentIdentifierToAny(*structure.textDocument));
    object.emplace("position", positionToAny(*structure.position));
    if (structure.workDoneToken.has_value()) {
      object.emplace("workDoneToken", progressTokenToAny(structure.workDoneToken.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToLinkedEditingRanges(
    const LSPAny &any
  ) const -> std::unique_ptr<LinkedEditingRanges> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) LinkedEditingRanges must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<LinkedEditingRanges> value =
      std::make_unique<LinkedEditingRanges>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) LinkedEditingRanges: " + std::to_string(object.size())
      );
    }

    iter = object.find("ranges");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<std::unique_ptr<Range>> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToRange(*elem));
      }
      value->ranges = std::move(values);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required LinkedEditingRanges attribute: ranges"
      );
    }

    iter = object.find("wordPattern");
    if (iter != object.end()) {
      value->wordPattern = anyToString(*iter->second);
    }

    return value;
  }

  auto LspTransformer::linkedEditingRangesToAny(
    const LinkedEditingRanges &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    {
      LSPArray array;
      for (const std::unique_ptr<Range> &elem : structure.ranges) {
        array.push_back(rangeToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("ranges", std::move(any));
    }
    if (structure.wordPattern.has_value()) {
      object.emplace("wordPattern", stringToAny(structure.wordPattern.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToLinkedEditingRangeRegistrationOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<LinkedEditingRangeRegistrationOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) LinkedEditingRangeRegistrationOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<LinkedEditingRangeRegistrationOptions> value =
      std::make_unique<LinkedEditingRangeRegistrationOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) LinkedEditingRangeRegistrationOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("documentSelector");
    if (iter != object.end()) {
      value->documentSelector = anyToTextDocumentRegistrationOptions_documentSelector(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required LinkedEditingRangeRegistrationOptions attribute: documentSelector"
      );
    }

    iter = object.find("id");
    if (iter != object.end()) {
      value->id = anyToString(*iter->second);
    }

    iter = object.find("workDoneProgress");
    if (iter != object.end()) {
      value->workDoneProgress = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::linkedEditingRangeRegistrationOptionsToAny(
    const LinkedEditingRangeRegistrationOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("documentSelector", textDocumentRegistrationOptions_documentSelectorToAny(structure.documentSelector));
    if (structure.id.has_value()) {
      object.emplace("id", stringToAny(structure.id.value()));
    }
    if (structure.workDoneProgress.has_value()) {
      object.emplace("workDoneProgress", booleanToAny(structure.workDoneProgress.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToCreateFilesParams(
    const LSPAny &any
  ) const -> std::unique_ptr<CreateFilesParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) CreateFilesParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<CreateFilesParams> value =
      std::make_unique<CreateFilesParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) CreateFilesParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("files");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<std::unique_ptr<FileCreate>> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToFileCreate(*elem));
      }
      value->files = std::move(values);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required CreateFilesParams attribute: files"
      );
    }

    return value;
  }

  auto LspTransformer::createFilesParamsToAny(
    const CreateFilesParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    {
      LSPArray array;
      for (const std::unique_ptr<FileCreate> &elem : structure.files) {
        array.push_back(fileCreateToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("files", std::move(any));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToWorkspaceEdit_documentChanges(
    const LSPAny &any
  ) const -> WorkspaceEdit_documentChanges {
    WorkspaceEdit_documentChanges value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::OBJECT_TYPE: {
      try {
        value = anyToTextDocumentEdit(any);
      } catch (LspException &e) {
        try {
          value = anyToCreateFile(any);
        } catch (LspException &e) {
          try {
            value = anyToRenameFile(any);
          } catch (LspException &e) {
            try {
              value = anyToDeleteFile(any);
            } catch (LspException &e) {
              throw LSP_EXCEPTION(
                ErrorCodes::INVALID_PARAMS,
                "Failed to transform LSPAny to WorkspaceEdit_documentChanges"
              );
            }
          }
        }
      }
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) WorkspaceEdit_documentChanges: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::workspaceEdit_documentChangesToAny(
    const WorkspaceEdit_documentChanges &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<WorkspaceEdit_documentChangesType>(variant.index())) {
    case WorkspaceEdit_documentChangesType::TEXT_DOCUMENT_EDIT: {
      return textDocumentEditToAny(
        *std::get<std::unique_ptr<TextDocumentEdit>>(variant)
      );
    }
    case WorkspaceEdit_documentChangesType::CREATE_FILE: {
      return createFileToAny(
        *std::get<std::unique_ptr<CreateFile>>(variant)
      );
    }
    case WorkspaceEdit_documentChangesType::RENAME_FILE: {
      return renameFileToAny(
        *std::get<std::unique_ptr<RenameFile>>(variant)
      );
    }
    case WorkspaceEdit_documentChangesType::DELETE_FILE: {
      return deleteFileToAny(
        *std::get<std::unique_ptr<DeleteFile>>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported WorkspaceEdit_documentChangesType: " +
         WorkspaceEdit_documentChangesTypeNames.at(static_cast<WorkspaceEdit_documentChangesType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToWorkspaceEdit(
    const LSPAny &any
  ) const -> std::unique_ptr<WorkspaceEdit> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) WorkspaceEdit must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<WorkspaceEdit> value =
      std::make_unique<WorkspaceEdit>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) WorkspaceEdit: " + std::to_string(object.size())
      );
    }

    iter = object.find("changes");
    if (iter != object.end()) {
      const LSPObject &object_map = std::get<LSPObject>(*iter->second);
      std::map<DocumentUri, std::vector<std::unique_ptr<TextEdit>>> map;
      for (const auto &[map_key, map_value] : object_map) {
        std::vector<std::unique_ptr<TextEdit>> array;
        for (const std::unique_ptr<LSPAny> &elem : std::get<LSPArray>(*map_value)) {
          array.push_back(anyToTextEdit(*elem));
        }
        map.emplace(map_key, std::move(array));
      }
      value->changes = std::move(map);
    }

    iter = object.find("documentChanges");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<WorkspaceEdit_documentChanges> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToWorkspaceEdit_documentChanges(*elem));
      }
      value->documentChanges = std::move(values);
    }

    iter = object.find("changeAnnotations");
    if (iter != object.end()) {
      const LSPObject &object_map = std::get<LSPObject>(*iter->second);
      std::map<ChangeAnnotationIdentifier, std::unique_ptr<ChangeAnnotation>> map;
      for (const auto &[map_key, map_value] : object_map) {
        map.emplace(map_key, anyToChangeAnnotation(*map_value));
      }
      value->changeAnnotations = std::move(map);
    }

    return value;
  }

  auto LspTransformer::workspaceEditToAny(
    const WorkspaceEdit &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.changes.has_value()) {
      LSPObject map;
      for (const auto &[mapKey, mapValue] : structure.changes.value()) {
        LSPArray array;
        for (const std::unique_ptr<TextEdit> &arrayElem : mapValue) {
          array.push_back(textEditToAny(*arrayElem));
        }
        std::unique_ptr<LSPAny> arrayAny = std::make_unique<LSPAny>();
        (*arrayAny) = std::move(array);
        map.emplace(mapKey, std::move(arrayAny));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(map);
      object.emplace("changes", std::move(any));
    }
    if (structure.documentChanges.has_value()) {
      LSPArray array;
      for (const WorkspaceEdit_documentChanges &elem : structure.documentChanges.value()) {
        array.push_back(workspaceEdit_documentChangesToAny(elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("documentChanges", std::move(any));
    }
    if (structure.changeAnnotations.has_value()) {
      LSPObject map;
      for (const auto &[mapKey, mapValue] : structure.changeAnnotations.value()) {
        map.emplace(mapKey, changeAnnotationToAny(*mapValue));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(map);
      object.emplace("changeAnnotations", std::move(any));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToFileOperationRegistrationOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<FileOperationRegistrationOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) FileOperationRegistrationOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<FileOperationRegistrationOptions> value =
      std::make_unique<FileOperationRegistrationOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) FileOperationRegistrationOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("filters");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<std::unique_ptr<FileOperationFilter>> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToFileOperationFilter(*elem));
      }
      value->filters = std::move(values);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required FileOperationRegistrationOptions attribute: filters"
      );
    }

    return value;
  }

  auto LspTransformer::fileOperationRegistrationOptionsToAny(
    const FileOperationRegistrationOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    {
      LSPArray array;
      for (const std::unique_ptr<FileOperationFilter> &elem : structure.filters) {
        array.push_back(fileOperationFilterToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("filters", std::move(any));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToRenameFilesParams(
    const LSPAny &any
  ) const -> std::unique_ptr<RenameFilesParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) RenameFilesParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<RenameFilesParams> value =
      std::make_unique<RenameFilesParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) RenameFilesParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("files");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<std::unique_ptr<FileRename>> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToFileRename(*elem));
      }
      value->files = std::move(values);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required RenameFilesParams attribute: files"
      );
    }

    return value;
  }

  auto LspTransformer::renameFilesParamsToAny(
    const RenameFilesParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    {
      LSPArray array;
      for (const std::unique_ptr<FileRename> &elem : structure.files) {
        array.push_back(fileRenameToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("files", std::move(any));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToDeleteFilesParams(
    const LSPAny &any
  ) const -> std::unique_ptr<DeleteFilesParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) DeleteFilesParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<DeleteFilesParams> value =
      std::make_unique<DeleteFilesParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) DeleteFilesParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("files");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<std::unique_ptr<FileDelete>> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToFileDelete(*elem));
      }
      value->files = std::move(values);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DeleteFilesParams attribute: files"
      );
    }

    return value;
  }

  auto LspTransformer::deleteFilesParamsToAny(
    const DeleteFilesParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    {
      LSPArray array;
      for (const std::unique_ptr<FileDelete> &elem : structure.files) {
        array.push_back(fileDeleteToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("files", std::move(any));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToMonikerParams(
    const LSPAny &any
  ) const -> std::unique_ptr<MonikerParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) MonikerParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<MonikerParams> value =
      std::make_unique<MonikerParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 4) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) MonikerParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("textDocument");
    if (iter != object.end()) {
      value->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required MonikerParams attribute: textDocument"
      );
    }

    iter = object.find("position");
    if (iter != object.end()) {
      value->position = anyToPosition(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required MonikerParams attribute: position"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      value->workDoneToken = anyToProgressToken(*iter->second);
    }

    iter = object.find("partialResultToken");
    if (iter != object.end()) {
      value->partialResultToken = anyToProgressToken(*iter->second);
    }

    return value;
  }

  auto LspTransformer::monikerParamsToAny(
    const MonikerParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("textDocument", textDocumentIdentifierToAny(*structure.textDocument));
    object.emplace("position", positionToAny(*structure.position));
    if (structure.workDoneToken.has_value()) {
      object.emplace("workDoneToken", progressTokenToAny(structure.workDoneToken.value()));
    }
    if (structure.partialResultToken.has_value()) {
      object.emplace("partialResultToken", progressTokenToAny(structure.partialResultToken.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToMoniker(
    const LSPAny &any
  ) const -> std::unique_ptr<Moniker> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) Moniker must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<Moniker> value =
      std::make_unique<Moniker>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 4) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) Moniker: " + std::to_string(object.size())
      );
    }

    iter = object.find("scheme");
    if (iter != object.end()) {
      value->scheme = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required Moniker attribute: scheme"
      );
    }

    iter = object.find("identifier");
    if (iter != object.end()) {
      value->identifier = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required Moniker attribute: identifier"
      );
    }

    iter = object.find("unique");
    if (iter != object.end()) {
      value->unique = anyToUniquenessLevel(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required Moniker attribute: unique"
      );
    }

    iter = object.find("kind");
    if (iter != object.end()) {
      value->kind = anyToMonikerKind(*iter->second);
    }

    return value;
  }

  auto LspTransformer::monikerToAny(
    const Moniker &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("scheme", stringToAny(structure.scheme));
    object.emplace("identifier", stringToAny(structure.identifier));
    object.emplace("unique", uniquenessLevelToAny(structure.unique));
    if (structure.kind.has_value()) {
      object.emplace("kind", monikerKindToAny(structure.kind.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToMonikerRegistrationOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<MonikerRegistrationOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) MonikerRegistrationOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<MonikerRegistrationOptions> value =
      std::make_unique<MonikerRegistrationOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) MonikerRegistrationOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("documentSelector");
    if (iter != object.end()) {
      value->documentSelector = anyToTextDocumentRegistrationOptions_documentSelector(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required MonikerRegistrationOptions attribute: documentSelector"
      );
    }

    iter = object.find("workDoneProgress");
    if (iter != object.end()) {
      value->workDoneProgress = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::monikerRegistrationOptionsToAny(
    const MonikerRegistrationOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("documentSelector", textDocumentRegistrationOptions_documentSelectorToAny(structure.documentSelector));
    if (structure.workDoneProgress.has_value()) {
      object.emplace("workDoneProgress", booleanToAny(structure.workDoneProgress.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToTypeHierarchyPrepareParams(
    const LSPAny &any
  ) const -> std::unique_ptr<TypeHierarchyPrepareParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) TypeHierarchyPrepareParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<TypeHierarchyPrepareParams> value =
      std::make_unique<TypeHierarchyPrepareParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) TypeHierarchyPrepareParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("textDocument");
    if (iter != object.end()) {
      value->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required TypeHierarchyPrepareParams attribute: textDocument"
      );
    }

    iter = object.find("position");
    if (iter != object.end()) {
      value->position = anyToPosition(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required TypeHierarchyPrepareParams attribute: position"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      value->workDoneToken = anyToProgressToken(*iter->second);
    }

    return value;
  }

  auto LspTransformer::typeHierarchyPrepareParamsToAny(
    const TypeHierarchyPrepareParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("textDocument", textDocumentIdentifierToAny(*structure.textDocument));
    object.emplace("position", positionToAny(*structure.position));
    if (structure.workDoneToken.has_value()) {
      object.emplace("workDoneToken", progressTokenToAny(structure.workDoneToken.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToTypeHierarchyItem(
    const LSPAny &any
  ) const -> std::unique_ptr<TypeHierarchyItem> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) TypeHierarchyItem must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<TypeHierarchyItem> value =
      std::make_unique<TypeHierarchyItem>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 8) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) TypeHierarchyItem: " + std::to_string(object.size())
      );
    }

    iter = object.find("name");
    if (iter != object.end()) {
      value->name = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required TypeHierarchyItem attribute: name"
      );
    }

    iter = object.find("kind");
    if (iter != object.end()) {
      value->kind = anyToSymbolKind(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required TypeHierarchyItem attribute: kind"
      );
    }

    iter = object.find("tags");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<SymbolTag> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToSymbolTag(*elem));
      }
      value->tags = std::move(values);
    }

    iter = object.find("detail");
    if (iter != object.end()) {
      value->detail = anyToString(*iter->second);
    }

    iter = object.find("uri");
    if (iter != object.end()) {
      value->uri = anyToDocumentUri(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required TypeHierarchyItem attribute: uri"
      );
    }

    iter = object.find("range");
    if (iter != object.end()) {
      value->range = anyToRange(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required TypeHierarchyItem attribute: range"
      );
    }

    iter = object.find("selectionRange");
    if (iter != object.end()) {
      value->selectionRange = anyToRange(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required TypeHierarchyItem attribute: selectionRange"
      );
    }

    iter = object.find("data");
    if (iter != object.end()) {
      value->data = copy(iter->second);
    }

    return value;
  }

  auto LspTransformer::typeHierarchyItemToAny(
    const TypeHierarchyItem &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("name", stringToAny(structure.name));
    object.emplace("kind", symbolKindToAny(structure.kind));
    if (structure.tags.has_value()) {
      LSPArray array;
      for (const SymbolTag &elem : structure.tags.value()) {
        array.push_back(symbolTagToAny(elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("tags", std::move(any));
    }
    if (structure.detail.has_value()) {
      object.emplace("detail", stringToAny(structure.detail.value()));
    }
    object.emplace("uri", documentUriToAny(structure.uri));
    object.emplace("range", rangeToAny(*structure.range));
    object.emplace("selectionRange", rangeToAny(*structure.selectionRange));
    if (structure.data.has_value()) {
      object.emplace("data", copy(structure.data.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToTypeHierarchyRegistrationOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<TypeHierarchyRegistrationOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) TypeHierarchyRegistrationOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<TypeHierarchyRegistrationOptions> value =
      std::make_unique<TypeHierarchyRegistrationOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) TypeHierarchyRegistrationOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("documentSelector");
    if (iter != object.end()) {
      value->documentSelector = anyToTextDocumentRegistrationOptions_documentSelector(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required TypeHierarchyRegistrationOptions attribute: documentSelector"
      );
    }

    iter = object.find("id");
    if (iter != object.end()) {
      value->id = anyToString(*iter->second);
    }

    iter = object.find("workDoneProgress");
    if (iter != object.end()) {
      value->workDoneProgress = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::typeHierarchyRegistrationOptionsToAny(
    const TypeHierarchyRegistrationOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("documentSelector", textDocumentRegistrationOptions_documentSelectorToAny(structure.documentSelector));
    if (structure.id.has_value()) {
      object.emplace("id", stringToAny(structure.id.value()));
    }
    if (structure.workDoneProgress.has_value()) {
      object.emplace("workDoneProgress", booleanToAny(structure.workDoneProgress.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToTypeHierarchySupertypesParams(
    const LSPAny &any
  ) const -> std::unique_ptr<TypeHierarchySupertypesParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) TypeHierarchySupertypesParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<TypeHierarchySupertypesParams> value =
      std::make_unique<TypeHierarchySupertypesParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) TypeHierarchySupertypesParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("item");
    if (iter != object.end()) {
      value->item = anyToTypeHierarchyItem(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required TypeHierarchySupertypesParams attribute: item"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      value->workDoneToken = anyToProgressToken(*iter->second);
    }

    iter = object.find("partialResultToken");
    if (iter != object.end()) {
      value->partialResultToken = anyToProgressToken(*iter->second);
    }

    return value;
  }

  auto LspTransformer::typeHierarchySupertypesParamsToAny(
    const TypeHierarchySupertypesParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("item", typeHierarchyItemToAny(*structure.item));
    if (structure.workDoneToken.has_value()) {
      object.emplace("workDoneToken", progressTokenToAny(structure.workDoneToken.value()));
    }
    if (structure.partialResultToken.has_value()) {
      object.emplace("partialResultToken", progressTokenToAny(structure.partialResultToken.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToTypeHierarchySubtypesParams(
    const LSPAny &any
  ) const -> std::unique_ptr<TypeHierarchySubtypesParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) TypeHierarchySubtypesParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<TypeHierarchySubtypesParams> value =
      std::make_unique<TypeHierarchySubtypesParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) TypeHierarchySubtypesParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("item");
    if (iter != object.end()) {
      value->item = anyToTypeHierarchyItem(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required TypeHierarchySubtypesParams attribute: item"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      value->workDoneToken = anyToProgressToken(*iter->second);
    }

    iter = object.find("partialResultToken");
    if (iter != object.end()) {
      value->partialResultToken = anyToProgressToken(*iter->second);
    }

    return value;
  }

  auto LspTransformer::typeHierarchySubtypesParamsToAny(
    const TypeHierarchySubtypesParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("item", typeHierarchyItemToAny(*structure.item));
    if (structure.workDoneToken.has_value()) {
      object.emplace("workDoneToken", progressTokenToAny(structure.workDoneToken.value()));
    }
    if (structure.partialResultToken.has_value()) {
      object.emplace("partialResultToken", progressTokenToAny(structure.partialResultToken.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToInlineValueParams(
    const LSPAny &any
  ) const -> std::unique_ptr<InlineValueParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) InlineValueParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<InlineValueParams> value =
      std::make_unique<InlineValueParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 4) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) InlineValueParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("textDocument");
    if (iter != object.end()) {
      value->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required InlineValueParams attribute: textDocument"
      );
    }

    iter = object.find("range");
    if (iter != object.end()) {
      value->range = anyToRange(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required InlineValueParams attribute: range"
      );
    }

    iter = object.find("context");
    if (iter != object.end()) {
      value->context = anyToInlineValueContext(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required InlineValueParams attribute: context"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      value->workDoneToken = anyToProgressToken(*iter->second);
    }

    return value;
  }

  auto LspTransformer::inlineValueParamsToAny(
    const InlineValueParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("textDocument", textDocumentIdentifierToAny(*structure.textDocument));
    object.emplace("range", rangeToAny(*structure.range));
    object.emplace("context", inlineValueContextToAny(*structure.context));
    if (structure.workDoneToken.has_value()) {
      object.emplace("workDoneToken", progressTokenToAny(structure.workDoneToken.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToInlineValueRegistrationOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<InlineValueRegistrationOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) InlineValueRegistrationOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<InlineValueRegistrationOptions> value =
      std::make_unique<InlineValueRegistrationOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) InlineValueRegistrationOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("documentSelector");
    if (iter != object.end()) {
      value->documentSelector = anyToTextDocumentRegistrationOptions_documentSelector(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required InlineValueRegistrationOptions attribute: documentSelector"
      );
    }

    iter = object.find("id");
    if (iter != object.end()) {
      value->id = anyToString(*iter->second);
    }

    iter = object.find("workDoneProgress");
    if (iter != object.end()) {
      value->workDoneProgress = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::inlineValueRegistrationOptionsToAny(
    const InlineValueRegistrationOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("documentSelector", textDocumentRegistrationOptions_documentSelectorToAny(structure.documentSelector));
    if (structure.id.has_value()) {
      object.emplace("id", stringToAny(structure.id.value()));
    }
    if (structure.workDoneProgress.has_value()) {
      object.emplace("workDoneProgress", booleanToAny(structure.workDoneProgress.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToInlayHintParams(
    const LSPAny &any
  ) const -> std::unique_ptr<InlayHintParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) InlayHintParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<InlayHintParams> value =
      std::make_unique<InlayHintParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) InlayHintParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("textDocument");
    if (iter != object.end()) {
      value->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required InlayHintParams attribute: textDocument"
      );
    }

    iter = object.find("range");
    if (iter != object.end()) {
      value->range = anyToRange(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required InlayHintParams attribute: range"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      value->workDoneToken = anyToProgressToken(*iter->second);
    }

    return value;
  }

  auto LspTransformer::inlayHintParamsToAny(
    const InlayHintParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("textDocument", textDocumentIdentifierToAny(*structure.textDocument));
    object.emplace("range", rangeToAny(*structure.range));
    if (structure.workDoneToken.has_value()) {
      object.emplace("workDoneToken", progressTokenToAny(structure.workDoneToken.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToInlayHint_label(
    const LSPAny &any
  ) const -> InlayHint_label {
    InlayHint_label value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::ARRAY_TYPE: {
      try {
        std::vector<std::unique_ptr<InlayHintLabelPart>> values;
        for (const std::unique_ptr<LSPAny> &elem
            : std::get<LSPArray>(any)) {
          values.push_back(anyToInlayHintLabelPart(*elem));
        }
        value = std::move(values);
      } catch (LspException &e) {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          "Failed to transform LSPAny to array"
        );
      }
      break;
    }
    case LSPAnyType::STRING_TYPE: {
      value = anyToString(any);
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) InlayHint_label: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::inlayHint_labelToAny(
    const InlayHint_label &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<InlayHint_labelType>(variant.index())) {
    case InlayHint_labelType::STRING_TYPE: {
      return stringToAny(
        std::get<string_t>(variant)
      );
    }
    case InlayHint_labelType::INLAY_HINT_LABEL_PART_ARRAY: {
      LSPArray array;
      for (const std::unique_ptr<InlayHintLabelPart> &elem
          : std::get<std::vector<std::unique_ptr<InlayHintLabelPart>>>(variant)) {
        array.push_back(inlayHintLabelPartToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      return any;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported InlayHint_labelType: " +
         InlayHint_labelTypeNames.at(static_cast<InlayHint_labelType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToInlayHint_tooltip(
    const LSPAny &any
  ) const -> InlayHint_tooltip {
    InlayHint_tooltip value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::OBJECT_TYPE: {
      try {
        value = anyToMarkupContent(any);
      } catch (LspException &e) {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          "Failed to transform LSPAny to InlayHint_tooltip"
        );
      }
      break;
    }
    case LSPAnyType::STRING_TYPE: {
      value = anyToString(any);
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) InlayHint_tooltip: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::inlayHint_tooltipToAny(
    const InlayHint_tooltip &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<InlayHint_tooltipType>(variant.index())) {
    case InlayHint_tooltipType::STRING_TYPE: {
      return stringToAny(
        std::get<string_t>(variant)
      );
    }
    case InlayHint_tooltipType::MARKUP_CONTENT: {
      return markupContentToAny(
        *std::get<std::unique_ptr<MarkupContent>>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported InlayHint_tooltipType: " +
         InlayHint_tooltipTypeNames.at(static_cast<InlayHint_tooltipType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToInlayHint(
    const LSPAny &any
  ) const -> std::unique_ptr<InlayHint> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) InlayHint must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<InlayHint> value =
      std::make_unique<InlayHint>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 8) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) InlayHint: " + std::to_string(object.size())
      );
    }

    iter = object.find("position");
    if (iter != object.end()) {
      value->position = anyToPosition(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required InlayHint attribute: position"
      );
    }

    iter = object.find("label");
    if (iter != object.end()) {
      value->label = anyToInlayHint_label(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required InlayHint attribute: label"
      );
    }

    iter = object.find("kind");
    if (iter != object.end()) {
      value->kind = anyToInlayHintKind(*iter->second);
    }

    iter = object.find("textEdits");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<std::unique_ptr<TextEdit>> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToTextEdit(*elem));
      }
      value->textEdits = std::move(values);
    }

    iter = object.find("tooltip");
    if (iter != object.end()) {
      value->tooltip = anyToInlayHint_tooltip(*iter->second);
    }

    iter = object.find("paddingLeft");
    if (iter != object.end()) {
      value->paddingLeft = anyToBoolean(*iter->second);
    }

    iter = object.find("paddingRight");
    if (iter != object.end()) {
      value->paddingRight = anyToBoolean(*iter->second);
    }

    iter = object.find("data");
    if (iter != object.end()) {
      value->data = copy(iter->second);
    }

    return value;
  }

  auto LspTransformer::inlayHintToAny(
    const InlayHint &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("position", positionToAny(*structure.position));
    object.emplace("label", inlayHint_labelToAny(structure.label));
    if (structure.kind.has_value()) {
      object.emplace("kind", inlayHintKindToAny(structure.kind.value()));
    }
    if (structure.textEdits.has_value()) {
      LSPArray array;
      for (const std::unique_ptr<TextEdit> &elem : structure.textEdits.value()) {
        array.push_back(textEditToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("textEdits", std::move(any));
    }
    if (structure.tooltip.has_value()) {
      object.emplace("tooltip", inlayHint_tooltipToAny(structure.tooltip.value()));
    }
    if (structure.paddingLeft.has_value()) {
      object.emplace("paddingLeft", booleanToAny(structure.paddingLeft.value()));
    }
    if (structure.paddingRight.has_value()) {
      object.emplace("paddingRight", booleanToAny(structure.paddingRight.value()));
    }
    if (structure.data.has_value()) {
      object.emplace("data", copy(structure.data.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToInlayHintRegistrationOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<InlayHintRegistrationOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) InlayHintRegistrationOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<InlayHintRegistrationOptions> value =
      std::make_unique<InlayHintRegistrationOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 4) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) InlayHintRegistrationOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("resolveProvider");
    if (iter != object.end()) {
      value->resolveProvider = anyToBoolean(*iter->second);
    }

    iter = object.find("documentSelector");
    if (iter != object.end()) {
      value->documentSelector = anyToTextDocumentRegistrationOptions_documentSelector(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required InlayHintRegistrationOptions attribute: documentSelector"
      );
    }

    iter = object.find("id");
    if (iter != object.end()) {
      value->id = anyToString(*iter->second);
    }

    iter = object.find("workDoneProgress");
    if (iter != object.end()) {
      value->workDoneProgress = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::inlayHintRegistrationOptionsToAny(
    const InlayHintRegistrationOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.resolveProvider.has_value()) {
      object.emplace("resolveProvider", booleanToAny(structure.resolveProvider.value()));
    }
    object.emplace("documentSelector", textDocumentRegistrationOptions_documentSelectorToAny(structure.documentSelector));
    if (structure.id.has_value()) {
      object.emplace("id", stringToAny(structure.id.value()));
    }
    if (structure.workDoneProgress.has_value()) {
      object.emplace("workDoneProgress", booleanToAny(structure.workDoneProgress.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToDocumentDiagnosticParams(
    const LSPAny &any
  ) const -> std::unique_ptr<DocumentDiagnosticParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) DocumentDiagnosticParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<DocumentDiagnosticParams> value =
      std::make_unique<DocumentDiagnosticParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 5) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) DocumentDiagnosticParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("textDocument");
    if (iter != object.end()) {
      value->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DocumentDiagnosticParams attribute: textDocument"
      );
    }

    iter = object.find("identifier");
    if (iter != object.end()) {
      value->identifier = anyToString(*iter->second);
    }

    iter = object.find("previousResultId");
    if (iter != object.end()) {
      value->previousResultId = anyToString(*iter->second);
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      value->workDoneToken = anyToProgressToken(*iter->second);
    }

    iter = object.find("partialResultToken");
    if (iter != object.end()) {
      value->partialResultToken = anyToProgressToken(*iter->second);
    }

    return value;
  }

  auto LspTransformer::documentDiagnosticParamsToAny(
    const DocumentDiagnosticParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("textDocument", textDocumentIdentifierToAny(*structure.textDocument));
    if (structure.identifier.has_value()) {
      object.emplace("identifier", stringToAny(structure.identifier.value()));
    }
    if (structure.previousResultId.has_value()) {
      object.emplace("previousResultId", stringToAny(structure.previousResultId.value()));
    }
    if (structure.workDoneToken.has_value()) {
      object.emplace("workDoneToken", progressTokenToAny(structure.workDoneToken.value()));
    }
    if (structure.partialResultToken.has_value()) {
      object.emplace("partialResultToken", progressTokenToAny(structure.partialResultToken.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToDocumentDiagnosticReportPartialResult_relatedDocuments(
    const LSPAny &any
  ) const -> DocumentDiagnosticReportPartialResult_relatedDocuments {
    DocumentDiagnosticReportPartialResult_relatedDocuments value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::OBJECT_TYPE: {
      try {
        value = anyToFullDocumentDiagnosticReport(any);
      } catch (LspException &e) {
        try {
          value = anyToUnchangedDocumentDiagnosticReport(any);
        } catch (LspException &e) {
          throw LSP_EXCEPTION(
            ErrorCodes::INVALID_PARAMS,
            "Failed to transform LSPAny to DocumentDiagnosticReportPartialResult_relatedDocuments"
          );
        }
      }
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) DocumentDiagnosticReportPartialResult_relatedDocuments: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::documentDiagnosticReportPartialResult_relatedDocumentsToAny(
    const DocumentDiagnosticReportPartialResult_relatedDocuments &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<DocumentDiagnosticReportPartialResult_relatedDocumentsType>(variant.index())) {
    case DocumentDiagnosticReportPartialResult_relatedDocumentsType::FULL_DOCUMENT_DIAGNOSTIC_REPORT: {
      return fullDocumentDiagnosticReportToAny(
        *std::get<std::unique_ptr<FullDocumentDiagnosticReport>>(variant)
      );
    }
    case DocumentDiagnosticReportPartialResult_relatedDocumentsType::UNCHANGED_DOCUMENT_DIAGNOSTIC_REPORT: {
      return unchangedDocumentDiagnosticReportToAny(
        *std::get<std::unique_ptr<UnchangedDocumentDiagnosticReport>>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported DocumentDiagnosticReportPartialResult_relatedDocumentsType: " +
         DocumentDiagnosticReportPartialResult_relatedDocumentsTypeNames.at(static_cast<DocumentDiagnosticReportPartialResult_relatedDocumentsType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToDocumentDiagnosticReportPartialResult(
    const LSPAny &any
  ) const -> std::unique_ptr<DocumentDiagnosticReportPartialResult> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) DocumentDiagnosticReportPartialResult must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<DocumentDiagnosticReportPartialResult> value =
      std::make_unique<DocumentDiagnosticReportPartialResult>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) DocumentDiagnosticReportPartialResult: " + std::to_string(object.size())
      );
    }

    iter = object.find("relatedDocuments");
    if (iter != object.end()) {
      const LSPObject &object_map = std::get<LSPObject>(*iter->second);
      std::map<DocumentUri, DocumentDiagnosticReportPartialResult_relatedDocuments> map;
      for (const auto &[map_key, map_value] : object_map) {
        map.emplace(map_key, anyToDocumentDiagnosticReportPartialResult_relatedDocuments(*map_value));
      }
      value->relatedDocuments = std::move(map);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DocumentDiagnosticReportPartialResult attribute: relatedDocuments"
      );
    }

    return value;
  }

  auto LspTransformer::documentDiagnosticReportPartialResultToAny(
    const DocumentDiagnosticReportPartialResult &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    {
      LSPObject map;
      for (const auto &[mapKey, mapValue] : structure.relatedDocuments) {
        map.emplace(mapKey, documentDiagnosticReportPartialResult_relatedDocumentsToAny(mapValue));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(map);
      object.emplace("relatedDocuments", std::move(any));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToDiagnosticServerCancellationData(
    const LSPAny &any
  ) const -> std::unique_ptr<DiagnosticServerCancellationData> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) DiagnosticServerCancellationData must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<DiagnosticServerCancellationData> value =
      std::make_unique<DiagnosticServerCancellationData>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) DiagnosticServerCancellationData: " + std::to_string(object.size())
      );
    }

    iter = object.find("retriggerRequest");
    if (iter != object.end()) {
      value->retriggerRequest = anyToBoolean(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DiagnosticServerCancellationData attribute: retriggerRequest"
      );
    }

    return value;
  }

  auto LspTransformer::diagnosticServerCancellationDataToAny(
    const DiagnosticServerCancellationData &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("retriggerRequest", booleanToAny(structure.retriggerRequest));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToDiagnosticRegistrationOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<DiagnosticRegistrationOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) DiagnosticRegistrationOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<DiagnosticRegistrationOptions> value =
      std::make_unique<DiagnosticRegistrationOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 6) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) DiagnosticRegistrationOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("documentSelector");
    if (iter != object.end()) {
      value->documentSelector = anyToTextDocumentRegistrationOptions_documentSelector(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DiagnosticRegistrationOptions attribute: documentSelector"
      );
    }

    iter = object.find("identifier");
    if (iter != object.end()) {
      value->identifier = anyToString(*iter->second);
    }

    iter = object.find("interFileDependencies");
    if (iter != object.end()) {
      value->interFileDependencies = anyToBoolean(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DiagnosticRegistrationOptions attribute: interFileDependencies"
      );
    }

    iter = object.find("workspaceDiagnostics");
    if (iter != object.end()) {
      value->workspaceDiagnostics = anyToBoolean(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DiagnosticRegistrationOptions attribute: workspaceDiagnostics"
      );
    }

    iter = object.find("id");
    if (iter != object.end()) {
      value->id = anyToString(*iter->second);
    }

    iter = object.find("workDoneProgress");
    if (iter != object.end()) {
      value->workDoneProgress = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::diagnosticRegistrationOptionsToAny(
    const DiagnosticRegistrationOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("documentSelector", textDocumentRegistrationOptions_documentSelectorToAny(structure.documentSelector));
    if (structure.identifier.has_value()) {
      object.emplace("identifier", stringToAny(structure.identifier.value()));
    }
    object.emplace("interFileDependencies", booleanToAny(structure.interFileDependencies));
    object.emplace("workspaceDiagnostics", booleanToAny(structure.workspaceDiagnostics));
    if (structure.id.has_value()) {
      object.emplace("id", stringToAny(structure.id.value()));
    }
    if (structure.workDoneProgress.has_value()) {
      object.emplace("workDoneProgress", booleanToAny(structure.workDoneProgress.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToWorkspaceDiagnosticParams(
    const LSPAny &any
  ) const -> std::unique_ptr<WorkspaceDiagnosticParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) WorkspaceDiagnosticParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<WorkspaceDiagnosticParams> value =
      std::make_unique<WorkspaceDiagnosticParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 4) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) WorkspaceDiagnosticParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("identifier");
    if (iter != object.end()) {
      value->identifier = anyToString(*iter->second);
    }

    iter = object.find("previousResultIds");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<std::unique_ptr<PreviousResultId>> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToPreviousResultId(*elem));
      }
      value->previousResultIds = std::move(values);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required WorkspaceDiagnosticParams attribute: previousResultIds"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      value->workDoneToken = anyToProgressToken(*iter->second);
    }

    iter = object.find("partialResultToken");
    if (iter != object.end()) {
      value->partialResultToken = anyToProgressToken(*iter->second);
    }

    return value;
  }

  auto LspTransformer::workspaceDiagnosticParamsToAny(
    const WorkspaceDiagnosticParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.identifier.has_value()) {
      object.emplace("identifier", stringToAny(structure.identifier.value()));
    }
    {
      LSPArray array;
      for (const std::unique_ptr<PreviousResultId> &elem : structure.previousResultIds) {
        array.push_back(previousResultIdToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("previousResultIds", std::move(any));
    }
    if (structure.workDoneToken.has_value()) {
      object.emplace("workDoneToken", progressTokenToAny(structure.workDoneToken.value()));
    }
    if (structure.partialResultToken.has_value()) {
      object.emplace("partialResultToken", progressTokenToAny(structure.partialResultToken.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToWorkspaceDiagnosticReport(
    const LSPAny &any
  ) const -> std::unique_ptr<WorkspaceDiagnosticReport> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) WorkspaceDiagnosticReport must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<WorkspaceDiagnosticReport> value =
      std::make_unique<WorkspaceDiagnosticReport>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) WorkspaceDiagnosticReport: " + std::to_string(object.size())
      );
    }

    iter = object.find("items");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<WorkspaceDocumentDiagnosticReport> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToWorkspaceDocumentDiagnosticReport(*elem));
      }
      value->items = std::move(values);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required WorkspaceDiagnosticReport attribute: items"
      );
    }

    return value;
  }

  auto LspTransformer::workspaceDiagnosticReportToAny(
    const WorkspaceDiagnosticReport &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    {
      LSPArray array;
      for (const WorkspaceDocumentDiagnosticReport &elem : structure.items) {
        array.push_back(workspaceDocumentDiagnosticReportToAny(elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("items", std::move(any));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToWorkspaceDiagnosticReportPartialResult(
    const LSPAny &any
  ) const -> std::unique_ptr<WorkspaceDiagnosticReportPartialResult> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) WorkspaceDiagnosticReportPartialResult must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<WorkspaceDiagnosticReportPartialResult> value =
      std::make_unique<WorkspaceDiagnosticReportPartialResult>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) WorkspaceDiagnosticReportPartialResult: " + std::to_string(object.size())
      );
    }

    iter = object.find("items");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<WorkspaceDocumentDiagnosticReport> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToWorkspaceDocumentDiagnosticReport(*elem));
      }
      value->items = std::move(values);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required WorkspaceDiagnosticReportPartialResult attribute: items"
      );
    }

    return value;
  }

  auto LspTransformer::workspaceDiagnosticReportPartialResultToAny(
    const WorkspaceDiagnosticReportPartialResult &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    {
      LSPArray array;
      for (const WorkspaceDocumentDiagnosticReport &elem : structure.items) {
        array.push_back(workspaceDocumentDiagnosticReportToAny(elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("items", std::move(any));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToDidOpenNotebookDocumentParams(
    const LSPAny &any
  ) const -> std::unique_ptr<DidOpenNotebookDocumentParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) DidOpenNotebookDocumentParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<DidOpenNotebookDocumentParams> value =
      std::make_unique<DidOpenNotebookDocumentParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) DidOpenNotebookDocumentParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("notebookDocument");
    if (iter != object.end()) {
      value->notebookDocument = anyToNotebookDocument(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DidOpenNotebookDocumentParams attribute: notebookDocument"
      );
    }

    iter = object.find("cellTextDocuments");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<std::unique_ptr<TextDocumentItem>> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToTextDocumentItem(*elem));
      }
      value->cellTextDocuments = std::move(values);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DidOpenNotebookDocumentParams attribute: cellTextDocuments"
      );
    }

    return value;
  }

  auto LspTransformer::didOpenNotebookDocumentParamsToAny(
    const DidOpenNotebookDocumentParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("notebookDocument", notebookDocumentToAny(*structure.notebookDocument));
    {
      LSPArray array;
      for (const std::unique_ptr<TextDocumentItem> &elem : structure.cellTextDocuments) {
        array.push_back(textDocumentItemToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("cellTextDocuments", std::move(any));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToDidChangeNotebookDocumentParams(
    const LSPAny &any
  ) const -> std::unique_ptr<DidChangeNotebookDocumentParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) DidChangeNotebookDocumentParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<DidChangeNotebookDocumentParams> value =
      std::make_unique<DidChangeNotebookDocumentParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) DidChangeNotebookDocumentParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("notebookDocument");
    if (iter != object.end()) {
      value->notebookDocument = anyToVersionedNotebookDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DidChangeNotebookDocumentParams attribute: notebookDocument"
      );
    }

    iter = object.find("change");
    if (iter != object.end()) {
      value->change = anyToNotebookDocumentChangeEvent(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DidChangeNotebookDocumentParams attribute: change"
      );
    }

    return value;
  }

  auto LspTransformer::didChangeNotebookDocumentParamsToAny(
    const DidChangeNotebookDocumentParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("notebookDocument", versionedNotebookDocumentIdentifierToAny(*structure.notebookDocument));
    object.emplace("change", notebookDocumentChangeEventToAny(*structure.change));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToDidSaveNotebookDocumentParams(
    const LSPAny &any
  ) const -> std::unique_ptr<DidSaveNotebookDocumentParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) DidSaveNotebookDocumentParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<DidSaveNotebookDocumentParams> value =
      std::make_unique<DidSaveNotebookDocumentParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) DidSaveNotebookDocumentParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("notebookDocument");
    if (iter != object.end()) {
      value->notebookDocument = anyToNotebookDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DidSaveNotebookDocumentParams attribute: notebookDocument"
      );
    }

    return value;
  }

  auto LspTransformer::didSaveNotebookDocumentParamsToAny(
    const DidSaveNotebookDocumentParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("notebookDocument", notebookDocumentIdentifierToAny(*structure.notebookDocument));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToDidCloseNotebookDocumentParams(
    const LSPAny &any
  ) const -> std::unique_ptr<DidCloseNotebookDocumentParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) DidCloseNotebookDocumentParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<DidCloseNotebookDocumentParams> value =
      std::make_unique<DidCloseNotebookDocumentParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) DidCloseNotebookDocumentParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("notebookDocument");
    if (iter != object.end()) {
      value->notebookDocument = anyToNotebookDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DidCloseNotebookDocumentParams attribute: notebookDocument"
      );
    }

    iter = object.find("cellTextDocuments");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<std::unique_ptr<TextDocumentIdentifier>> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToTextDocumentIdentifier(*elem));
      }
      value->cellTextDocuments = std::move(values);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DidCloseNotebookDocumentParams attribute: cellTextDocuments"
      );
    }

    return value;
  }

  auto LspTransformer::didCloseNotebookDocumentParamsToAny(
    const DidCloseNotebookDocumentParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("notebookDocument", notebookDocumentIdentifierToAny(*structure.notebookDocument));
    {
      LSPArray array;
      for (const std::unique_ptr<TextDocumentIdentifier> &elem : structure.cellTextDocuments) {
        array.push_back(textDocumentIdentifierToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("cellTextDocuments", std::move(any));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToInlineCompletionParams(
    const LSPAny &any
  ) const -> std::unique_ptr<InlineCompletionParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) InlineCompletionParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<InlineCompletionParams> value =
      std::make_unique<InlineCompletionParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 4) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) InlineCompletionParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("context");
    if (iter != object.end()) {
      value->context = anyToInlineCompletionContext(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required InlineCompletionParams attribute: context"
      );
    }

    iter = object.find("textDocument");
    if (iter != object.end()) {
      value->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required InlineCompletionParams attribute: textDocument"
      );
    }

    iter = object.find("position");
    if (iter != object.end()) {
      value->position = anyToPosition(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required InlineCompletionParams attribute: position"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      value->workDoneToken = anyToProgressToken(*iter->second);
    }

    return value;
  }

  auto LspTransformer::inlineCompletionParamsToAny(
    const InlineCompletionParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("context", inlineCompletionContextToAny(*structure.context));
    object.emplace("textDocument", textDocumentIdentifierToAny(*structure.textDocument));
    object.emplace("position", positionToAny(*structure.position));
    if (structure.workDoneToken.has_value()) {
      object.emplace("workDoneToken", progressTokenToAny(structure.workDoneToken.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToInlineCompletionList(
    const LSPAny &any
  ) const -> std::unique_ptr<InlineCompletionList> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) InlineCompletionList must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<InlineCompletionList> value =
      std::make_unique<InlineCompletionList>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) InlineCompletionList: " + std::to_string(object.size())
      );
    }

    iter = object.find("items");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<std::unique_ptr<InlineCompletionItem>> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToInlineCompletionItem(*elem));
      }
      value->items = std::move(values);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required InlineCompletionList attribute: items"
      );
    }

    return value;
  }

  auto LspTransformer::inlineCompletionListToAny(
    const InlineCompletionList &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    {
      LSPArray array;
      for (const std::unique_ptr<InlineCompletionItem> &elem : structure.items) {
        array.push_back(inlineCompletionItemToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("items", std::move(any));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToInlineCompletionItem_insertText(
    const LSPAny &any
  ) const -> InlineCompletionItem_insertText {
    InlineCompletionItem_insertText value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::OBJECT_TYPE: {
      try {
        value = anyToStringValue(any);
      } catch (LspException &e) {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          "Failed to transform LSPAny to InlineCompletionItem_insertText"
        );
      }
      break;
    }
    case LSPAnyType::STRING_TYPE: {
      value = anyToString(any);
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) InlineCompletionItem_insertText: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::inlineCompletionItem_insertTextToAny(
    const InlineCompletionItem_insertText &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<InlineCompletionItem_insertTextType>(variant.index())) {
    case InlineCompletionItem_insertTextType::STRING_TYPE: {
      return stringToAny(
        std::get<string_t>(variant)
      );
    }
    case InlineCompletionItem_insertTextType::STRING_VALUE: {
      return stringValueToAny(
        *std::get<std::unique_ptr<StringValue>>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported InlineCompletionItem_insertTextType: " +
         InlineCompletionItem_insertTextTypeNames.at(static_cast<InlineCompletionItem_insertTextType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToInlineCompletionItem(
    const LSPAny &any
  ) const -> std::unique_ptr<InlineCompletionItem> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) InlineCompletionItem must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<InlineCompletionItem> value =
      std::make_unique<InlineCompletionItem>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 4) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) InlineCompletionItem: " + std::to_string(object.size())
      );
    }

    iter = object.find("insertText");
    if (iter != object.end()) {
      value->insertText = anyToInlineCompletionItem_insertText(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required InlineCompletionItem attribute: insertText"
      );
    }

    iter = object.find("filterText");
    if (iter != object.end()) {
      value->filterText = anyToString(*iter->second);
    }

    iter = object.find("range");
    if (iter != object.end()) {
      value->range = anyToRange(*iter->second);
    }

    iter = object.find("command");
    if (iter != object.end()) {
      value->command = anyToCommand(*iter->second);
    }

    return value;
  }

  auto LspTransformer::inlineCompletionItemToAny(
    const InlineCompletionItem &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("insertText", inlineCompletionItem_insertTextToAny(structure.insertText));
    if (structure.filterText.has_value()) {
      object.emplace("filterText", stringToAny(structure.filterText.value()));
    }
    if (structure.range.has_value()) {
      object.emplace("range", rangeToAny(*structure.range.value()));
    }
    if (structure.command.has_value()) {
      object.emplace("command", commandToAny(*structure.command.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToInlineCompletionRegistrationOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<InlineCompletionRegistrationOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) InlineCompletionRegistrationOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<InlineCompletionRegistrationOptions> value =
      std::make_unique<InlineCompletionRegistrationOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) InlineCompletionRegistrationOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("documentSelector");
    if (iter != object.end()) {
      value->documentSelector = anyToTextDocumentRegistrationOptions_documentSelector(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required InlineCompletionRegistrationOptions attribute: documentSelector"
      );
    }

    iter = object.find("id");
    if (iter != object.end()) {
      value->id = anyToString(*iter->second);
    }

    iter = object.find("workDoneProgress");
    if (iter != object.end()) {
      value->workDoneProgress = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::inlineCompletionRegistrationOptionsToAny(
    const InlineCompletionRegistrationOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("documentSelector", textDocumentRegistrationOptions_documentSelectorToAny(structure.documentSelector));
    if (structure.id.has_value()) {
      object.emplace("id", stringToAny(structure.id.value()));
    }
    if (structure.workDoneProgress.has_value()) {
      object.emplace("workDoneProgress", booleanToAny(structure.workDoneProgress.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToRegistrationParams(
    const LSPAny &any
  ) const -> std::unique_ptr<RegistrationParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) RegistrationParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<RegistrationParams> value =
      std::make_unique<RegistrationParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) RegistrationParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("registrations");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<std::unique_ptr<Registration>> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToRegistration(*elem));
      }
      value->registrations = std::move(values);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required RegistrationParams attribute: registrations"
      );
    }

    return value;
  }

  auto LspTransformer::registrationParamsToAny(
    const RegistrationParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    {
      LSPArray array;
      for (const std::unique_ptr<Registration> &elem : structure.registrations) {
        array.push_back(registrationToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("registrations", std::move(any));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToUnregistrationParams(
    const LSPAny &any
  ) const -> std::unique_ptr<UnregistrationParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) UnregistrationParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<UnregistrationParams> value =
      std::make_unique<UnregistrationParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) UnregistrationParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("unregisterations");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<std::unique_ptr<Unregistration>> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToUnregistration(*elem));
      }
      value->unregisterations = std::move(values);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required UnregistrationParams attribute: unregisterations"
      );
    }

    return value;
  }

  auto LspTransformer::unregistrationParamsToAny(
    const UnregistrationParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    {
      LSPArray array;
      for (const std::unique_ptr<Unregistration> &elem : structure.unregisterations) {
        array.push_back(unregistrationToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("unregisterations", std::move(any));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToInitializeParams(
    const LSPAny &any
  ) const -> std::unique_ptr<InitializeParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) InitializeParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<InitializeParams> value =
      std::make_unique<InitializeParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 10) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) InitializeParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("processId");
    if (iter != object.end()) {
      value->processId = anyTo_InitializeParams_processId(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required InitializeParams attribute: processId"
      );
    }

    iter = object.find("clientInfo");
    if (iter != object.end()) {
      value->clientInfo = anyTo_InitializeParams_clientInfo(*iter->second);
    }

    iter = object.find("locale");
    if (iter != object.end()) {
      value->locale = anyToString(*iter->second);
    }

    iter = object.find("rootPath");
    if (iter != object.end()) {
      value->rootPath = anyTo_InitializeParams_rootPath(*iter->second);
    }

    iter = object.find("rootUri");
    if (iter != object.end()) {
      value->rootUri = anyTo_InitializeParams_rootUri(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required InitializeParams attribute: rootUri"
      );
    }

    iter = object.find("capabilities");
    if (iter != object.end()) {
      value->capabilities = anyToClientCapabilities(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required InitializeParams attribute: capabilities"
      );
    }

    iter = object.find("initializationOptions");
    if (iter != object.end()) {
      value->initializationOptions = copy(iter->second);
    }

    iter = object.find("trace");
    if (iter != object.end()) {
      value->trace = anyToTraceValues(*iter->second);
    }

    iter = object.find("workspaceFolders");
    if (iter != object.end()) {
      value->workspaceFolders = anyToWorkspaceFoldersInitializeParams_workspaceFolders(*iter->second);
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      value->workDoneToken = anyToProgressToken(*iter->second);
    }

    return value;
  }

  auto LspTransformer::initializeParamsToAny(
    const InitializeParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("processId", _InitializeParams_processIdToAny(structure.processId));
    if (structure.clientInfo.has_value()) {
      object.emplace("clientInfo", _InitializeParams_clientInfoToAny(*structure.clientInfo.value()));
    }
    if (structure.locale.has_value()) {
      object.emplace("locale", stringToAny(structure.locale.value()));
    }
    if (structure.rootPath.has_value()) {
      object.emplace("rootPath", _InitializeParams_rootPathToAny(structure.rootPath.value()));
    }
    object.emplace("rootUri", _InitializeParams_rootUriToAny(structure.rootUri));
    object.emplace("capabilities", clientCapabilitiesToAny(*structure.capabilities));
    if (structure.initializationOptions.has_value()) {
      object.emplace("initializationOptions", copy(structure.initializationOptions.value()));
    }
    if (structure.trace.has_value()) {
      object.emplace("trace", traceValuesToAny(structure.trace.value()));
    }
    if (structure.workspaceFolders.has_value()) {
      object.emplace("workspaceFolders", workspaceFoldersInitializeParams_workspaceFoldersToAny(structure.workspaceFolders.value()));
    }
    if (structure.workDoneToken.has_value()) {
      object.emplace("workDoneToken", progressTokenToAny(structure.workDoneToken.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToInitializeResult_serverInfo(
    const LSPAny &any
  ) const -> std::unique_ptr<InitializeResult_serverInfo> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) InitializeResult_serverInfo must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<InitializeResult_serverInfo> value =
      std::make_unique<InitializeResult_serverInfo>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) InitializeResult_serverInfo: " + std::to_string(object.size())
      );
    }

    iter = object.find("name");
    if (iter != object.end()) {
      value->name = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required InitializeResult_serverInfo attribute: name"
      );
    }

    iter = object.find("version");
    if (iter != object.end()) {
      value->version = anyToString(*iter->second);
    }

    return value;
  }

  auto LspTransformer::initializeResult_serverInfoToAny(
    const InitializeResult_serverInfo &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("name", stringToAny(structure.name));
    if (structure.version.has_value()) {
      object.emplace("version", stringToAny(structure.version.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToInitializeResult(
    const LSPAny &any
  ) const -> std::unique_ptr<InitializeResult> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) InitializeResult must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<InitializeResult> value =
      std::make_unique<InitializeResult>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) InitializeResult: " + std::to_string(object.size())
      );
    }

    iter = object.find("capabilities");
    if (iter != object.end()) {
      value->capabilities = anyToServerCapabilities(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required InitializeResult attribute: capabilities"
      );
    }

    iter = object.find("serverInfo");
    if (iter != object.end()) {
      value->serverInfo = anyToInitializeResult_serverInfo(*iter->second);
    }

    return value;
  }

  auto LspTransformer::initializeResultToAny(
    const InitializeResult &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("capabilities", serverCapabilitiesToAny(*structure.capabilities));
    if (structure.serverInfo.has_value()) {
      object.emplace("serverInfo", initializeResult_serverInfoToAny(*structure.serverInfo.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToInitializeError(
    const LSPAny &any
  ) const -> std::unique_ptr<InitializeError> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) InitializeError must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<InitializeError> value =
      std::make_unique<InitializeError>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) InitializeError: " + std::to_string(object.size())
      );
    }

    iter = object.find("retry");
    if (iter != object.end()) {
      value->retry = anyToBoolean(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required InitializeError attribute: retry"
      );
    }

    return value;
  }

  auto LspTransformer::initializeErrorToAny(
    const InitializeError &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("retry", booleanToAny(structure.retry));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToInitializedParams(
    const LSPAny &any
  ) const -> std::unique_ptr<InitializedParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) InitializedParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<InitializedParams> value =
      std::make_unique<InitializedParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 0) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) InitializedParams: " + std::to_string(object.size())
      );
    }

    return value;
  }

  auto LspTransformer::initializedParamsToAny(
    const InitializedParams &/*structure*/
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    // empty

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToDidChangeConfigurationParams(
    const LSPAny &any
  ) const -> std::unique_ptr<DidChangeConfigurationParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) DidChangeConfigurationParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<DidChangeConfigurationParams> value =
      std::make_unique<DidChangeConfigurationParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) DidChangeConfigurationParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("settings");
    if (iter != object.end()) {
      value->settings = copy(iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DidChangeConfigurationParams attribute: settings"
      );
    }

    return value;
  }

  auto LspTransformer::didChangeConfigurationParamsToAny(
    const DidChangeConfigurationParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("settings", copy(structure.settings));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToDidChangeConfigurationRegistrationOptions_section(
    const LSPAny &any
  ) const -> DidChangeConfigurationRegistrationOptions_section {
    DidChangeConfigurationRegistrationOptions_section value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::ARRAY_TYPE: {
      try {
        std::vector<string_t> values;
        for (const std::unique_ptr<LSPAny> &elem
            : std::get<LSPArray>(any)) {
          values.push_back(anyToString(*elem));
        }
        value = std::move(values);
      } catch (LspException &e) {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          "Failed to transform LSPAny to array"
        );
      }
      break;
    }
    case LSPAnyType::STRING_TYPE: {
      value = anyToString(any);
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) DidChangeConfigurationRegistrationOptions_section: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::didChangeConfigurationRegistrationOptions_sectionToAny(
    const DidChangeConfigurationRegistrationOptions_section &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<DidChangeConfigurationRegistrationOptions_sectionType>(variant.index())) {
    case DidChangeConfigurationRegistrationOptions_sectionType::STRING_TYPE: {
      return stringToAny(
        std::get<string_t>(variant)
      );
    }
    case DidChangeConfigurationRegistrationOptions_sectionType::STRING_TYPE_ARRAY: {
      LSPArray array;
      for (const string_t &elem
          : std::get<std::vector<string_t>>(variant)) {
        array.push_back(stringToAny(elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      return any;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported DidChangeConfigurationRegistrationOptions_sectionType: " +
         DidChangeConfigurationRegistrationOptions_sectionTypeNames.at(static_cast<DidChangeConfigurationRegistrationOptions_sectionType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToDidChangeConfigurationRegistrationOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<DidChangeConfigurationRegistrationOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) DidChangeConfigurationRegistrationOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<DidChangeConfigurationRegistrationOptions> value =
      std::make_unique<DidChangeConfigurationRegistrationOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) DidChangeConfigurationRegistrationOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("section");
    if (iter != object.end()) {
      value->section = anyToDidChangeConfigurationRegistrationOptions_section(*iter->second);
    }

    return value;
  }

  auto LspTransformer::didChangeConfigurationRegistrationOptionsToAny(
    const DidChangeConfigurationRegistrationOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.section.has_value()) {
      object.emplace("section", didChangeConfigurationRegistrationOptions_sectionToAny(structure.section.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToShowMessageParams(
    const LSPAny &any
  ) const -> std::unique_ptr<ShowMessageParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) ShowMessageParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<ShowMessageParams> value =
      std::make_unique<ShowMessageParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) ShowMessageParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("type");
    if (iter != object.end()) {
      value->type = anyToMessageType(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required ShowMessageParams attribute: type"
      );
    }

    iter = object.find("message");
    if (iter != object.end()) {
      value->message = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required ShowMessageParams attribute: message"
      );
    }

    return value;
  }

  auto LspTransformer::showMessageParamsToAny(
    const ShowMessageParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("type", messageTypeToAny(structure.type));
    object.emplace("message", stringToAny(structure.message));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToShowMessageRequestParams(
    const LSPAny &any
  ) const -> std::unique_ptr<ShowMessageRequestParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) ShowMessageRequestParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<ShowMessageRequestParams> value =
      std::make_unique<ShowMessageRequestParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) ShowMessageRequestParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("type");
    if (iter != object.end()) {
      value->type = anyToMessageType(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required ShowMessageRequestParams attribute: type"
      );
    }

    iter = object.find("message");
    if (iter != object.end()) {
      value->message = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required ShowMessageRequestParams attribute: message"
      );
    }

    iter = object.find("actions");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<std::unique_ptr<MessageActionItem>> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToMessageActionItem(*elem));
      }
      value->actions = std::move(values);
    }

    return value;
  }

  auto LspTransformer::showMessageRequestParamsToAny(
    const ShowMessageRequestParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("type", messageTypeToAny(structure.type));
    object.emplace("message", stringToAny(structure.message));
    if (structure.actions.has_value()) {
      LSPArray array;
      for (const std::unique_ptr<MessageActionItem> &elem : structure.actions.value()) {
        array.push_back(messageActionItemToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("actions", std::move(any));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToMessageActionItem(
    const LSPAny &any
  ) const -> std::unique_ptr<MessageActionItem> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) MessageActionItem must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<MessageActionItem> value =
      std::make_unique<MessageActionItem>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) MessageActionItem: " + std::to_string(object.size())
      );
    }

    iter = object.find("title");
    if (iter != object.end()) {
      value->title = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required MessageActionItem attribute: title"
      );
    }

    return value;
  }

  auto LspTransformer::messageActionItemToAny(
    const MessageActionItem &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("title", stringToAny(structure.title));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToLogMessageParams(
    const LSPAny &any
  ) const -> std::unique_ptr<LogMessageParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) LogMessageParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<LogMessageParams> value =
      std::make_unique<LogMessageParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) LogMessageParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("type");
    if (iter != object.end()) {
      value->type = anyToMessageType(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required LogMessageParams attribute: type"
      );
    }

    iter = object.find("message");
    if (iter != object.end()) {
      value->message = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required LogMessageParams attribute: message"
      );
    }

    return value;
  }

  auto LspTransformer::logMessageParamsToAny(
    const LogMessageParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("type", messageTypeToAny(structure.type));
    object.emplace("message", stringToAny(structure.message));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToDidOpenTextDocumentParams(
    const LSPAny &any
  ) const -> std::unique_ptr<DidOpenTextDocumentParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) DidOpenTextDocumentParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<DidOpenTextDocumentParams> value =
      std::make_unique<DidOpenTextDocumentParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) DidOpenTextDocumentParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("textDocument");
    if (iter != object.end()) {
      value->textDocument = anyToTextDocumentItem(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DidOpenTextDocumentParams attribute: textDocument"
      );
    }

    return value;
  }

  auto LspTransformer::didOpenTextDocumentParamsToAny(
    const DidOpenTextDocumentParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("textDocument", textDocumentItemToAny(*structure.textDocument));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToDidChangeTextDocumentParams(
    const LSPAny &any
  ) const -> std::unique_ptr<DidChangeTextDocumentParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) DidChangeTextDocumentParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<DidChangeTextDocumentParams> value =
      std::make_unique<DidChangeTextDocumentParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) DidChangeTextDocumentParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("textDocument");
    if (iter != object.end()) {
      value->textDocument = anyToVersionedTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DidChangeTextDocumentParams attribute: textDocument"
      );
    }

    iter = object.find("contentChanges");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<TextDocumentContentChangeEvent> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToTextDocumentContentChangeEvent(*elem));
      }
      value->contentChanges = std::move(values);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DidChangeTextDocumentParams attribute: contentChanges"
      );
    }

    return value;
  }

  auto LspTransformer::didChangeTextDocumentParamsToAny(
    const DidChangeTextDocumentParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("textDocument", versionedTextDocumentIdentifierToAny(*structure.textDocument));
    {
      LSPArray array;
      for (const TextDocumentContentChangeEvent &elem : structure.contentChanges) {
        array.push_back(textDocumentContentChangeEventToAny(elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("contentChanges", std::move(any));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToTextDocumentChangeRegistrationOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<TextDocumentChangeRegistrationOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) TextDocumentChangeRegistrationOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<TextDocumentChangeRegistrationOptions> value =
      std::make_unique<TextDocumentChangeRegistrationOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) TextDocumentChangeRegistrationOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("syncKind");
    if (iter != object.end()) {
      value->syncKind = anyToTextDocumentSyncKind(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required TextDocumentChangeRegistrationOptions attribute: syncKind"
      );
    }

    iter = object.find("documentSelector");
    if (iter != object.end()) {
      value->documentSelector = anyToTextDocumentRegistrationOptions_documentSelector(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required TextDocumentChangeRegistrationOptions attribute: documentSelector"
      );
    }

    return value;
  }

  auto LspTransformer::textDocumentChangeRegistrationOptionsToAny(
    const TextDocumentChangeRegistrationOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("syncKind", textDocumentSyncKindToAny(structure.syncKind));
    object.emplace("documentSelector", textDocumentRegistrationOptions_documentSelectorToAny(structure.documentSelector));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToDidCloseTextDocumentParams(
    const LSPAny &any
  ) const -> std::unique_ptr<DidCloseTextDocumentParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) DidCloseTextDocumentParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<DidCloseTextDocumentParams> value =
      std::make_unique<DidCloseTextDocumentParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) DidCloseTextDocumentParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("textDocument");
    if (iter != object.end()) {
      value->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DidCloseTextDocumentParams attribute: textDocument"
      );
    }

    return value;
  }

  auto LspTransformer::didCloseTextDocumentParamsToAny(
    const DidCloseTextDocumentParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("textDocument", textDocumentIdentifierToAny(*structure.textDocument));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToDidSaveTextDocumentParams(
    const LSPAny &any
  ) const -> std::unique_ptr<DidSaveTextDocumentParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) DidSaveTextDocumentParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<DidSaveTextDocumentParams> value =
      std::make_unique<DidSaveTextDocumentParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) DidSaveTextDocumentParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("textDocument");
    if (iter != object.end()) {
      value->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DidSaveTextDocumentParams attribute: textDocument"
      );
    }

    iter = object.find("text");
    if (iter != object.end()) {
      value->text = anyToString(*iter->second);
    }

    return value;
  }

  auto LspTransformer::didSaveTextDocumentParamsToAny(
    const DidSaveTextDocumentParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("textDocument", textDocumentIdentifierToAny(*structure.textDocument));
    if (structure.text.has_value()) {
      object.emplace("text", stringToAny(structure.text.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToTextDocumentSaveRegistrationOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<TextDocumentSaveRegistrationOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) TextDocumentSaveRegistrationOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<TextDocumentSaveRegistrationOptions> value =
      std::make_unique<TextDocumentSaveRegistrationOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) TextDocumentSaveRegistrationOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("documentSelector");
    if (iter != object.end()) {
      value->documentSelector = anyToTextDocumentRegistrationOptions_documentSelector(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required TextDocumentSaveRegistrationOptions attribute: documentSelector"
      );
    }

    iter = object.find("includeText");
    if (iter != object.end()) {
      value->includeText = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::textDocumentSaveRegistrationOptionsToAny(
    const TextDocumentSaveRegistrationOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("documentSelector", textDocumentRegistrationOptions_documentSelectorToAny(structure.documentSelector));
    if (structure.includeText.has_value()) {
      object.emplace("includeText", booleanToAny(structure.includeText.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToWillSaveTextDocumentParams(
    const LSPAny &any
  ) const -> std::unique_ptr<WillSaveTextDocumentParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) WillSaveTextDocumentParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<WillSaveTextDocumentParams> value =
      std::make_unique<WillSaveTextDocumentParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) WillSaveTextDocumentParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("textDocument");
    if (iter != object.end()) {
      value->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required WillSaveTextDocumentParams attribute: textDocument"
      );
    }

    iter = object.find("reason");
    if (iter != object.end()) {
      value->reason = anyToTextDocumentSaveReason(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required WillSaveTextDocumentParams attribute: reason"
      );
    }

    return value;
  }

  auto LspTransformer::willSaveTextDocumentParamsToAny(
    const WillSaveTextDocumentParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("textDocument", textDocumentIdentifierToAny(*structure.textDocument));
    object.emplace("reason", textDocumentSaveReasonToAny(structure.reason));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToTextEdit(
    const LSPAny &any
  ) const -> std::unique_ptr<TextEdit> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) TextEdit must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<TextEdit> value =
      std::make_unique<TextEdit>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) TextEdit: " + std::to_string(object.size())
      );
    }

    iter = object.find("range");
    if (iter != object.end()) {
      value->range = anyToRange(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required TextEdit attribute: range"
      );
    }

    iter = object.find("newText");
    if (iter != object.end()) {
      value->newText = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required TextEdit attribute: newText"
      );
    }

    return value;
  }

  auto LspTransformer::textEditToAny(
    const TextEdit &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("range", rangeToAny(*structure.range));
    object.emplace("newText", stringToAny(structure.newText));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToDidChangeWatchedFilesParams(
    const LSPAny &any
  ) const -> std::unique_ptr<DidChangeWatchedFilesParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) DidChangeWatchedFilesParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<DidChangeWatchedFilesParams> value =
      std::make_unique<DidChangeWatchedFilesParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) DidChangeWatchedFilesParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("changes");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<std::unique_ptr<FileEvent>> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToFileEvent(*elem));
      }
      value->changes = std::move(values);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DidChangeWatchedFilesParams attribute: changes"
      );
    }

    return value;
  }

  auto LspTransformer::didChangeWatchedFilesParamsToAny(
    const DidChangeWatchedFilesParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    {
      LSPArray array;
      for (const std::unique_ptr<FileEvent> &elem : structure.changes) {
        array.push_back(fileEventToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("changes", std::move(any));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToDidChangeWatchedFilesRegistrationOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<DidChangeWatchedFilesRegistrationOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) DidChangeWatchedFilesRegistrationOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<DidChangeWatchedFilesRegistrationOptions> value =
      std::make_unique<DidChangeWatchedFilesRegistrationOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) DidChangeWatchedFilesRegistrationOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("watchers");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<std::unique_ptr<FileSystemWatcher>> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToFileSystemWatcher(*elem));
      }
      value->watchers = std::move(values);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DidChangeWatchedFilesRegistrationOptions attribute: watchers"
      );
    }

    return value;
  }

  auto LspTransformer::didChangeWatchedFilesRegistrationOptionsToAny(
    const DidChangeWatchedFilesRegistrationOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    {
      LSPArray array;
      for (const std::unique_ptr<FileSystemWatcher> &elem : structure.watchers) {
        array.push_back(fileSystemWatcherToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("watchers", std::move(any));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToPublishDiagnosticsParams(
    const LSPAny &any
  ) const -> std::unique_ptr<PublishDiagnosticsParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) PublishDiagnosticsParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<PublishDiagnosticsParams> value =
      std::make_unique<PublishDiagnosticsParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) PublishDiagnosticsParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("uri");
    if (iter != object.end()) {
      value->uri = anyToDocumentUri(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required PublishDiagnosticsParams attribute: uri"
      );
    }

    iter = object.find("version");
    if (iter != object.end()) {
      value->version = anyToInteger(*iter->second);
    }

    iter = object.find("diagnostics");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<std::unique_ptr<Diagnostic>> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToDiagnostic(*elem));
      }
      value->diagnostics = std::move(values);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required PublishDiagnosticsParams attribute: diagnostics"
      );
    }

    return value;
  }

  auto LspTransformer::publishDiagnosticsParamsToAny(
    const PublishDiagnosticsParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("uri", documentUriToAny(structure.uri));
    if (structure.version.has_value()) {
      object.emplace("version", integerToAny(structure.version.value()));
    }
    {
      LSPArray array;
      for (const std::unique_ptr<Diagnostic> &elem : structure.diagnostics) {
        array.push_back(diagnosticToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("diagnostics", std::move(any));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToCompletionParams(
    const LSPAny &any
  ) const -> std::unique_ptr<CompletionParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) CompletionParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<CompletionParams> value =
      std::make_unique<CompletionParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 5) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) CompletionParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("context");
    if (iter != object.end()) {
      value->context = anyToCompletionContext(*iter->second);
    }

    iter = object.find("textDocument");
    if (iter != object.end()) {
      value->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required CompletionParams attribute: textDocument"
      );
    }

    iter = object.find("position");
    if (iter != object.end()) {
      value->position = anyToPosition(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required CompletionParams attribute: position"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      value->workDoneToken = anyToProgressToken(*iter->second);
    }

    iter = object.find("partialResultToken");
    if (iter != object.end()) {
      value->partialResultToken = anyToProgressToken(*iter->second);
    }

    return value;
  }

  auto LspTransformer::completionParamsToAny(
    const CompletionParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.context.has_value()) {
      object.emplace("context", completionContextToAny(*structure.context.value()));
    }
    object.emplace("textDocument", textDocumentIdentifierToAny(*structure.textDocument));
    object.emplace("position", positionToAny(*structure.position));
    if (structure.workDoneToken.has_value()) {
      object.emplace("workDoneToken", progressTokenToAny(structure.workDoneToken.value()));
    }
    if (structure.partialResultToken.has_value()) {
      object.emplace("partialResultToken", progressTokenToAny(structure.partialResultToken.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToCompletionItem_documentation(
    const LSPAny &any
  ) const -> CompletionItem_documentation {
    CompletionItem_documentation value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::OBJECT_TYPE: {
      try {
        value = anyToMarkupContent(any);
      } catch (LspException &e) {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          "Failed to transform LSPAny to CompletionItem_documentation"
        );
      }
      break;
    }
    case LSPAnyType::STRING_TYPE: {
      value = anyToString(any);
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) CompletionItem_documentation: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::completionItem_documentationToAny(
    const CompletionItem_documentation &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<CompletionItem_documentationType>(variant.index())) {
    case CompletionItem_documentationType::STRING_TYPE: {
      return stringToAny(
        std::get<string_t>(variant)
      );
    }
    case CompletionItem_documentationType::MARKUP_CONTENT: {
      return markupContentToAny(
        *std::get<std::unique_ptr<MarkupContent>>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported CompletionItem_documentationType: " +
         CompletionItem_documentationTypeNames.at(static_cast<CompletionItem_documentationType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToCompletionItem_textEdit(
    const LSPAny &any
  ) const -> CompletionItem_textEdit {
    CompletionItem_textEdit value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::OBJECT_TYPE: {
      try {
        value = anyToTextEdit(any);
      } catch (LspException &e) {
        try {
          value = anyToInsertReplaceEdit(any);
        } catch (LspException &e) {
          throw LSP_EXCEPTION(
            ErrorCodes::INVALID_PARAMS,
            "Failed to transform LSPAny to CompletionItem_textEdit"
          );
        }
      }
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) CompletionItem_textEdit: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::completionItem_textEditToAny(
    const CompletionItem_textEdit &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<CompletionItem_textEditType>(variant.index())) {
    case CompletionItem_textEditType::TEXT_EDIT: {
      return textEditToAny(
        *std::get<std::unique_ptr<TextEdit>>(variant)
      );
    }
    case CompletionItem_textEditType::INSERT_REPLACE_EDIT: {
      return insertReplaceEditToAny(
        *std::get<std::unique_ptr<InsertReplaceEdit>>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported CompletionItem_textEditType: " +
         CompletionItem_textEditTypeNames.at(static_cast<CompletionItem_textEditType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToCompletionItem(
    const LSPAny &any
  ) const -> std::unique_ptr<CompletionItem> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) CompletionItem must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<CompletionItem> value =
      std::make_unique<CompletionItem>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 19) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) CompletionItem: " + std::to_string(object.size())
      );
    }

    iter = object.find("label");
    if (iter != object.end()) {
      value->label = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required CompletionItem attribute: label"
      );
    }

    iter = object.find("labelDetails");
    if (iter != object.end()) {
      value->labelDetails = anyToCompletionItemLabelDetails(*iter->second);
    }

    iter = object.find("kind");
    if (iter != object.end()) {
      value->kind = anyToCompletionItemKind(*iter->second);
    }

    iter = object.find("tags");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<CompletionItemTag> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToCompletionItemTag(*elem));
      }
      value->tags = std::move(values);
    }

    iter = object.find("detail");
    if (iter != object.end()) {
      value->detail = anyToString(*iter->second);
    }

    iter = object.find("documentation");
    if (iter != object.end()) {
      value->documentation = anyToCompletionItem_documentation(*iter->second);
    }

    iter = object.find("deprecated");
    if (iter != object.end()) {
      value->deprecated = anyToBoolean(*iter->second);
    }

    iter = object.find("preselect");
    if (iter != object.end()) {
      value->preselect = anyToBoolean(*iter->second);
    }

    iter = object.find("sortText");
    if (iter != object.end()) {
      value->sortText = anyToString(*iter->second);
    }

    iter = object.find("filterText");
    if (iter != object.end()) {
      value->filterText = anyToString(*iter->second);
    }

    iter = object.find("insertText");
    if (iter != object.end()) {
      value->insertText = anyToString(*iter->second);
    }

    iter = object.find("insertTextFormat");
    if (iter != object.end()) {
      value->insertTextFormat = anyToInsertTextFormat(*iter->second);
    }

    iter = object.find("insertTextMode");
    if (iter != object.end()) {
      value->insertTextMode = anyToInsertTextMode(*iter->second);
    }

    iter = object.find("textEdit");
    if (iter != object.end()) {
      value->textEdit = anyToCompletionItem_textEdit(*iter->second);
    }

    iter = object.find("textEditText");
    if (iter != object.end()) {
      value->textEditText = anyToString(*iter->second);
    }

    iter = object.find("additionalTextEdits");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<std::unique_ptr<TextEdit>> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToTextEdit(*elem));
      }
      value->additionalTextEdits = std::move(values);
    }

    iter = object.find("commitCharacters");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<string_t> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToString(*elem));
      }
      value->commitCharacters = std::move(values);
    }

    iter = object.find("command");
    if (iter != object.end()) {
      value->command = anyToCommand(*iter->second);
    }

    iter = object.find("data");
    if (iter != object.end()) {
      value->data = copy(iter->second);
    }

    return value;
  }

  auto LspTransformer::completionItemToAny(
    const CompletionItem &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("label", stringToAny(structure.label));
    if (structure.labelDetails.has_value()) {
      object.emplace("labelDetails", completionItemLabelDetailsToAny(*structure.labelDetails.value()));
    }
    if (structure.kind.has_value()) {
      object.emplace("kind", completionItemKindToAny(structure.kind.value()));
    }
    if (structure.tags.has_value()) {
      LSPArray array;
      for (const CompletionItemTag &elem : structure.tags.value()) {
        array.push_back(completionItemTagToAny(elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("tags", std::move(any));
    }
    if (structure.detail.has_value()) {
      object.emplace("detail", stringToAny(structure.detail.value()));
    }
    if (structure.documentation.has_value()) {
      object.emplace("documentation", completionItem_documentationToAny(structure.documentation.value()));
    }
    if (structure.deprecated.has_value()) {
      object.emplace("deprecated", booleanToAny(structure.deprecated.value()));
    }
    if (structure.preselect.has_value()) {
      object.emplace("preselect", booleanToAny(structure.preselect.value()));
    }
    if (structure.sortText.has_value()) {
      object.emplace("sortText", stringToAny(structure.sortText.value()));
    }
    if (structure.filterText.has_value()) {
      object.emplace("filterText", stringToAny(structure.filterText.value()));
    }
    if (structure.insertText.has_value()) {
      object.emplace("insertText", stringToAny(structure.insertText.value()));
    }
    if (structure.insertTextFormat.has_value()) {
      object.emplace("insertTextFormat", insertTextFormatToAny(structure.insertTextFormat.value()));
    }
    if (structure.insertTextMode.has_value()) {
      object.emplace("insertTextMode", insertTextModeToAny(structure.insertTextMode.value()));
    }
    if (structure.textEdit.has_value()) {
      object.emplace("textEdit", completionItem_textEditToAny(structure.textEdit.value()));
    }
    if (structure.textEditText.has_value()) {
      object.emplace("textEditText", stringToAny(structure.textEditText.value()));
    }
    if (structure.additionalTextEdits.has_value()) {
      LSPArray array;
      for (const std::unique_ptr<TextEdit> &elem : structure.additionalTextEdits.value()) {
        array.push_back(textEditToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("additionalTextEdits", std::move(any));
    }
    if (structure.commitCharacters.has_value()) {
      LSPArray array;
      for (const string_t &elem : structure.commitCharacters.value()) {
        array.push_back(stringToAny(elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("commitCharacters", std::move(any));
    }
    if (structure.command.has_value()) {
      object.emplace("command", commandToAny(*structure.command.value()));
    }
    if (structure.data.has_value()) {
      object.emplace("data", copy(structure.data.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToCompletionList_itemDefaults_editRange_1(
    const LSPAny &any
  ) const -> std::unique_ptr<CompletionList_itemDefaults_editRange_1> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) CompletionList_itemDefaults_editRange_1 must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<CompletionList_itemDefaults_editRange_1> value =
      std::make_unique<CompletionList_itemDefaults_editRange_1>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) CompletionList_itemDefaults_editRange_1: " + std::to_string(object.size())
      );
    }

    iter = object.find("insert");
    if (iter != object.end()) {
      value->insert = anyToRange(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required CompletionList_itemDefaults_editRange_1 attribute: insert"
      );
    }

    iter = object.find("replace");
    if (iter != object.end()) {
      value->replace = anyToRange(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required CompletionList_itemDefaults_editRange_1 attribute: replace"
      );
    }

    return value;
  }

  auto LspTransformer::completionList_itemDefaults_editRange_1ToAny(
    const CompletionList_itemDefaults_editRange_1 &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("insert", rangeToAny(*structure.insert));
    object.emplace("replace", rangeToAny(*structure.replace));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToCompletionList_itemDefaults_editRange(
    const LSPAny &any
  ) const -> CompletionList_itemDefaults_editRange {
    CompletionList_itemDefaults_editRange value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::OBJECT_TYPE: {
      try {
        value = anyToRange(any);
      } catch (LspException &e) {
        try {
          value = anyToCompletionList_itemDefaults_editRange_1(any);
        } catch (LspException &e) {
          throw LSP_EXCEPTION(
            ErrorCodes::INVALID_PARAMS,
            "Failed to transform LSPAny to CompletionList_itemDefaults_editRange"
          );
        }
      }
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) CompletionList_itemDefaults_editRange: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::completionList_itemDefaults_editRangeToAny(
    const CompletionList_itemDefaults_editRange &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<CompletionList_itemDefaults_editRangeType>(variant.index())) {
    case CompletionList_itemDefaults_editRangeType::RANGE: {
      return rangeToAny(
        *std::get<std::unique_ptr<Range>>(variant)
      );
    }
    case CompletionList_itemDefaults_editRangeType::COMPLETION_LIST_ITEM_DEFAULTS_EDIT_RANGE_1: {
      return completionList_itemDefaults_editRange_1ToAny(
        *std::get<std::unique_ptr<CompletionList_itemDefaults_editRange_1>>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported CompletionList_itemDefaults_editRangeType: " +
         CompletionList_itemDefaults_editRangeTypeNames.at(static_cast<CompletionList_itemDefaults_editRangeType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToCompletionList_itemDefaults(
    const LSPAny &any
  ) const -> std::unique_ptr<CompletionList_itemDefaults> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) CompletionList_itemDefaults must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<CompletionList_itemDefaults> value =
      std::make_unique<CompletionList_itemDefaults>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 5) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) CompletionList_itemDefaults: " + std::to_string(object.size())
      );
    }

    iter = object.find("commitCharacters");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<string_t> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToString(*elem));
      }
      value->commitCharacters = std::move(values);
    }

    iter = object.find("editRange");
    if (iter != object.end()) {
      value->editRange = anyToCompletionList_itemDefaults_editRange(*iter->second);
    }

    iter = object.find("insertTextFormat");
    if (iter != object.end()) {
      value->insertTextFormat = anyToInsertTextFormat(*iter->second);
    }

    iter = object.find("insertTextMode");
    if (iter != object.end()) {
      value->insertTextMode = anyToInsertTextMode(*iter->second);
    }

    iter = object.find("data");
    if (iter != object.end()) {
      value->data = copy(iter->second);
    }

    return value;
  }

  auto LspTransformer::completionList_itemDefaultsToAny(
    const CompletionList_itemDefaults &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.commitCharacters.has_value()) {
      LSPArray array;
      for (const string_t &elem : structure.commitCharacters.value()) {
        array.push_back(stringToAny(elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("commitCharacters", std::move(any));
    }
    if (structure.editRange.has_value()) {
      object.emplace("editRange", completionList_itemDefaults_editRangeToAny(structure.editRange.value()));
    }
    if (structure.insertTextFormat.has_value()) {
      object.emplace("insertTextFormat", insertTextFormatToAny(structure.insertTextFormat.value()));
    }
    if (structure.insertTextMode.has_value()) {
      object.emplace("insertTextMode", insertTextModeToAny(structure.insertTextMode.value()));
    }
    if (structure.data.has_value()) {
      object.emplace("data", copy(structure.data.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToCompletionList(
    const LSPAny &any
  ) const -> std::unique_ptr<CompletionList> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) CompletionList must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<CompletionList> value =
      std::make_unique<CompletionList>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) CompletionList: " + std::to_string(object.size())
      );
    }

    iter = object.find("isIncomplete");
    if (iter != object.end()) {
      value->isIncomplete = anyToBoolean(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required CompletionList attribute: isIncomplete"
      );
    }

    iter = object.find("itemDefaults");
    if (iter != object.end()) {
      value->itemDefaults = anyToCompletionList_itemDefaults(*iter->second);
    }

    iter = object.find("items");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<std::unique_ptr<CompletionItem>> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToCompletionItem(*elem));
      }
      value->items = std::move(values);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required CompletionList attribute: items"
      );
    }

    return value;
  }

  auto LspTransformer::completionListToAny(
    const CompletionList &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("isIncomplete", booleanToAny(structure.isIncomplete));
    if (structure.itemDefaults.has_value()) {
      object.emplace("itemDefaults", completionList_itemDefaultsToAny(*structure.itemDefaults.value()));
    }
    {
      LSPArray array;
      for (const std::unique_ptr<CompletionItem> &elem : structure.items) {
        array.push_back(completionItemToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("items", std::move(any));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToCompletionRegistrationOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<CompletionRegistrationOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) CompletionRegistrationOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<CompletionRegistrationOptions> value =
      std::make_unique<CompletionRegistrationOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 6) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) CompletionRegistrationOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("documentSelector");
    if (iter != object.end()) {
      value->documentSelector = anyToTextDocumentRegistrationOptions_documentSelector(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required CompletionRegistrationOptions attribute: documentSelector"
      );
    }

    iter = object.find("triggerCharacters");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<string_t> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToString(*elem));
      }
      value->triggerCharacters = std::move(values);
    }

    iter = object.find("allCommitCharacters");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<string_t> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToString(*elem));
      }
      value->allCommitCharacters = std::move(values);
    }

    iter = object.find("resolveProvider");
    if (iter != object.end()) {
      value->resolveProvider = anyToBoolean(*iter->second);
    }

    iter = object.find("completionItem");
    if (iter != object.end()) {
      value->completionItem = anyToCompletionOptions_completionItem(*iter->second);
    }

    iter = object.find("workDoneProgress");
    if (iter != object.end()) {
      value->workDoneProgress = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::completionRegistrationOptionsToAny(
    const CompletionRegistrationOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("documentSelector", textDocumentRegistrationOptions_documentSelectorToAny(structure.documentSelector));
    if (structure.triggerCharacters.has_value()) {
      LSPArray array;
      for (const string_t &elem : structure.triggerCharacters.value()) {
        array.push_back(stringToAny(elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("triggerCharacters", std::move(any));
    }
    if (structure.allCommitCharacters.has_value()) {
      LSPArray array;
      for (const string_t &elem : structure.allCommitCharacters.value()) {
        array.push_back(stringToAny(elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("allCommitCharacters", std::move(any));
    }
    if (structure.resolveProvider.has_value()) {
      object.emplace("resolveProvider", booleanToAny(structure.resolveProvider.value()));
    }
    if (structure.completionItem.has_value()) {
      object.emplace("completionItem", completionOptions_completionItemToAny(*structure.completionItem.value()));
    }
    if (structure.workDoneProgress.has_value()) {
      object.emplace("workDoneProgress", booleanToAny(structure.workDoneProgress.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToHoverParams(
    const LSPAny &any
  ) const -> std::unique_ptr<HoverParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) HoverParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<HoverParams> value =
      std::make_unique<HoverParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) HoverParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("textDocument");
    if (iter != object.end()) {
      value->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required HoverParams attribute: textDocument"
      );
    }

    iter = object.find("position");
    if (iter != object.end()) {
      value->position = anyToPosition(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required HoverParams attribute: position"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      value->workDoneToken = anyToProgressToken(*iter->second);
    }

    return value;
  }

  auto LspTransformer::hoverParamsToAny(
    const HoverParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("textDocument", textDocumentIdentifierToAny(*structure.textDocument));
    object.emplace("position", positionToAny(*structure.position));
    if (structure.workDoneToken.has_value()) {
      object.emplace("workDoneToken", progressTokenToAny(structure.workDoneToken.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToHover_contents(
    const LSPAny &any
  ) const -> Hover_contents {
    Hover_contents value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::OBJECT_TYPE: {
      try {
        value = anyToMarkupContent(any);
      } catch (LspException &e) {
        try {
          value = anyToMarkedString(any);
        } catch (LspException &e) {
          throw LSP_EXCEPTION(
            ErrorCodes::INVALID_PARAMS,
            "Failed to transform LSPAny to Hover_contents"
          );
        }
      }
      break;
    }
    case LSPAnyType::ARRAY_TYPE: {
      try {
        std::vector<MarkedString> values;
        for (const std::unique_ptr<LSPAny> &elem
            : std::get<LSPArray>(any)) {
          values.push_back(anyToMarkedString(*elem));
        }
        value = std::move(values);
      } catch (LspException &e) {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          "Failed to transform LSPAny to array"
        );
      }
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) Hover_contents: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::hover_contentsToAny(
    const Hover_contents &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<Hover_contentsType>(variant.index())) {
    case Hover_contentsType::MARKUP_CONTENT: {
      return markupContentToAny(
        *std::get<std::unique_ptr<MarkupContent>>(variant)
      );
    }
    case Hover_contentsType::MARKED_STRING: {
      return markedStringToAny(
        std::get<MarkedString>(variant)
      );
    }
    case Hover_contentsType::MARKED_STRING_ARRAY: {
      LSPArray array;
      for (const MarkedString &elem
          : std::get<std::vector<MarkedString>>(variant)) {
        array.push_back(markedStringToAny(elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      return any;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported Hover_contentsType: " +
         Hover_contentsTypeNames.at(static_cast<Hover_contentsType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToHover(
    const LSPAny &any
  ) const -> std::unique_ptr<Hover> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) Hover must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<Hover> value =
      std::make_unique<Hover>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) Hover: " + std::to_string(object.size())
      );
    }

    iter = object.find("contents");
    if (iter != object.end()) {
      value->contents = anyToHover_contents(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required Hover attribute: contents"
      );
    }

    iter = object.find("range");
    if (iter != object.end()) {
      value->range = anyToRange(*iter->second);
    }

    return value;
  }

  auto LspTransformer::hoverToAny(
    const Hover &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("contents", hover_contentsToAny(structure.contents));
    if (structure.range.has_value()) {
      object.emplace("range", rangeToAny(*structure.range.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToHoverRegistrationOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<HoverRegistrationOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) HoverRegistrationOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<HoverRegistrationOptions> value =
      std::make_unique<HoverRegistrationOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) HoverRegistrationOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("documentSelector");
    if (iter != object.end()) {
      value->documentSelector = anyToTextDocumentRegistrationOptions_documentSelector(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required HoverRegistrationOptions attribute: documentSelector"
      );
    }

    iter = object.find("workDoneProgress");
    if (iter != object.end()) {
      value->workDoneProgress = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::hoverRegistrationOptionsToAny(
    const HoverRegistrationOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("documentSelector", textDocumentRegistrationOptions_documentSelectorToAny(structure.documentSelector));
    if (structure.workDoneProgress.has_value()) {
      object.emplace("workDoneProgress", booleanToAny(structure.workDoneProgress.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToSignatureHelpParams(
    const LSPAny &any
  ) const -> std::unique_ptr<SignatureHelpParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) SignatureHelpParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<SignatureHelpParams> value =
      std::make_unique<SignatureHelpParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 4) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) SignatureHelpParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("context");
    if (iter != object.end()) {
      value->context = anyToSignatureHelpContext(*iter->second);
    }

    iter = object.find("textDocument");
    if (iter != object.end()) {
      value->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required SignatureHelpParams attribute: textDocument"
      );
    }

    iter = object.find("position");
    if (iter != object.end()) {
      value->position = anyToPosition(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required SignatureHelpParams attribute: position"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      value->workDoneToken = anyToProgressToken(*iter->second);
    }

    return value;
  }

  auto LspTransformer::signatureHelpParamsToAny(
    const SignatureHelpParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.context.has_value()) {
      object.emplace("context", signatureHelpContextToAny(*structure.context.value()));
    }
    object.emplace("textDocument", textDocumentIdentifierToAny(*structure.textDocument));
    object.emplace("position", positionToAny(*structure.position));
    if (structure.workDoneToken.has_value()) {
      object.emplace("workDoneToken", progressTokenToAny(structure.workDoneToken.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToSignatureHelp(
    const LSPAny &any
  ) const -> std::unique_ptr<SignatureHelp> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) SignatureHelp must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<SignatureHelp> value =
      std::make_unique<SignatureHelp>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) SignatureHelp: " + std::to_string(object.size())
      );
    }

    iter = object.find("signatures");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<std::unique_ptr<SignatureInformation>> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToSignatureInformation(*elem));
      }
      value->signatures = std::move(values);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required SignatureHelp attribute: signatures"
      );
    }

    iter = object.find("activeSignature");
    if (iter != object.end()) {
      value->activeSignature = anyToUInteger(*iter->second);
    }

    iter = object.find("activeParameter");
    if (iter != object.end()) {
      value->activeParameter = anyToUInteger(*iter->second);
    }

    return value;
  }

  auto LspTransformer::signatureHelpToAny(
    const SignatureHelp &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    {
      LSPArray array;
      for (const std::unique_ptr<SignatureInformation> &elem : structure.signatures) {
        array.push_back(signatureInformationToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("signatures", std::move(any));
    }
    if (structure.activeSignature.has_value()) {
      object.emplace("activeSignature", uintegerToAny(structure.activeSignature.value()));
    }
    if (structure.activeParameter.has_value()) {
      object.emplace("activeParameter", uintegerToAny(structure.activeParameter.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToSignatureHelpRegistrationOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<SignatureHelpRegistrationOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) SignatureHelpRegistrationOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<SignatureHelpRegistrationOptions> value =
      std::make_unique<SignatureHelpRegistrationOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 4) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) SignatureHelpRegistrationOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("documentSelector");
    if (iter != object.end()) {
      value->documentSelector = anyToTextDocumentRegistrationOptions_documentSelector(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required SignatureHelpRegistrationOptions attribute: documentSelector"
      );
    }

    iter = object.find("triggerCharacters");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<string_t> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToString(*elem));
      }
      value->triggerCharacters = std::move(values);
    }

    iter = object.find("retriggerCharacters");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<string_t> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToString(*elem));
      }
      value->retriggerCharacters = std::move(values);
    }

    iter = object.find("workDoneProgress");
    if (iter != object.end()) {
      value->workDoneProgress = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::signatureHelpRegistrationOptionsToAny(
    const SignatureHelpRegistrationOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("documentSelector", textDocumentRegistrationOptions_documentSelectorToAny(structure.documentSelector));
    if (structure.triggerCharacters.has_value()) {
      LSPArray array;
      for (const string_t &elem : structure.triggerCharacters.value()) {
        array.push_back(stringToAny(elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("triggerCharacters", std::move(any));
    }
    if (structure.retriggerCharacters.has_value()) {
      LSPArray array;
      for (const string_t &elem : structure.retriggerCharacters.value()) {
        array.push_back(stringToAny(elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("retriggerCharacters", std::move(any));
    }
    if (structure.workDoneProgress.has_value()) {
      object.emplace("workDoneProgress", booleanToAny(structure.workDoneProgress.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToDefinitionParams(
    const LSPAny &any
  ) const -> std::unique_ptr<DefinitionParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) DefinitionParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<DefinitionParams> value =
      std::make_unique<DefinitionParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 4) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) DefinitionParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("textDocument");
    if (iter != object.end()) {
      value->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DefinitionParams attribute: textDocument"
      );
    }

    iter = object.find("position");
    if (iter != object.end()) {
      value->position = anyToPosition(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DefinitionParams attribute: position"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      value->workDoneToken = anyToProgressToken(*iter->second);
    }

    iter = object.find("partialResultToken");
    if (iter != object.end()) {
      value->partialResultToken = anyToProgressToken(*iter->second);
    }

    return value;
  }

  auto LspTransformer::definitionParamsToAny(
    const DefinitionParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("textDocument", textDocumentIdentifierToAny(*structure.textDocument));
    object.emplace("position", positionToAny(*structure.position));
    if (structure.workDoneToken.has_value()) {
      object.emplace("workDoneToken", progressTokenToAny(structure.workDoneToken.value()));
    }
    if (structure.partialResultToken.has_value()) {
      object.emplace("partialResultToken", progressTokenToAny(structure.partialResultToken.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToDefinitionRegistrationOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<DefinitionRegistrationOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) DefinitionRegistrationOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<DefinitionRegistrationOptions> value =
      std::make_unique<DefinitionRegistrationOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) DefinitionRegistrationOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("documentSelector");
    if (iter != object.end()) {
      value->documentSelector = anyToTextDocumentRegistrationOptions_documentSelector(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DefinitionRegistrationOptions attribute: documentSelector"
      );
    }

    iter = object.find("workDoneProgress");
    if (iter != object.end()) {
      value->workDoneProgress = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::definitionRegistrationOptionsToAny(
    const DefinitionRegistrationOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("documentSelector", textDocumentRegistrationOptions_documentSelectorToAny(structure.documentSelector));
    if (structure.workDoneProgress.has_value()) {
      object.emplace("workDoneProgress", booleanToAny(structure.workDoneProgress.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToReferenceParams(
    const LSPAny &any
  ) const -> std::unique_ptr<ReferenceParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) ReferenceParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<ReferenceParams> value =
      std::make_unique<ReferenceParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 5) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) ReferenceParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("context");
    if (iter != object.end()) {
      value->context = anyToReferenceContext(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required ReferenceParams attribute: context"
      );
    }

    iter = object.find("textDocument");
    if (iter != object.end()) {
      value->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required ReferenceParams attribute: textDocument"
      );
    }

    iter = object.find("position");
    if (iter != object.end()) {
      value->position = anyToPosition(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required ReferenceParams attribute: position"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      value->workDoneToken = anyToProgressToken(*iter->second);
    }

    iter = object.find("partialResultToken");
    if (iter != object.end()) {
      value->partialResultToken = anyToProgressToken(*iter->second);
    }

    return value;
  }

  auto LspTransformer::referenceParamsToAny(
    const ReferenceParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("context", referenceContextToAny(*structure.context));
    object.emplace("textDocument", textDocumentIdentifierToAny(*structure.textDocument));
    object.emplace("position", positionToAny(*structure.position));
    if (structure.workDoneToken.has_value()) {
      object.emplace("workDoneToken", progressTokenToAny(structure.workDoneToken.value()));
    }
    if (structure.partialResultToken.has_value()) {
      object.emplace("partialResultToken", progressTokenToAny(structure.partialResultToken.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToReferenceRegistrationOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<ReferenceRegistrationOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) ReferenceRegistrationOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<ReferenceRegistrationOptions> value =
      std::make_unique<ReferenceRegistrationOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) ReferenceRegistrationOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("documentSelector");
    if (iter != object.end()) {
      value->documentSelector = anyToTextDocumentRegistrationOptions_documentSelector(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required ReferenceRegistrationOptions attribute: documentSelector"
      );
    }

    iter = object.find("workDoneProgress");
    if (iter != object.end()) {
      value->workDoneProgress = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::referenceRegistrationOptionsToAny(
    const ReferenceRegistrationOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("documentSelector", textDocumentRegistrationOptions_documentSelectorToAny(structure.documentSelector));
    if (structure.workDoneProgress.has_value()) {
      object.emplace("workDoneProgress", booleanToAny(structure.workDoneProgress.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToDocumentHighlightParams(
    const LSPAny &any
  ) const -> std::unique_ptr<DocumentHighlightParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) DocumentHighlightParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<DocumentHighlightParams> value =
      std::make_unique<DocumentHighlightParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 4) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) DocumentHighlightParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("textDocument");
    if (iter != object.end()) {
      value->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DocumentHighlightParams attribute: textDocument"
      );
    }

    iter = object.find("position");
    if (iter != object.end()) {
      value->position = anyToPosition(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DocumentHighlightParams attribute: position"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      value->workDoneToken = anyToProgressToken(*iter->second);
    }

    iter = object.find("partialResultToken");
    if (iter != object.end()) {
      value->partialResultToken = anyToProgressToken(*iter->second);
    }

    return value;
  }

  auto LspTransformer::documentHighlightParamsToAny(
    const DocumentHighlightParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("textDocument", textDocumentIdentifierToAny(*structure.textDocument));
    object.emplace("position", positionToAny(*structure.position));
    if (structure.workDoneToken.has_value()) {
      object.emplace("workDoneToken", progressTokenToAny(structure.workDoneToken.value()));
    }
    if (structure.partialResultToken.has_value()) {
      object.emplace("partialResultToken", progressTokenToAny(structure.partialResultToken.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToDocumentHighlight(
    const LSPAny &any
  ) const -> std::unique_ptr<DocumentHighlight> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) DocumentHighlight must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<DocumentHighlight> value =
      std::make_unique<DocumentHighlight>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) DocumentHighlight: " + std::to_string(object.size())
      );
    }

    iter = object.find("range");
    if (iter != object.end()) {
      value->range = anyToRange(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DocumentHighlight attribute: range"
      );
    }

    iter = object.find("kind");
    if (iter != object.end()) {
      value->kind = anyToDocumentHighlightKind(*iter->second);
    }

    return value;
  }

  auto LspTransformer::documentHighlightToAny(
    const DocumentHighlight &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("range", rangeToAny(*structure.range));
    if (structure.kind.has_value()) {
      object.emplace("kind", documentHighlightKindToAny(structure.kind.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToDocumentHighlightRegistrationOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<DocumentHighlightRegistrationOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) DocumentHighlightRegistrationOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<DocumentHighlightRegistrationOptions> value =
      std::make_unique<DocumentHighlightRegistrationOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) DocumentHighlightRegistrationOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("documentSelector");
    if (iter != object.end()) {
      value->documentSelector = anyToTextDocumentRegistrationOptions_documentSelector(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DocumentHighlightRegistrationOptions attribute: documentSelector"
      );
    }

    iter = object.find("workDoneProgress");
    if (iter != object.end()) {
      value->workDoneProgress = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::documentHighlightRegistrationOptionsToAny(
    const DocumentHighlightRegistrationOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("documentSelector", textDocumentRegistrationOptions_documentSelectorToAny(structure.documentSelector));
    if (structure.workDoneProgress.has_value()) {
      object.emplace("workDoneProgress", booleanToAny(structure.workDoneProgress.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToDocumentSymbolParams(
    const LSPAny &any
  ) const -> std::unique_ptr<DocumentSymbolParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) DocumentSymbolParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<DocumentSymbolParams> value =
      std::make_unique<DocumentSymbolParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) DocumentSymbolParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("textDocument");
    if (iter != object.end()) {
      value->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DocumentSymbolParams attribute: textDocument"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      value->workDoneToken = anyToProgressToken(*iter->second);
    }

    iter = object.find("partialResultToken");
    if (iter != object.end()) {
      value->partialResultToken = anyToProgressToken(*iter->second);
    }

    return value;
  }

  auto LspTransformer::documentSymbolParamsToAny(
    const DocumentSymbolParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("textDocument", textDocumentIdentifierToAny(*structure.textDocument));
    if (structure.workDoneToken.has_value()) {
      object.emplace("workDoneToken", progressTokenToAny(structure.workDoneToken.value()));
    }
    if (structure.partialResultToken.has_value()) {
      object.emplace("partialResultToken", progressTokenToAny(structure.partialResultToken.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToSymbolInformation(
    const LSPAny &any
  ) const -> std::unique_ptr<SymbolInformation> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) SymbolInformation must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<SymbolInformation> value =
      std::make_unique<SymbolInformation>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 6) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) SymbolInformation: " + std::to_string(object.size())
      );
    }

    iter = object.find("deprecated");
    if (iter != object.end()) {
      value->deprecated = anyToBoolean(*iter->second);
    }

    iter = object.find("location");
    if (iter != object.end()) {
      value->location = anyToLocation(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required SymbolInformation attribute: location"
      );
    }

    iter = object.find("name");
    if (iter != object.end()) {
      value->name = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required SymbolInformation attribute: name"
      );
    }

    iter = object.find("kind");
    if (iter != object.end()) {
      value->kind = anyToSymbolKind(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required SymbolInformation attribute: kind"
      );
    }

    iter = object.find("tags");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<SymbolTag> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToSymbolTag(*elem));
      }
      value->tags = std::move(values);
    }

    iter = object.find("containerName");
    if (iter != object.end()) {
      value->containerName = anyToString(*iter->second);
    }

    return value;
  }

  auto LspTransformer::symbolInformationToAny(
    const SymbolInformation &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.deprecated.has_value()) {
      object.emplace("deprecated", booleanToAny(structure.deprecated.value()));
    }
    object.emplace("location", locationToAny(*structure.location));
    object.emplace("name", stringToAny(structure.name));
    object.emplace("kind", symbolKindToAny(structure.kind));
    if (structure.tags.has_value()) {
      LSPArray array;
      for (const SymbolTag &elem : structure.tags.value()) {
        array.push_back(symbolTagToAny(elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("tags", std::move(any));
    }
    if (structure.containerName.has_value()) {
      object.emplace("containerName", stringToAny(structure.containerName.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToDocumentSymbol(
    const LSPAny &any
  ) const -> std::unique_ptr<DocumentSymbol> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) DocumentSymbol must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<DocumentSymbol> value =
      std::make_unique<DocumentSymbol>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 8) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) DocumentSymbol: " + std::to_string(object.size())
      );
    }

    iter = object.find("name");
    if (iter != object.end()) {
      value->name = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DocumentSymbol attribute: name"
      );
    }

    iter = object.find("detail");
    if (iter != object.end()) {
      value->detail = anyToString(*iter->second);
    }

    iter = object.find("kind");
    if (iter != object.end()) {
      value->kind = anyToSymbolKind(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DocumentSymbol attribute: kind"
      );
    }

    iter = object.find("tags");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<SymbolTag> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToSymbolTag(*elem));
      }
      value->tags = std::move(values);
    }

    iter = object.find("deprecated");
    if (iter != object.end()) {
      value->deprecated = anyToBoolean(*iter->second);
    }

    iter = object.find("range");
    if (iter != object.end()) {
      value->range = anyToRange(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DocumentSymbol attribute: range"
      );
    }

    iter = object.find("selectionRange");
    if (iter != object.end()) {
      value->selectionRange = anyToRange(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DocumentSymbol attribute: selectionRange"
      );
    }

    iter = object.find("children");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<std::unique_ptr<DocumentSymbol>> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToDocumentSymbol(*elem));
      }
      value->children = std::move(values);
    }

    return value;
  }

  auto LspTransformer::documentSymbolToAny(
    const DocumentSymbol &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("name", stringToAny(structure.name));
    if (structure.detail.has_value()) {
      object.emplace("detail", stringToAny(structure.detail.value()));
    }
    object.emplace("kind", symbolKindToAny(structure.kind));
    if (structure.tags.has_value()) {
      LSPArray array;
      for (const SymbolTag &elem : structure.tags.value()) {
        array.push_back(symbolTagToAny(elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("tags", std::move(any));
    }
    if (structure.deprecated.has_value()) {
      object.emplace("deprecated", booleanToAny(structure.deprecated.value()));
    }
    object.emplace("range", rangeToAny(*structure.range));
    object.emplace("selectionRange", rangeToAny(*structure.selectionRange));
    if (structure.children.has_value()) {
      LSPArray array;
      for (const std::unique_ptr<DocumentSymbol> &elem : structure.children.value()) {
        array.push_back(documentSymbolToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("children", std::move(any));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToDocumentSymbolRegistrationOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<DocumentSymbolRegistrationOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) DocumentSymbolRegistrationOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<DocumentSymbolRegistrationOptions> value =
      std::make_unique<DocumentSymbolRegistrationOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) DocumentSymbolRegistrationOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("documentSelector");
    if (iter != object.end()) {
      value->documentSelector = anyToTextDocumentRegistrationOptions_documentSelector(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DocumentSymbolRegistrationOptions attribute: documentSelector"
      );
    }

    iter = object.find("label");
    if (iter != object.end()) {
      value->label = anyToString(*iter->second);
    }

    iter = object.find("workDoneProgress");
    if (iter != object.end()) {
      value->workDoneProgress = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::documentSymbolRegistrationOptionsToAny(
    const DocumentSymbolRegistrationOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("documentSelector", textDocumentRegistrationOptions_documentSelectorToAny(structure.documentSelector));
    if (structure.label.has_value()) {
      object.emplace("label", stringToAny(structure.label.value()));
    }
    if (structure.workDoneProgress.has_value()) {
      object.emplace("workDoneProgress", booleanToAny(structure.workDoneProgress.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToCodeActionParams(
    const LSPAny &any
  ) const -> std::unique_ptr<CodeActionParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) CodeActionParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<CodeActionParams> value =
      std::make_unique<CodeActionParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 5) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) CodeActionParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("textDocument");
    if (iter != object.end()) {
      value->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required CodeActionParams attribute: textDocument"
      );
    }

    iter = object.find("range");
    if (iter != object.end()) {
      value->range = anyToRange(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required CodeActionParams attribute: range"
      );
    }

    iter = object.find("context");
    if (iter != object.end()) {
      value->context = anyToCodeActionContext(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required CodeActionParams attribute: context"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      value->workDoneToken = anyToProgressToken(*iter->second);
    }

    iter = object.find("partialResultToken");
    if (iter != object.end()) {
      value->partialResultToken = anyToProgressToken(*iter->second);
    }

    return value;
  }

  auto LspTransformer::codeActionParamsToAny(
    const CodeActionParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("textDocument", textDocumentIdentifierToAny(*structure.textDocument));
    object.emplace("range", rangeToAny(*structure.range));
    object.emplace("context", codeActionContextToAny(*structure.context));
    if (structure.workDoneToken.has_value()) {
      object.emplace("workDoneToken", progressTokenToAny(structure.workDoneToken.value()));
    }
    if (structure.partialResultToken.has_value()) {
      object.emplace("partialResultToken", progressTokenToAny(structure.partialResultToken.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToCommand(
    const LSPAny &any
  ) const -> std::unique_ptr<Command> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) Command must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<Command> value =
      std::make_unique<Command>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) Command: " + std::to_string(object.size())
      );
    }

    iter = object.find("title");
    if (iter != object.end()) {
      value->title = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required Command attribute: title"
      );
    }

    iter = object.find("command");
    if (iter != object.end()) {
      value->command = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required Command attribute: command"
      );
    }

    iter = object.find("arguments");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<std::unique_ptr<LSPAny>> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(copy(elem));
      }
      value->arguments = std::move(values);
    }

    return value;
  }

  auto LspTransformer::commandToAny(
    const Command &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("title", stringToAny(structure.title));
    object.emplace("command", stringToAny(structure.command));
    if (structure.arguments.has_value()) {
      LSPArray array;
      for (const std::unique_ptr<LSPAny> &elem : structure.arguments.value()) {
        array.push_back(copy(elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("arguments", std::move(any));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToCodeAction_disabled(
    const LSPAny &any
  ) const -> std::unique_ptr<CodeAction_disabled> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) CodeAction_disabled must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<CodeAction_disabled> value =
      std::make_unique<CodeAction_disabled>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) CodeAction_disabled: " + std::to_string(object.size())
      );
    }

    iter = object.find("reason");
    if (iter != object.end()) {
      value->reason = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required CodeAction_disabled attribute: reason"
      );
    }

    return value;
  }

  auto LspTransformer::codeAction_disabledToAny(
    const CodeAction_disabled &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("reason", stringToAny(structure.reason));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToCodeAction(
    const LSPAny &any
  ) const -> std::unique_ptr<CodeAction> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) CodeAction must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<CodeAction> value =
      std::make_unique<CodeAction>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 8) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) CodeAction: " + std::to_string(object.size())
      );
    }

    iter = object.find("title");
    if (iter != object.end()) {
      value->title = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required CodeAction attribute: title"
      );
    }

    iter = object.find("kind");
    if (iter != object.end()) {
      value->kind = anyToCodeActionKind(*iter->second);
    }

    iter = object.find("diagnostics");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<std::unique_ptr<Diagnostic>> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToDiagnostic(*elem));
      }
      value->diagnostics = std::move(values);
    }

    iter = object.find("isPreferred");
    if (iter != object.end()) {
      value->isPreferred = anyToBoolean(*iter->second);
    }

    iter = object.find("disabled");
    if (iter != object.end()) {
      value->disabled = anyToCodeAction_disabled(*iter->second);
    }

    iter = object.find("edit");
    if (iter != object.end()) {
      value->edit = anyToWorkspaceEdit(*iter->second);
    }

    iter = object.find("command");
    if (iter != object.end()) {
      value->command = anyToCommand(*iter->second);
    }

    iter = object.find("data");
    if (iter != object.end()) {
      value->data = copy(iter->second);
    }

    return value;
  }

  auto LspTransformer::codeActionToAny(
    const CodeAction &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("title", stringToAny(structure.title));
    if (structure.kind.has_value()) {
      object.emplace("kind", codeActionKindToAny(structure.kind.value()));
    }
    if (structure.diagnostics.has_value()) {
      LSPArray array;
      for (const std::unique_ptr<Diagnostic> &elem : structure.diagnostics.value()) {
        array.push_back(diagnosticToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("diagnostics", std::move(any));
    }
    if (structure.isPreferred.has_value()) {
      object.emplace("isPreferred", booleanToAny(structure.isPreferred.value()));
    }
    if (structure.disabled.has_value()) {
      object.emplace("disabled", codeAction_disabledToAny(*structure.disabled.value()));
    }
    if (structure.edit.has_value()) {
      object.emplace("edit", workspaceEditToAny(*structure.edit.value()));
    }
    if (structure.command.has_value()) {
      object.emplace("command", commandToAny(*structure.command.value()));
    }
    if (structure.data.has_value()) {
      object.emplace("data", copy(structure.data.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToCodeActionRegistrationOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<CodeActionRegistrationOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) CodeActionRegistrationOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<CodeActionRegistrationOptions> value =
      std::make_unique<CodeActionRegistrationOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 4) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) CodeActionRegistrationOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("documentSelector");
    if (iter != object.end()) {
      value->documentSelector = anyToTextDocumentRegistrationOptions_documentSelector(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required CodeActionRegistrationOptions attribute: documentSelector"
      );
    }

    iter = object.find("codeActionKinds");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<CodeActionKind> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToCodeActionKind(*elem));
      }
      value->codeActionKinds = std::move(values);
    }

    iter = object.find("resolveProvider");
    if (iter != object.end()) {
      value->resolveProvider = anyToBoolean(*iter->second);
    }

    iter = object.find("workDoneProgress");
    if (iter != object.end()) {
      value->workDoneProgress = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::codeActionRegistrationOptionsToAny(
    const CodeActionRegistrationOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("documentSelector", textDocumentRegistrationOptions_documentSelectorToAny(structure.documentSelector));
    if (structure.codeActionKinds.has_value()) {
      LSPArray array;
      for (const CodeActionKind &elem : structure.codeActionKinds.value()) {
        array.push_back(codeActionKindToAny(elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("codeActionKinds", std::move(any));
    }
    if (structure.resolveProvider.has_value()) {
      object.emplace("resolveProvider", booleanToAny(structure.resolveProvider.value()));
    }
    if (structure.workDoneProgress.has_value()) {
      object.emplace("workDoneProgress", booleanToAny(structure.workDoneProgress.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToWorkspaceSymbolParams(
    const LSPAny &any
  ) const -> std::unique_ptr<WorkspaceSymbolParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) WorkspaceSymbolParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<WorkspaceSymbolParams> value =
      std::make_unique<WorkspaceSymbolParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) WorkspaceSymbolParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("query");
    if (iter != object.end()) {
      value->query = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required WorkspaceSymbolParams attribute: query"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      value->workDoneToken = anyToProgressToken(*iter->second);
    }

    iter = object.find("partialResultToken");
    if (iter != object.end()) {
      value->partialResultToken = anyToProgressToken(*iter->second);
    }

    return value;
  }

  auto LspTransformer::workspaceSymbolParamsToAny(
    const WorkspaceSymbolParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("query", stringToAny(structure.query));
    if (structure.workDoneToken.has_value()) {
      object.emplace("workDoneToken", progressTokenToAny(structure.workDoneToken.value()));
    }
    if (structure.partialResultToken.has_value()) {
      object.emplace("partialResultToken", progressTokenToAny(structure.partialResultToken.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToWorkspaceSymbol_location_1(
    const LSPAny &any
  ) const -> std::unique_ptr<WorkspaceSymbol_location_1> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) WorkspaceSymbol_location_1 must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<WorkspaceSymbol_location_1> value =
      std::make_unique<WorkspaceSymbol_location_1>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) WorkspaceSymbol_location_1: " + std::to_string(object.size())
      );
    }

    iter = object.find("uri");
    if (iter != object.end()) {
      value->uri = anyToDocumentUri(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required WorkspaceSymbol_location_1 attribute: uri"
      );
    }

    return value;
  }

  auto LspTransformer::workspaceSymbol_location_1ToAny(
    const WorkspaceSymbol_location_1 &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("uri", documentUriToAny(structure.uri));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToWorkspaceSymbol_location(
    const LSPAny &any
  ) const -> WorkspaceSymbol_location {
    WorkspaceSymbol_location value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::OBJECT_TYPE: {
      try {
        value = anyToLocation(any);
      } catch (LspException &e) {
        try {
          value = anyToWorkspaceSymbol_location_1(any);
        } catch (LspException &e) {
          throw LSP_EXCEPTION(
            ErrorCodes::INVALID_PARAMS,
            "Failed to transform LSPAny to WorkspaceSymbol_location"
          );
        }
      }
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) WorkspaceSymbol_location: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::workspaceSymbol_locationToAny(
    const WorkspaceSymbol_location &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<WorkspaceSymbol_locationType>(variant.index())) {
    case WorkspaceSymbol_locationType::LOCATION: {
      return locationToAny(
        *std::get<std::unique_ptr<Location>>(variant)
      );
    }
    case WorkspaceSymbol_locationType::WORKSPACE_SYMBOL_LOCATION_1: {
      return workspaceSymbol_location_1ToAny(
        *std::get<std::unique_ptr<WorkspaceSymbol_location_1>>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported WorkspaceSymbol_locationType: " +
         WorkspaceSymbol_locationTypeNames.at(static_cast<WorkspaceSymbol_locationType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToWorkspaceSymbol(
    const LSPAny &any
  ) const -> std::unique_ptr<WorkspaceSymbol> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) WorkspaceSymbol must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<WorkspaceSymbol> value =
      std::make_unique<WorkspaceSymbol>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 6) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) WorkspaceSymbol: " + std::to_string(object.size())
      );
    }

    iter = object.find("location");
    if (iter != object.end()) {
      value->location = anyToWorkspaceSymbol_location(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required WorkspaceSymbol attribute: location"
      );
    }

    iter = object.find("data");
    if (iter != object.end()) {
      value->data = copy(iter->second);
    }

    iter = object.find("name");
    if (iter != object.end()) {
      value->name = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required WorkspaceSymbol attribute: name"
      );
    }

    iter = object.find("kind");
    if (iter != object.end()) {
      value->kind = anyToSymbolKind(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required WorkspaceSymbol attribute: kind"
      );
    }

    iter = object.find("tags");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<SymbolTag> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToSymbolTag(*elem));
      }
      value->tags = std::move(values);
    }

    iter = object.find("containerName");
    if (iter != object.end()) {
      value->containerName = anyToString(*iter->second);
    }

    return value;
  }

  auto LspTransformer::workspaceSymbolToAny(
    const WorkspaceSymbol &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("location", workspaceSymbol_locationToAny(structure.location));
    if (structure.data.has_value()) {
      object.emplace("data", copy(structure.data.value()));
    }
    object.emplace("name", stringToAny(structure.name));
    object.emplace("kind", symbolKindToAny(structure.kind));
    if (structure.tags.has_value()) {
      LSPArray array;
      for (const SymbolTag &elem : structure.tags.value()) {
        array.push_back(symbolTagToAny(elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("tags", std::move(any));
    }
    if (structure.containerName.has_value()) {
      object.emplace("containerName", stringToAny(structure.containerName.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToWorkspaceSymbolRegistrationOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<WorkspaceSymbolRegistrationOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) WorkspaceSymbolRegistrationOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<WorkspaceSymbolRegistrationOptions> value =
      std::make_unique<WorkspaceSymbolRegistrationOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) WorkspaceSymbolRegistrationOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("resolveProvider");
    if (iter != object.end()) {
      value->resolveProvider = anyToBoolean(*iter->second);
    }

    iter = object.find("workDoneProgress");
    if (iter != object.end()) {
      value->workDoneProgress = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::workspaceSymbolRegistrationOptionsToAny(
    const WorkspaceSymbolRegistrationOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.resolveProvider.has_value()) {
      object.emplace("resolveProvider", booleanToAny(structure.resolveProvider.value()));
    }
    if (structure.workDoneProgress.has_value()) {
      object.emplace("workDoneProgress", booleanToAny(structure.workDoneProgress.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToCodeLensParams(
    const LSPAny &any
  ) const -> std::unique_ptr<CodeLensParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) CodeLensParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<CodeLensParams> value =
      std::make_unique<CodeLensParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) CodeLensParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("textDocument");
    if (iter != object.end()) {
      value->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required CodeLensParams attribute: textDocument"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      value->workDoneToken = anyToProgressToken(*iter->second);
    }

    iter = object.find("partialResultToken");
    if (iter != object.end()) {
      value->partialResultToken = anyToProgressToken(*iter->second);
    }

    return value;
  }

  auto LspTransformer::codeLensParamsToAny(
    const CodeLensParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("textDocument", textDocumentIdentifierToAny(*structure.textDocument));
    if (structure.workDoneToken.has_value()) {
      object.emplace("workDoneToken", progressTokenToAny(structure.workDoneToken.value()));
    }
    if (structure.partialResultToken.has_value()) {
      object.emplace("partialResultToken", progressTokenToAny(structure.partialResultToken.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToCodeLens(
    const LSPAny &any
  ) const -> std::unique_ptr<CodeLens> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) CodeLens must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<CodeLens> value =
      std::make_unique<CodeLens>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) CodeLens: " + std::to_string(object.size())
      );
    }

    iter = object.find("range");
    if (iter != object.end()) {
      value->range = anyToRange(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required CodeLens attribute: range"
      );
    }

    iter = object.find("command");
    if (iter != object.end()) {
      value->command = anyToCommand(*iter->second);
    }

    iter = object.find("data");
    if (iter != object.end()) {
      value->data = copy(iter->second);
    }

    return value;
  }

  auto LspTransformer::codeLensToAny(
    const CodeLens &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("range", rangeToAny(*structure.range));
    if (structure.command.has_value()) {
      object.emplace("command", commandToAny(*structure.command.value()));
    }
    if (structure.data.has_value()) {
      object.emplace("data", copy(structure.data.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToCodeLensRegistrationOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<CodeLensRegistrationOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) CodeLensRegistrationOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<CodeLensRegistrationOptions> value =
      std::make_unique<CodeLensRegistrationOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) CodeLensRegistrationOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("documentSelector");
    if (iter != object.end()) {
      value->documentSelector = anyToTextDocumentRegistrationOptions_documentSelector(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required CodeLensRegistrationOptions attribute: documentSelector"
      );
    }

    iter = object.find("resolveProvider");
    if (iter != object.end()) {
      value->resolveProvider = anyToBoolean(*iter->second);
    }

    iter = object.find("workDoneProgress");
    if (iter != object.end()) {
      value->workDoneProgress = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::codeLensRegistrationOptionsToAny(
    const CodeLensRegistrationOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("documentSelector", textDocumentRegistrationOptions_documentSelectorToAny(structure.documentSelector));
    if (structure.resolveProvider.has_value()) {
      object.emplace("resolveProvider", booleanToAny(structure.resolveProvider.value()));
    }
    if (structure.workDoneProgress.has_value()) {
      object.emplace("workDoneProgress", booleanToAny(structure.workDoneProgress.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToDocumentLinkParams(
    const LSPAny &any
  ) const -> std::unique_ptr<DocumentLinkParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) DocumentLinkParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<DocumentLinkParams> value =
      std::make_unique<DocumentLinkParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) DocumentLinkParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("textDocument");
    if (iter != object.end()) {
      value->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DocumentLinkParams attribute: textDocument"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      value->workDoneToken = anyToProgressToken(*iter->second);
    }

    iter = object.find("partialResultToken");
    if (iter != object.end()) {
      value->partialResultToken = anyToProgressToken(*iter->second);
    }

    return value;
  }

  auto LspTransformer::documentLinkParamsToAny(
    const DocumentLinkParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("textDocument", textDocumentIdentifierToAny(*structure.textDocument));
    if (structure.workDoneToken.has_value()) {
      object.emplace("workDoneToken", progressTokenToAny(structure.workDoneToken.value()));
    }
    if (structure.partialResultToken.has_value()) {
      object.emplace("partialResultToken", progressTokenToAny(structure.partialResultToken.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToDocumentLink(
    const LSPAny &any
  ) const -> std::unique_ptr<DocumentLink> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) DocumentLink must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<DocumentLink> value =
      std::make_unique<DocumentLink>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 4) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) DocumentLink: " + std::to_string(object.size())
      );
    }

    iter = object.find("range");
    if (iter != object.end()) {
      value->range = anyToRange(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DocumentLink attribute: range"
      );
    }

    iter = object.find("target");
    if (iter != object.end()) {
      value->target = anyToURI(*iter->second);
    }

    iter = object.find("tooltip");
    if (iter != object.end()) {
      value->tooltip = anyToString(*iter->second);
    }

    iter = object.find("data");
    if (iter != object.end()) {
      value->data = copy(iter->second);
    }

    return value;
  }

  auto LspTransformer::documentLinkToAny(
    const DocumentLink &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("range", rangeToAny(*structure.range));
    if (structure.target.has_value()) {
      object.emplace("target", uriToAny(structure.target.value()));
    }
    if (structure.tooltip.has_value()) {
      object.emplace("tooltip", stringToAny(structure.tooltip.value()));
    }
    if (structure.data.has_value()) {
      object.emplace("data", copy(structure.data.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToDocumentLinkRegistrationOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<DocumentLinkRegistrationOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) DocumentLinkRegistrationOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<DocumentLinkRegistrationOptions> value =
      std::make_unique<DocumentLinkRegistrationOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) DocumentLinkRegistrationOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("documentSelector");
    if (iter != object.end()) {
      value->documentSelector = anyToTextDocumentRegistrationOptions_documentSelector(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DocumentLinkRegistrationOptions attribute: documentSelector"
      );
    }

    iter = object.find("resolveProvider");
    if (iter != object.end()) {
      value->resolveProvider = anyToBoolean(*iter->second);
    }

    iter = object.find("workDoneProgress");
    if (iter != object.end()) {
      value->workDoneProgress = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::documentLinkRegistrationOptionsToAny(
    const DocumentLinkRegistrationOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("documentSelector", textDocumentRegistrationOptions_documentSelectorToAny(structure.documentSelector));
    if (structure.resolveProvider.has_value()) {
      object.emplace("resolveProvider", booleanToAny(structure.resolveProvider.value()));
    }
    if (structure.workDoneProgress.has_value()) {
      object.emplace("workDoneProgress", booleanToAny(structure.workDoneProgress.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToDocumentFormattingParams(
    const LSPAny &any
  ) const -> std::unique_ptr<DocumentFormattingParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) DocumentFormattingParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<DocumentFormattingParams> value =
      std::make_unique<DocumentFormattingParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) DocumentFormattingParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("textDocument");
    if (iter != object.end()) {
      value->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DocumentFormattingParams attribute: textDocument"
      );
    }

    iter = object.find("options");
    if (iter != object.end()) {
      value->options = anyToFormattingOptions(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DocumentFormattingParams attribute: options"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      value->workDoneToken = anyToProgressToken(*iter->second);
    }

    return value;
  }

  auto LspTransformer::documentFormattingParamsToAny(
    const DocumentFormattingParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("textDocument", textDocumentIdentifierToAny(*structure.textDocument));
    object.emplace("options", formattingOptionsToAny(*structure.options));
    if (structure.workDoneToken.has_value()) {
      object.emplace("workDoneToken", progressTokenToAny(structure.workDoneToken.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToDocumentFormattingRegistrationOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<DocumentFormattingRegistrationOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) DocumentFormattingRegistrationOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<DocumentFormattingRegistrationOptions> value =
      std::make_unique<DocumentFormattingRegistrationOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) DocumentFormattingRegistrationOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("documentSelector");
    if (iter != object.end()) {
      value->documentSelector = anyToTextDocumentRegistrationOptions_documentSelector(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DocumentFormattingRegistrationOptions attribute: documentSelector"
      );
    }

    iter = object.find("workDoneProgress");
    if (iter != object.end()) {
      value->workDoneProgress = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::documentFormattingRegistrationOptionsToAny(
    const DocumentFormattingRegistrationOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("documentSelector", textDocumentRegistrationOptions_documentSelectorToAny(structure.documentSelector));
    if (structure.workDoneProgress.has_value()) {
      object.emplace("workDoneProgress", booleanToAny(structure.workDoneProgress.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToDocumentRangeFormattingParams(
    const LSPAny &any
  ) const -> std::unique_ptr<DocumentRangeFormattingParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) DocumentRangeFormattingParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<DocumentRangeFormattingParams> value =
      std::make_unique<DocumentRangeFormattingParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 4) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) DocumentRangeFormattingParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("textDocument");
    if (iter != object.end()) {
      value->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DocumentRangeFormattingParams attribute: textDocument"
      );
    }

    iter = object.find("range");
    if (iter != object.end()) {
      value->range = anyToRange(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DocumentRangeFormattingParams attribute: range"
      );
    }

    iter = object.find("options");
    if (iter != object.end()) {
      value->options = anyToFormattingOptions(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DocumentRangeFormattingParams attribute: options"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      value->workDoneToken = anyToProgressToken(*iter->second);
    }

    return value;
  }

  auto LspTransformer::documentRangeFormattingParamsToAny(
    const DocumentRangeFormattingParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("textDocument", textDocumentIdentifierToAny(*structure.textDocument));
    object.emplace("range", rangeToAny(*structure.range));
    object.emplace("options", formattingOptionsToAny(*structure.options));
    if (structure.workDoneToken.has_value()) {
      object.emplace("workDoneToken", progressTokenToAny(structure.workDoneToken.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToDocumentRangeFormattingRegistrationOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<DocumentRangeFormattingRegistrationOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) DocumentRangeFormattingRegistrationOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<DocumentRangeFormattingRegistrationOptions> value =
      std::make_unique<DocumentRangeFormattingRegistrationOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) DocumentRangeFormattingRegistrationOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("documentSelector");
    if (iter != object.end()) {
      value->documentSelector = anyToTextDocumentRegistrationOptions_documentSelector(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DocumentRangeFormattingRegistrationOptions attribute: documentSelector"
      );
    }

    iter = object.find("rangesSupport");
    if (iter != object.end()) {
      value->rangesSupport = anyToBoolean(*iter->second);
    }

    iter = object.find("workDoneProgress");
    if (iter != object.end()) {
      value->workDoneProgress = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::documentRangeFormattingRegistrationOptionsToAny(
    const DocumentRangeFormattingRegistrationOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("documentSelector", textDocumentRegistrationOptions_documentSelectorToAny(structure.documentSelector));
    if (structure.rangesSupport.has_value()) {
      object.emplace("rangesSupport", booleanToAny(structure.rangesSupport.value()));
    }
    if (structure.workDoneProgress.has_value()) {
      object.emplace("workDoneProgress", booleanToAny(structure.workDoneProgress.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToDocumentRangesFormattingParams(
    const LSPAny &any
  ) const -> std::unique_ptr<DocumentRangesFormattingParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) DocumentRangesFormattingParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<DocumentRangesFormattingParams> value =
      std::make_unique<DocumentRangesFormattingParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 4) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) DocumentRangesFormattingParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("textDocument");
    if (iter != object.end()) {
      value->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DocumentRangesFormattingParams attribute: textDocument"
      );
    }

    iter = object.find("ranges");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<std::unique_ptr<Range>> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToRange(*elem));
      }
      value->ranges = std::move(values);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DocumentRangesFormattingParams attribute: ranges"
      );
    }

    iter = object.find("options");
    if (iter != object.end()) {
      value->options = anyToFormattingOptions(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DocumentRangesFormattingParams attribute: options"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      value->workDoneToken = anyToProgressToken(*iter->second);
    }

    return value;
  }

  auto LspTransformer::documentRangesFormattingParamsToAny(
    const DocumentRangesFormattingParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("textDocument", textDocumentIdentifierToAny(*structure.textDocument));
    {
      LSPArray array;
      for (const std::unique_ptr<Range> &elem : structure.ranges) {
        array.push_back(rangeToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("ranges", std::move(any));
    }
    object.emplace("options", formattingOptionsToAny(*structure.options));
    if (structure.workDoneToken.has_value()) {
      object.emplace("workDoneToken", progressTokenToAny(structure.workDoneToken.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToDocumentOnTypeFormattingParams(
    const LSPAny &any
  ) const -> std::unique_ptr<DocumentOnTypeFormattingParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) DocumentOnTypeFormattingParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<DocumentOnTypeFormattingParams> value =
      std::make_unique<DocumentOnTypeFormattingParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 4) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) DocumentOnTypeFormattingParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("textDocument");
    if (iter != object.end()) {
      value->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DocumentOnTypeFormattingParams attribute: textDocument"
      );
    }

    iter = object.find("position");
    if (iter != object.end()) {
      value->position = anyToPosition(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DocumentOnTypeFormattingParams attribute: position"
      );
    }

    iter = object.find("ch");
    if (iter != object.end()) {
      value->ch = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DocumentOnTypeFormattingParams attribute: ch"
      );
    }

    iter = object.find("options");
    if (iter != object.end()) {
      value->options = anyToFormattingOptions(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DocumentOnTypeFormattingParams attribute: options"
      );
    }

    return value;
  }

  auto LspTransformer::documentOnTypeFormattingParamsToAny(
    const DocumentOnTypeFormattingParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("textDocument", textDocumentIdentifierToAny(*structure.textDocument));
    object.emplace("position", positionToAny(*structure.position));
    object.emplace("ch", stringToAny(structure.ch));
    object.emplace("options", formattingOptionsToAny(*structure.options));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToDocumentOnTypeFormattingRegistrationOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<DocumentOnTypeFormattingRegistrationOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) DocumentOnTypeFormattingRegistrationOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<DocumentOnTypeFormattingRegistrationOptions> value =
      std::make_unique<DocumentOnTypeFormattingRegistrationOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) DocumentOnTypeFormattingRegistrationOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("documentSelector");
    if (iter != object.end()) {
      value->documentSelector = anyToTextDocumentRegistrationOptions_documentSelector(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DocumentOnTypeFormattingRegistrationOptions attribute: documentSelector"
      );
    }

    iter = object.find("firstTriggerCharacter");
    if (iter != object.end()) {
      value->firstTriggerCharacter = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DocumentOnTypeFormattingRegistrationOptions attribute: firstTriggerCharacter"
      );
    }

    iter = object.find("moreTriggerCharacter");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<string_t> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToString(*elem));
      }
      value->moreTriggerCharacter = std::move(values);
    }

    return value;
  }

  auto LspTransformer::documentOnTypeFormattingRegistrationOptionsToAny(
    const DocumentOnTypeFormattingRegistrationOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("documentSelector", textDocumentRegistrationOptions_documentSelectorToAny(structure.documentSelector));
    object.emplace("firstTriggerCharacter", stringToAny(structure.firstTriggerCharacter));
    if (structure.moreTriggerCharacter.has_value()) {
      LSPArray array;
      for (const string_t &elem : structure.moreTriggerCharacter.value()) {
        array.push_back(stringToAny(elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("moreTriggerCharacter", std::move(any));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToRenameParams(
    const LSPAny &any
  ) const -> std::unique_ptr<RenameParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) RenameParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<RenameParams> value =
      std::make_unique<RenameParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 4) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) RenameParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("textDocument");
    if (iter != object.end()) {
      value->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required RenameParams attribute: textDocument"
      );
    }

    iter = object.find("position");
    if (iter != object.end()) {
      value->position = anyToPosition(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required RenameParams attribute: position"
      );
    }

    iter = object.find("newName");
    if (iter != object.end()) {
      value->newName = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required RenameParams attribute: newName"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      value->workDoneToken = anyToProgressToken(*iter->second);
    }

    return value;
  }

  auto LspTransformer::renameParamsToAny(
    const RenameParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("textDocument", textDocumentIdentifierToAny(*structure.textDocument));
    object.emplace("position", positionToAny(*structure.position));
    object.emplace("newName", stringToAny(structure.newName));
    if (structure.workDoneToken.has_value()) {
      object.emplace("workDoneToken", progressTokenToAny(structure.workDoneToken.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToRenameRegistrationOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<RenameRegistrationOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) RenameRegistrationOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<RenameRegistrationOptions> value =
      std::make_unique<RenameRegistrationOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) RenameRegistrationOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("documentSelector");
    if (iter != object.end()) {
      value->documentSelector = anyToTextDocumentRegistrationOptions_documentSelector(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required RenameRegistrationOptions attribute: documentSelector"
      );
    }

    iter = object.find("prepareProvider");
    if (iter != object.end()) {
      value->prepareProvider = anyToBoolean(*iter->second);
    }

    iter = object.find("workDoneProgress");
    if (iter != object.end()) {
      value->workDoneProgress = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::renameRegistrationOptionsToAny(
    const RenameRegistrationOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("documentSelector", textDocumentRegistrationOptions_documentSelectorToAny(structure.documentSelector));
    if (structure.prepareProvider.has_value()) {
      object.emplace("prepareProvider", booleanToAny(structure.prepareProvider.value()));
    }
    if (structure.workDoneProgress.has_value()) {
      object.emplace("workDoneProgress", booleanToAny(structure.workDoneProgress.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToPrepareRenameParams(
    const LSPAny &any
  ) const -> std::unique_ptr<PrepareRenameParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) PrepareRenameParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<PrepareRenameParams> value =
      std::make_unique<PrepareRenameParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) PrepareRenameParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("textDocument");
    if (iter != object.end()) {
      value->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required PrepareRenameParams attribute: textDocument"
      );
    }

    iter = object.find("position");
    if (iter != object.end()) {
      value->position = anyToPosition(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required PrepareRenameParams attribute: position"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      value->workDoneToken = anyToProgressToken(*iter->second);
    }

    return value;
  }

  auto LspTransformer::prepareRenameParamsToAny(
    const PrepareRenameParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("textDocument", textDocumentIdentifierToAny(*structure.textDocument));
    object.emplace("position", positionToAny(*structure.position));
    if (structure.workDoneToken.has_value()) {
      object.emplace("workDoneToken", progressTokenToAny(structure.workDoneToken.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToExecuteCommandParams(
    const LSPAny &any
  ) const -> std::unique_ptr<ExecuteCommandParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) ExecuteCommandParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<ExecuteCommandParams> value =
      std::make_unique<ExecuteCommandParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) ExecuteCommandParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("command");
    if (iter != object.end()) {
      value->command = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required ExecuteCommandParams attribute: command"
      );
    }

    iter = object.find("arguments");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<std::unique_ptr<LSPAny>> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(copy(elem));
      }
      value->arguments = std::move(values);
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      value->workDoneToken = anyToProgressToken(*iter->second);
    }

    return value;
  }

  auto LspTransformer::executeCommandParamsToAny(
    const ExecuteCommandParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("command", stringToAny(structure.command));
    if (structure.arguments.has_value()) {
      LSPArray array;
      for (const std::unique_ptr<LSPAny> &elem : structure.arguments.value()) {
        array.push_back(copy(elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("arguments", std::move(any));
    }
    if (structure.workDoneToken.has_value()) {
      object.emplace("workDoneToken", progressTokenToAny(structure.workDoneToken.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToExecuteCommandRegistrationOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<ExecuteCommandRegistrationOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) ExecuteCommandRegistrationOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<ExecuteCommandRegistrationOptions> value =
      std::make_unique<ExecuteCommandRegistrationOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) ExecuteCommandRegistrationOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("commands");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<string_t> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToString(*elem));
      }
      value->commands = std::move(values);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required ExecuteCommandRegistrationOptions attribute: commands"
      );
    }

    iter = object.find("workDoneProgress");
    if (iter != object.end()) {
      value->workDoneProgress = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::executeCommandRegistrationOptionsToAny(
    const ExecuteCommandRegistrationOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    {
      LSPArray array;
      for (const string_t &elem : structure.commands) {
        array.push_back(stringToAny(elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("commands", std::move(any));
    }
    if (structure.workDoneProgress.has_value()) {
      object.emplace("workDoneProgress", booleanToAny(structure.workDoneProgress.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToApplyWorkspaceEditParams(
    const LSPAny &any
  ) const -> std::unique_ptr<ApplyWorkspaceEditParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) ApplyWorkspaceEditParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<ApplyWorkspaceEditParams> value =
      std::make_unique<ApplyWorkspaceEditParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) ApplyWorkspaceEditParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("label");
    if (iter != object.end()) {
      value->label = anyToString(*iter->second);
    }

    iter = object.find("edit");
    if (iter != object.end()) {
      value->edit = anyToWorkspaceEdit(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required ApplyWorkspaceEditParams attribute: edit"
      );
    }

    return value;
  }

  auto LspTransformer::applyWorkspaceEditParamsToAny(
    const ApplyWorkspaceEditParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.label.has_value()) {
      object.emplace("label", stringToAny(structure.label.value()));
    }
    object.emplace("edit", workspaceEditToAny(*structure.edit));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToApplyWorkspaceEditResult(
    const LSPAny &any
  ) const -> std::unique_ptr<ApplyWorkspaceEditResult> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) ApplyWorkspaceEditResult must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<ApplyWorkspaceEditResult> value =
      std::make_unique<ApplyWorkspaceEditResult>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) ApplyWorkspaceEditResult: " + std::to_string(object.size())
      );
    }

    iter = object.find("applied");
    if (iter != object.end()) {
      value->applied = anyToBoolean(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required ApplyWorkspaceEditResult attribute: applied"
      );
    }

    iter = object.find("failureReason");
    if (iter != object.end()) {
      value->failureReason = anyToString(*iter->second);
    }

    iter = object.find("failedChange");
    if (iter != object.end()) {
      value->failedChange = anyToUInteger(*iter->second);
    }

    return value;
  }

  auto LspTransformer::applyWorkspaceEditResultToAny(
    const ApplyWorkspaceEditResult &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("applied", booleanToAny(structure.applied));
    if (structure.failureReason.has_value()) {
      object.emplace("failureReason", stringToAny(structure.failureReason.value()));
    }
    if (structure.failedChange.has_value()) {
      object.emplace("failedChange", uintegerToAny(structure.failedChange.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToWorkDoneProgressBegin(
    const LSPAny &any
  ) const -> std::unique_ptr<WorkDoneProgressBegin> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) WorkDoneProgressBegin must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<WorkDoneProgressBegin> value =
      std::make_unique<WorkDoneProgressBegin>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 5) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) WorkDoneProgressBegin: " + std::to_string(object.size())
      );
    }

    iter = object.find("kind");
    if (iter != object.end()) {
      const string_t &stringValue = anyToString(*iter->second);
      if (stringValue != "begin") {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          "String value for WorkDoneProgressBegin.kind must be \"begin\" but was: \"" + stringValue + "\""
        );
      }
      value->kind = stringValue;
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required WorkDoneProgressBegin attribute: kind"
      );
    }

    iter = object.find("title");
    if (iter != object.end()) {
      value->title = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required WorkDoneProgressBegin attribute: title"
      );
    }

    iter = object.find("cancellable");
    if (iter != object.end()) {
      value->cancellable = anyToBoolean(*iter->second);
    }

    iter = object.find("message");
    if (iter != object.end()) {
      value->message = anyToString(*iter->second);
    }

    iter = object.find("percentage");
    if (iter != object.end()) {
      value->percentage = anyToUInteger(*iter->second);
    }

    return value;
  }

  auto LspTransformer::workDoneProgressBeginToAny(
    const WorkDoneProgressBegin &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("kind", stringToAny(structure.kind));
    object.emplace("title", stringToAny(structure.title));
    if (structure.cancellable.has_value()) {
      object.emplace("cancellable", booleanToAny(structure.cancellable.value()));
    }
    if (structure.message.has_value()) {
      object.emplace("message", stringToAny(structure.message.value()));
    }
    if (structure.percentage.has_value()) {
      object.emplace("percentage", uintegerToAny(structure.percentage.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToWorkDoneProgressReport(
    const LSPAny &any
  ) const -> std::unique_ptr<WorkDoneProgressReport> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) WorkDoneProgressReport must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<WorkDoneProgressReport> value =
      std::make_unique<WorkDoneProgressReport>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 4) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) WorkDoneProgressReport: " + std::to_string(object.size())
      );
    }

    iter = object.find("kind");
    if (iter != object.end()) {
      const string_t &stringValue = anyToString(*iter->second);
      if (stringValue != "report") {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          "String value for WorkDoneProgressReport.kind must be \"report\" but was: \"" + stringValue + "\""
        );
      }
      value->kind = stringValue;
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required WorkDoneProgressReport attribute: kind"
      );
    }

    iter = object.find("cancellable");
    if (iter != object.end()) {
      value->cancellable = anyToBoolean(*iter->second);
    }

    iter = object.find("message");
    if (iter != object.end()) {
      value->message = anyToString(*iter->second);
    }

    iter = object.find("percentage");
    if (iter != object.end()) {
      value->percentage = anyToUInteger(*iter->second);
    }

    return value;
  }

  auto LspTransformer::workDoneProgressReportToAny(
    const WorkDoneProgressReport &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("kind", stringToAny(structure.kind));
    if (structure.cancellable.has_value()) {
      object.emplace("cancellable", booleanToAny(structure.cancellable.value()));
    }
    if (structure.message.has_value()) {
      object.emplace("message", stringToAny(structure.message.value()));
    }
    if (structure.percentage.has_value()) {
      object.emplace("percentage", uintegerToAny(structure.percentage.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToWorkDoneProgressEnd(
    const LSPAny &any
  ) const -> std::unique_ptr<WorkDoneProgressEnd> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) WorkDoneProgressEnd must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<WorkDoneProgressEnd> value =
      std::make_unique<WorkDoneProgressEnd>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) WorkDoneProgressEnd: " + std::to_string(object.size())
      );
    }

    iter = object.find("kind");
    if (iter != object.end()) {
      const string_t &stringValue = anyToString(*iter->second);
      if (stringValue != "end") {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          "String value for WorkDoneProgressEnd.kind must be \"end\" but was: \"" + stringValue + "\""
        );
      }
      value->kind = stringValue;
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required WorkDoneProgressEnd attribute: kind"
      );
    }

    iter = object.find("message");
    if (iter != object.end()) {
      value->message = anyToString(*iter->second);
    }

    return value;
  }

  auto LspTransformer::workDoneProgressEndToAny(
    const WorkDoneProgressEnd &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("kind", stringToAny(structure.kind));
    if (structure.message.has_value()) {
      object.emplace("message", stringToAny(structure.message.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToSetTraceParams(
    const LSPAny &any
  ) const -> std::unique_ptr<SetTraceParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) SetTraceParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<SetTraceParams> value =
      std::make_unique<SetTraceParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) SetTraceParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("value");
    if (iter != object.end()) {
      value->value = anyToTraceValues(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required SetTraceParams attribute: value"
      );
    }

    return value;
  }

  auto LspTransformer::setTraceParamsToAny(
    const SetTraceParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("value", traceValuesToAny(structure.value));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToLogTraceParams(
    const LSPAny &any
  ) const -> std::unique_ptr<LogTraceParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) LogTraceParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<LogTraceParams> value =
      std::make_unique<LogTraceParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) LogTraceParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("message");
    if (iter != object.end()) {
      value->message = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required LogTraceParams attribute: message"
      );
    }

    iter = object.find("verbose");
    if (iter != object.end()) {
      value->verbose = anyToString(*iter->second);
    }

    return value;
  }

  auto LspTransformer::logTraceParamsToAny(
    const LogTraceParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("message", stringToAny(structure.message));
    if (structure.verbose.has_value()) {
      object.emplace("verbose", stringToAny(structure.verbose.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToCancelParams_id(
    const LSPAny &any
  ) const -> CancelParams_id {
    CancelParams_id value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::STRING_TYPE: {
      value = anyToString(any);
      break;
    }
    case LSPAnyType::INTEGER_TYPE: {
      value = anyToInteger(any);
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) CancelParams_id: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::cancelParams_idToAny(
    const CancelParams_id &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<CancelParams_idType>(variant.index())) {
    case CancelParams_idType::INTEGER_TYPE: {
      return integerToAny(
        std::get<integer_t>(variant)
      );
    }
    case CancelParams_idType::STRING_TYPE: {
      return stringToAny(
        std::get<string_t>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported CancelParams_idType: " +
         CancelParams_idTypeNames.at(static_cast<CancelParams_idType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToCancelParams(
    const LSPAny &any
  ) const -> std::unique_ptr<CancelParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) CancelParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<CancelParams> value =
      std::make_unique<CancelParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) CancelParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("id");
    if (iter != object.end()) {
      value->id = anyToCancelParams_id(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required CancelParams attribute: id"
      );
    }

    return value;
  }

  auto LspTransformer::cancelParamsToAny(
    const CancelParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("id", cancelParams_idToAny(structure.id));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToProgressParams(
    const LSPAny &any
  ) const -> std::unique_ptr<ProgressParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) ProgressParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<ProgressParams> value =
      std::make_unique<ProgressParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) ProgressParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("token");
    if (iter != object.end()) {
      value->token = anyToProgressToken(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required ProgressParams attribute: token"
      );
    }

    iter = object.find("value");
    if (iter != object.end()) {
      value->value = copy(iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required ProgressParams attribute: value"
      );
    }

    return value;
  }

  auto LspTransformer::progressParamsToAny(
    const ProgressParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("token", progressTokenToAny(structure.token));
    object.emplace("value", copy(structure.value));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToTextDocumentPositionParams(
    const LSPAny &any
  ) const -> std::unique_ptr<TextDocumentPositionParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) TextDocumentPositionParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<TextDocumentPositionParams> value =
      std::make_unique<TextDocumentPositionParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) TextDocumentPositionParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("textDocument");
    if (iter != object.end()) {
      value->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required TextDocumentPositionParams attribute: textDocument"
      );
    }

    iter = object.find("position");
    if (iter != object.end()) {
      value->position = anyToPosition(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required TextDocumentPositionParams attribute: position"
      );
    }

    return value;
  }

  auto LspTransformer::textDocumentPositionParamsToAny(
    const TextDocumentPositionParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("textDocument", textDocumentIdentifierToAny(*structure.textDocument));
    object.emplace("position", positionToAny(*structure.position));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToWorkDoneProgressParams(
    const LSPAny &any
  ) const -> std::unique_ptr<WorkDoneProgressParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) WorkDoneProgressParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<WorkDoneProgressParams> value =
      std::make_unique<WorkDoneProgressParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) WorkDoneProgressParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      value->workDoneToken = anyToProgressToken(*iter->second);
    }

    return value;
  }

  auto LspTransformer::workDoneProgressParamsToAny(
    const WorkDoneProgressParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.workDoneToken.has_value()) {
      object.emplace("workDoneToken", progressTokenToAny(structure.workDoneToken.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToPartialResultParams(
    const LSPAny &any
  ) const -> std::unique_ptr<PartialResultParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) PartialResultParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<PartialResultParams> value =
      std::make_unique<PartialResultParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) PartialResultParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("partialResultToken");
    if (iter != object.end()) {
      value->partialResultToken = anyToProgressToken(*iter->second);
    }

    return value;
  }

  auto LspTransformer::partialResultParamsToAny(
    const PartialResultParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.partialResultToken.has_value()) {
      object.emplace("partialResultToken", progressTokenToAny(structure.partialResultToken.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToLocationLink(
    const LSPAny &any
  ) const -> std::unique_ptr<LocationLink> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) LocationLink must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<LocationLink> value =
      std::make_unique<LocationLink>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 4) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) LocationLink: " + std::to_string(object.size())
      );
    }

    iter = object.find("originSelectionRange");
    if (iter != object.end()) {
      value->originSelectionRange = anyToRange(*iter->second);
    }

    iter = object.find("targetUri");
    if (iter != object.end()) {
      value->targetUri = anyToDocumentUri(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required LocationLink attribute: targetUri"
      );
    }

    iter = object.find("targetRange");
    if (iter != object.end()) {
      value->targetRange = anyToRange(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required LocationLink attribute: targetRange"
      );
    }

    iter = object.find("targetSelectionRange");
    if (iter != object.end()) {
      value->targetSelectionRange = anyToRange(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required LocationLink attribute: targetSelectionRange"
      );
    }

    return value;
  }

  auto LspTransformer::locationLinkToAny(
    const LocationLink &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.originSelectionRange.has_value()) {
      object.emplace("originSelectionRange", rangeToAny(*structure.originSelectionRange.value()));
    }
    object.emplace("targetUri", documentUriToAny(structure.targetUri));
    object.emplace("targetRange", rangeToAny(*structure.targetRange));
    object.emplace("targetSelectionRange", rangeToAny(*structure.targetSelectionRange));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToRange(
    const LSPAny &any
  ) const -> std::unique_ptr<Range> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) Range must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<Range> value =
      std::make_unique<Range>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) Range: " + std::to_string(object.size())
      );
    }

    iter = object.find("start");
    if (iter != object.end()) {
      value->start = anyToPosition(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required Range attribute: start"
      );
    }

    iter = object.find("end");
    if (iter != object.end()) {
      value->end = anyToPosition(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required Range attribute: end"
      );
    }

    return value;
  }

  auto LspTransformer::rangeToAny(
    const Range &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("start", positionToAny(*structure.start));
    object.emplace("end", positionToAny(*structure.end));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToImplementationOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<ImplementationOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) ImplementationOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<ImplementationOptions> value =
      std::make_unique<ImplementationOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) ImplementationOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("workDoneProgress");
    if (iter != object.end()) {
      value->workDoneProgress = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::implementationOptionsToAny(
    const ImplementationOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.workDoneProgress.has_value()) {
      object.emplace("workDoneProgress", booleanToAny(structure.workDoneProgress.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToStaticRegistrationOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<StaticRegistrationOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) StaticRegistrationOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<StaticRegistrationOptions> value =
      std::make_unique<StaticRegistrationOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) StaticRegistrationOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("id");
    if (iter != object.end()) {
      value->id = anyToString(*iter->second);
    }

    return value;
  }

  auto LspTransformer::staticRegistrationOptionsToAny(
    const StaticRegistrationOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.id.has_value()) {
      object.emplace("id", stringToAny(structure.id.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToTypeDefinitionOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<TypeDefinitionOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) TypeDefinitionOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<TypeDefinitionOptions> value =
      std::make_unique<TypeDefinitionOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) TypeDefinitionOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("workDoneProgress");
    if (iter != object.end()) {
      value->workDoneProgress = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::typeDefinitionOptionsToAny(
    const TypeDefinitionOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.workDoneProgress.has_value()) {
      object.emplace("workDoneProgress", booleanToAny(structure.workDoneProgress.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToWorkspaceFoldersChangeEvent(
    const LSPAny &any
  ) const -> std::unique_ptr<WorkspaceFoldersChangeEvent> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) WorkspaceFoldersChangeEvent must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<WorkspaceFoldersChangeEvent> value =
      std::make_unique<WorkspaceFoldersChangeEvent>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) WorkspaceFoldersChangeEvent: " + std::to_string(object.size())
      );
    }

    iter = object.find("added");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<std::unique_ptr<WorkspaceFolder>> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToWorkspaceFolder(*elem));
      }
      value->added = std::move(values);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required WorkspaceFoldersChangeEvent attribute: added"
      );
    }

    iter = object.find("removed");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<std::unique_ptr<WorkspaceFolder>> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToWorkspaceFolder(*elem));
      }
      value->removed = std::move(values);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required WorkspaceFoldersChangeEvent attribute: removed"
      );
    }

    return value;
  }

  auto LspTransformer::workspaceFoldersChangeEventToAny(
    const WorkspaceFoldersChangeEvent &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    {
      LSPArray array;
      for (const std::unique_ptr<WorkspaceFolder> &elem : structure.added) {
        array.push_back(workspaceFolderToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("added", std::move(any));
    }
    {
      LSPArray array;
      for (const std::unique_ptr<WorkspaceFolder> &elem : structure.removed) {
        array.push_back(workspaceFolderToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("removed", std::move(any));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToConfigurationItem(
    const LSPAny &any
  ) const -> std::unique_ptr<ConfigurationItem> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) ConfigurationItem must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<ConfigurationItem> value =
      std::make_unique<ConfigurationItem>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) ConfigurationItem: " + std::to_string(object.size())
      );
    }

    iter = object.find("scopeUri");
    if (iter != object.end()) {
      value->scopeUri = anyToURI(*iter->second);
    }

    iter = object.find("section");
    if (iter != object.end()) {
      value->section = anyToString(*iter->second);
    }

    return value;
  }

  auto LspTransformer::configurationItemToAny(
    const ConfigurationItem &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.scopeUri.has_value()) {
      object.emplace("scopeUri", uriToAny(structure.scopeUri.value()));
    }
    if (structure.section.has_value()) {
      object.emplace("section", stringToAny(structure.section.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToTextDocumentIdentifier(
    const LSPAny &any
  ) const -> std::unique_ptr<TextDocumentIdentifier> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) TextDocumentIdentifier must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<TextDocumentIdentifier> value =
      std::make_unique<TextDocumentIdentifier>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) TextDocumentIdentifier: " + std::to_string(object.size())
      );
    }

    iter = object.find("uri");
    if (iter != object.end()) {
      value->uri = anyToDocumentUri(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required TextDocumentIdentifier attribute: uri"
      );
    }

    return value;
  }

  auto LspTransformer::textDocumentIdentifierToAny(
    const TextDocumentIdentifier &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("uri", documentUriToAny(structure.uri));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToColor(
    const LSPAny &any
  ) const -> std::unique_ptr<Color> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) Color must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<Color> value =
      std::make_unique<Color>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 4) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) Color: " + std::to_string(object.size())
      );
    }

    iter = object.find("red");
    if (iter != object.end()) {
      value->red = anyToDecimal(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required Color attribute: red"
      );
    }

    iter = object.find("green");
    if (iter != object.end()) {
      value->green = anyToDecimal(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required Color attribute: green"
      );
    }

    iter = object.find("blue");
    if (iter != object.end()) {
      value->blue = anyToDecimal(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required Color attribute: blue"
      );
    }

    iter = object.find("alpha");
    if (iter != object.end()) {
      value->alpha = anyToDecimal(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required Color attribute: alpha"
      );
    }

    return value;
  }

  auto LspTransformer::colorToAny(
    const Color &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("red", decimalToAny(structure.red));
    object.emplace("green", decimalToAny(structure.green));
    object.emplace("blue", decimalToAny(structure.blue));
    object.emplace("alpha", decimalToAny(structure.alpha));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToDocumentColorOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<DocumentColorOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) DocumentColorOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<DocumentColorOptions> value =
      std::make_unique<DocumentColorOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) DocumentColorOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("workDoneProgress");
    if (iter != object.end()) {
      value->workDoneProgress = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::documentColorOptionsToAny(
    const DocumentColorOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.workDoneProgress.has_value()) {
      object.emplace("workDoneProgress", booleanToAny(structure.workDoneProgress.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToFoldingRangeOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<FoldingRangeOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) FoldingRangeOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<FoldingRangeOptions> value =
      std::make_unique<FoldingRangeOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) FoldingRangeOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("workDoneProgress");
    if (iter != object.end()) {
      value->workDoneProgress = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::foldingRangeOptionsToAny(
    const FoldingRangeOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.workDoneProgress.has_value()) {
      object.emplace("workDoneProgress", booleanToAny(structure.workDoneProgress.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToDeclarationOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<DeclarationOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) DeclarationOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<DeclarationOptions> value =
      std::make_unique<DeclarationOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) DeclarationOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("workDoneProgress");
    if (iter != object.end()) {
      value->workDoneProgress = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::declarationOptionsToAny(
    const DeclarationOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.workDoneProgress.has_value()) {
      object.emplace("workDoneProgress", booleanToAny(structure.workDoneProgress.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToPosition(
    const LSPAny &any
  ) const -> std::unique_ptr<Position> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) Position must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<Position> value =
      std::make_unique<Position>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) Position: " + std::to_string(object.size())
      );
    }

    iter = object.find("line");
    if (iter != object.end()) {
      value->line = anyToUInteger(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required Position attribute: line"
      );
    }

    iter = object.find("character");
    if (iter != object.end()) {
      value->character = anyToUInteger(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required Position attribute: character"
      );
    }

    return value;
  }

  auto LspTransformer::positionToAny(
    const Position &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("line", uintegerToAny(structure.line));
    object.emplace("character", uintegerToAny(structure.character));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToSelectionRangeOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<SelectionRangeOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) SelectionRangeOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<SelectionRangeOptions> value =
      std::make_unique<SelectionRangeOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) SelectionRangeOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("workDoneProgress");
    if (iter != object.end()) {
      value->workDoneProgress = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::selectionRangeOptionsToAny(
    const SelectionRangeOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.workDoneProgress.has_value()) {
      object.emplace("workDoneProgress", booleanToAny(structure.workDoneProgress.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToCallHierarchyOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<CallHierarchyOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) CallHierarchyOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<CallHierarchyOptions> value =
      std::make_unique<CallHierarchyOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) CallHierarchyOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("workDoneProgress");
    if (iter != object.end()) {
      value->workDoneProgress = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::callHierarchyOptionsToAny(
    const CallHierarchyOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.workDoneProgress.has_value()) {
      object.emplace("workDoneProgress", booleanToAny(structure.workDoneProgress.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToSemanticTokensOptions_range_1(
    const LSPAny &any
  ) const -> std::unique_ptr<SemanticTokensOptions_range_1> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) SemanticTokensOptions_range_1 must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<SemanticTokensOptions_range_1> value =
      std::make_unique<SemanticTokensOptions_range_1>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 0) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) SemanticTokensOptions_range_1: " + std::to_string(object.size())
      );
    }

    return value;
  }

  auto LspTransformer::semanticTokensOptions_range_1ToAny(
    const SemanticTokensOptions_range_1 &/*structure*/
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    // empty

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToSemanticTokensOptions_range(
    const LSPAny &any
  ) const -> SemanticTokensOptions_range {
    SemanticTokensOptions_range value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::OBJECT_TYPE: {
      try {
        value = anyToSemanticTokensOptions_range_1(any);
      } catch (LspException &e) {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          "Failed to transform LSPAny to SemanticTokensOptions_range"
        );
      }
      break;
    }
    case LSPAnyType::BOOLEAN_TYPE: {
      value = anyToBoolean(any);
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) SemanticTokensOptions_range: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::semanticTokensOptions_rangeToAny(
    const SemanticTokensOptions_range &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<SemanticTokensOptions_rangeType>(variant.index())) {
    case SemanticTokensOptions_rangeType::BOOLEAN_TYPE: {
      return booleanToAny(
        std::get<boolean_t>(variant)
      );
    }
    case SemanticTokensOptions_rangeType::SEMANTIC_TOKENS_OPTIONS_RANGE_1: {
      return semanticTokensOptions_range_1ToAny(
        *std::get<std::unique_ptr<SemanticTokensOptions_range_1>>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported SemanticTokensOptions_rangeType: " +
         SemanticTokensOptions_rangeTypeNames.at(static_cast<SemanticTokensOptions_rangeType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToSemanticTokensOptions_full_1(
    const LSPAny &any
  ) const -> std::unique_ptr<SemanticTokensOptions_full_1> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) SemanticTokensOptions_full_1 must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<SemanticTokensOptions_full_1> value =
      std::make_unique<SemanticTokensOptions_full_1>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) SemanticTokensOptions_full_1: " + std::to_string(object.size())
      );
    }

    iter = object.find("delta");
    if (iter != object.end()) {
      value->delta = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::semanticTokensOptions_full_1ToAny(
    const SemanticTokensOptions_full_1 &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.delta.has_value()) {
      object.emplace("delta", booleanToAny(structure.delta.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToSemanticTokensOptions_full(
    const LSPAny &any
  ) const -> SemanticTokensOptions_full {
    SemanticTokensOptions_full value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::OBJECT_TYPE: {
      try {
        value = anyToSemanticTokensOptions_full_1(any);
      } catch (LspException &e) {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          "Failed to transform LSPAny to SemanticTokensOptions_full"
        );
      }
      break;
    }
    case LSPAnyType::BOOLEAN_TYPE: {
      value = anyToBoolean(any);
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) SemanticTokensOptions_full: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::semanticTokensOptions_fullToAny(
    const SemanticTokensOptions_full &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<SemanticTokensOptions_fullType>(variant.index())) {
    case SemanticTokensOptions_fullType::BOOLEAN_TYPE: {
      return booleanToAny(
        std::get<boolean_t>(variant)
      );
    }
    case SemanticTokensOptions_fullType::SEMANTIC_TOKENS_OPTIONS_FULL_1: {
      return semanticTokensOptions_full_1ToAny(
        *std::get<std::unique_ptr<SemanticTokensOptions_full_1>>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported SemanticTokensOptions_fullType: " +
         SemanticTokensOptions_fullTypeNames.at(static_cast<SemanticTokensOptions_fullType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToSemanticTokensOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<SemanticTokensOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) SemanticTokensOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<SemanticTokensOptions> value =
      std::make_unique<SemanticTokensOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 4) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) SemanticTokensOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("legend");
    if (iter != object.end()) {
      value->legend = anyToSemanticTokensLegend(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required SemanticTokensOptions attribute: legend"
      );
    }

    iter = object.find("range");
    if (iter != object.end()) {
      value->range = anyToSemanticTokensOptions_range(*iter->second);
    }

    iter = object.find("full");
    if (iter != object.end()) {
      value->full = anyToSemanticTokensOptions_full(*iter->second);
    }

    iter = object.find("workDoneProgress");
    if (iter != object.end()) {
      value->workDoneProgress = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::semanticTokensOptionsToAny(
    const SemanticTokensOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("legend", semanticTokensLegendToAny(*structure.legend));
    if (structure.range.has_value()) {
      object.emplace("range", semanticTokensOptions_rangeToAny(structure.range.value()));
    }
    if (structure.full.has_value()) {
      object.emplace("full", semanticTokensOptions_fullToAny(structure.full.value()));
    }
    if (structure.workDoneProgress.has_value()) {
      object.emplace("workDoneProgress", booleanToAny(structure.workDoneProgress.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToSemanticTokensEdit(
    const LSPAny &any
  ) const -> std::unique_ptr<SemanticTokensEdit> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) SemanticTokensEdit must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<SemanticTokensEdit> value =
      std::make_unique<SemanticTokensEdit>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) SemanticTokensEdit: " + std::to_string(object.size())
      );
    }

    iter = object.find("start");
    if (iter != object.end()) {
      value->start = anyToUInteger(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required SemanticTokensEdit attribute: start"
      );
    }

    iter = object.find("deleteCount");
    if (iter != object.end()) {
      value->deleteCount = anyToUInteger(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required SemanticTokensEdit attribute: deleteCount"
      );
    }

    iter = object.find("data");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<uinteger_t> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToUInteger(*elem));
      }
      value->data = std::move(values);
    }

    return value;
  }

  auto LspTransformer::semanticTokensEditToAny(
    const SemanticTokensEdit &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("start", uintegerToAny(structure.start));
    object.emplace("deleteCount", uintegerToAny(structure.deleteCount));
    if (structure.data.has_value()) {
      LSPArray array;
      for (const uinteger_t &elem : structure.data.value()) {
        array.push_back(uintegerToAny(elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("data", std::move(any));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToLinkedEditingRangeOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<LinkedEditingRangeOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) LinkedEditingRangeOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<LinkedEditingRangeOptions> value =
      std::make_unique<LinkedEditingRangeOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) LinkedEditingRangeOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("workDoneProgress");
    if (iter != object.end()) {
      value->workDoneProgress = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::linkedEditingRangeOptionsToAny(
    const LinkedEditingRangeOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.workDoneProgress.has_value()) {
      object.emplace("workDoneProgress", booleanToAny(structure.workDoneProgress.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToFileCreate(
    const LSPAny &any
  ) const -> std::unique_ptr<FileCreate> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) FileCreate must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<FileCreate> value =
      std::make_unique<FileCreate>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) FileCreate: " + std::to_string(object.size())
      );
    }

    iter = object.find("uri");
    if (iter != object.end()) {
      value->uri = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required FileCreate attribute: uri"
      );
    }

    return value;
  }

  auto LspTransformer::fileCreateToAny(
    const FileCreate &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("uri", stringToAny(structure.uri));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToTextDocumentEdit_edits(
    const LSPAny &any
  ) const -> TextDocumentEdit_edits {
    TextDocumentEdit_edits value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::OBJECT_TYPE: {
      try {
        value = anyToTextEdit(any);
      } catch (LspException &e) {
        try {
          value = anyToAnnotatedTextEdit(any);
        } catch (LspException &e) {
          throw LSP_EXCEPTION(
            ErrorCodes::INVALID_PARAMS,
            "Failed to transform LSPAny to TextDocumentEdit_edits"
          );
        }
      }
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) TextDocumentEdit_edits: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::textDocumentEdit_editsToAny(
    const TextDocumentEdit_edits &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<TextDocumentEdit_editsType>(variant.index())) {
    case TextDocumentEdit_editsType::TEXT_EDIT: {
      return textEditToAny(
        *std::get<std::unique_ptr<TextEdit>>(variant)
      );
    }
    case TextDocumentEdit_editsType::ANNOTATED_TEXT_EDIT: {
      return annotatedTextEditToAny(
        *std::get<std::unique_ptr<AnnotatedTextEdit>>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported TextDocumentEdit_editsType: " +
         TextDocumentEdit_editsTypeNames.at(static_cast<TextDocumentEdit_editsType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToTextDocumentEdit(
    const LSPAny &any
  ) const -> std::unique_ptr<TextDocumentEdit> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) TextDocumentEdit must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<TextDocumentEdit> value =
      std::make_unique<TextDocumentEdit>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) TextDocumentEdit: " + std::to_string(object.size())
      );
    }

    iter = object.find("textDocument");
    if (iter != object.end()) {
      value->textDocument = anyToOptionalVersionedTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required TextDocumentEdit attribute: textDocument"
      );
    }

    iter = object.find("edits");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<TextDocumentEdit_edits> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToTextDocumentEdit_edits(*elem));
      }
      value->edits = std::move(values);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required TextDocumentEdit attribute: edits"
      );
    }

    return value;
  }

  auto LspTransformer::textDocumentEditToAny(
    const TextDocumentEdit &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("textDocument", optionalVersionedTextDocumentIdentifierToAny(*structure.textDocument));
    {
      LSPArray array;
      for (const TextDocumentEdit_edits &elem : structure.edits) {
        array.push_back(textDocumentEdit_editsToAny(elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("edits", std::move(any));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToCreateFile(
    const LSPAny &any
  ) const -> std::unique_ptr<CreateFile> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) CreateFile must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<CreateFile> value =
      std::make_unique<CreateFile>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 4) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) CreateFile: " + std::to_string(object.size())
      );
    }

    iter = object.find("kind");
    if (iter != object.end()) {
      const string_t &stringValue = anyToString(*iter->second);
      if (stringValue != "create") {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          "String value for CreateFile.kind must be \"create\" but was: \"" + stringValue + "\""
        );
      }
      value->kind = stringValue;
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required CreateFile attribute: kind"
      );
    }

    iter = object.find("uri");
    if (iter != object.end()) {
      value->uri = anyToDocumentUri(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required CreateFile attribute: uri"
      );
    }

    iter = object.find("options");
    if (iter != object.end()) {
      value->options = anyToCreateFileOptions(*iter->second);
    }

    iter = object.find("annotationId");
    if (iter != object.end()) {
      value->annotationId = anyToChangeAnnotationIdentifier(*iter->second);
    }

    return value;
  }

  auto LspTransformer::createFileToAny(
    const CreateFile &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("kind", stringToAny(structure.kind));
    object.emplace("uri", documentUriToAny(structure.uri));
    if (structure.options.has_value()) {
      object.emplace("options", createFileOptionsToAny(*structure.options.value()));
    }
    if (structure.annotationId.has_value()) {
      object.emplace("annotationId", changeAnnotationIdentifierToAny(structure.annotationId.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToRenameFile(
    const LSPAny &any
  ) const -> std::unique_ptr<RenameFile> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) RenameFile must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<RenameFile> value =
      std::make_unique<RenameFile>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 5) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) RenameFile: " + std::to_string(object.size())
      );
    }

    iter = object.find("kind");
    if (iter != object.end()) {
      const string_t &stringValue = anyToString(*iter->second);
      if (stringValue != "rename") {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          "String value for RenameFile.kind must be \"rename\" but was: \"" + stringValue + "\""
        );
      }
      value->kind = stringValue;
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required RenameFile attribute: kind"
      );
    }

    iter = object.find("oldUri");
    if (iter != object.end()) {
      value->oldUri = anyToDocumentUri(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required RenameFile attribute: oldUri"
      );
    }

    iter = object.find("newUri");
    if (iter != object.end()) {
      value->newUri = anyToDocumentUri(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required RenameFile attribute: newUri"
      );
    }

    iter = object.find("options");
    if (iter != object.end()) {
      value->options = anyToRenameFileOptions(*iter->second);
    }

    iter = object.find("annotationId");
    if (iter != object.end()) {
      value->annotationId = anyToChangeAnnotationIdentifier(*iter->second);
    }

    return value;
  }

  auto LspTransformer::renameFileToAny(
    const RenameFile &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("kind", stringToAny(structure.kind));
    object.emplace("oldUri", documentUriToAny(structure.oldUri));
    object.emplace("newUri", documentUriToAny(structure.newUri));
    if (structure.options.has_value()) {
      object.emplace("options", renameFileOptionsToAny(*structure.options.value()));
    }
    if (structure.annotationId.has_value()) {
      object.emplace("annotationId", changeAnnotationIdentifierToAny(structure.annotationId.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToDeleteFile(
    const LSPAny &any
  ) const -> std::unique_ptr<DeleteFile> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) DeleteFile must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<DeleteFile> value =
      std::make_unique<DeleteFile>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 4) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) DeleteFile: " + std::to_string(object.size())
      );
    }

    iter = object.find("kind");
    if (iter != object.end()) {
      const string_t &stringValue = anyToString(*iter->second);
      if (stringValue != "delete") {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          "String value for DeleteFile.kind must be \"delete\" but was: \"" + stringValue + "\""
        );
      }
      value->kind = stringValue;
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DeleteFile attribute: kind"
      );
    }

    iter = object.find("uri");
    if (iter != object.end()) {
      value->uri = anyToDocumentUri(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DeleteFile attribute: uri"
      );
    }

    iter = object.find("options");
    if (iter != object.end()) {
      value->options = anyToDeleteFileOptions(*iter->second);
    }

    iter = object.find("annotationId");
    if (iter != object.end()) {
      value->annotationId = anyToChangeAnnotationIdentifier(*iter->second);
    }

    return value;
  }

  auto LspTransformer::deleteFileToAny(
    const DeleteFile &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("kind", stringToAny(structure.kind));
    object.emplace("uri", documentUriToAny(structure.uri));
    if (structure.options.has_value()) {
      object.emplace("options", deleteFileOptionsToAny(*structure.options.value()));
    }
    if (structure.annotationId.has_value()) {
      object.emplace("annotationId", changeAnnotationIdentifierToAny(structure.annotationId.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToChangeAnnotation(
    const LSPAny &any
  ) const -> std::unique_ptr<ChangeAnnotation> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) ChangeAnnotation must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<ChangeAnnotation> value =
      std::make_unique<ChangeAnnotation>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) ChangeAnnotation: " + std::to_string(object.size())
      );
    }

    iter = object.find("label");
    if (iter != object.end()) {
      value->label = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required ChangeAnnotation attribute: label"
      );
    }

    iter = object.find("needsConfirmation");
    if (iter != object.end()) {
      value->needsConfirmation = anyToBoolean(*iter->second);
    }

    iter = object.find("description");
    if (iter != object.end()) {
      value->description = anyToString(*iter->second);
    }

    return value;
  }

  auto LspTransformer::changeAnnotationToAny(
    const ChangeAnnotation &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("label", stringToAny(structure.label));
    if (structure.needsConfirmation.has_value()) {
      object.emplace("needsConfirmation", booleanToAny(structure.needsConfirmation.value()));
    }
    if (structure.description.has_value()) {
      object.emplace("description", stringToAny(structure.description.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToFileOperationFilter(
    const LSPAny &any
  ) const -> std::unique_ptr<FileOperationFilter> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) FileOperationFilter must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<FileOperationFilter> value =
      std::make_unique<FileOperationFilter>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) FileOperationFilter: " + std::to_string(object.size())
      );
    }

    iter = object.find("scheme");
    if (iter != object.end()) {
      value->scheme = anyToString(*iter->second);
    }

    iter = object.find("pattern");
    if (iter != object.end()) {
      value->pattern = anyToFileOperationPattern(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required FileOperationFilter attribute: pattern"
      );
    }

    return value;
  }

  auto LspTransformer::fileOperationFilterToAny(
    const FileOperationFilter &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.scheme.has_value()) {
      object.emplace("scheme", stringToAny(structure.scheme.value()));
    }
    object.emplace("pattern", fileOperationPatternToAny(*structure.pattern));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToFileRename(
    const LSPAny &any
  ) const -> std::unique_ptr<FileRename> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) FileRename must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<FileRename> value =
      std::make_unique<FileRename>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) FileRename: " + std::to_string(object.size())
      );
    }

    iter = object.find("oldUri");
    if (iter != object.end()) {
      value->oldUri = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required FileRename attribute: oldUri"
      );
    }

    iter = object.find("newUri");
    if (iter != object.end()) {
      value->newUri = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required FileRename attribute: newUri"
      );
    }

    return value;
  }

  auto LspTransformer::fileRenameToAny(
    const FileRename &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("oldUri", stringToAny(structure.oldUri));
    object.emplace("newUri", stringToAny(structure.newUri));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToFileDelete(
    const LSPAny &any
  ) const -> std::unique_ptr<FileDelete> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) FileDelete must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<FileDelete> value =
      std::make_unique<FileDelete>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) FileDelete: " + std::to_string(object.size())
      );
    }

    iter = object.find("uri");
    if (iter != object.end()) {
      value->uri = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required FileDelete attribute: uri"
      );
    }

    return value;
  }

  auto LspTransformer::fileDeleteToAny(
    const FileDelete &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("uri", stringToAny(structure.uri));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToMonikerOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<MonikerOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) MonikerOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<MonikerOptions> value =
      std::make_unique<MonikerOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) MonikerOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("workDoneProgress");
    if (iter != object.end()) {
      value->workDoneProgress = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::monikerOptionsToAny(
    const MonikerOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.workDoneProgress.has_value()) {
      object.emplace("workDoneProgress", booleanToAny(structure.workDoneProgress.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToTypeHierarchyOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<TypeHierarchyOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) TypeHierarchyOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<TypeHierarchyOptions> value =
      std::make_unique<TypeHierarchyOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) TypeHierarchyOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("workDoneProgress");
    if (iter != object.end()) {
      value->workDoneProgress = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::typeHierarchyOptionsToAny(
    const TypeHierarchyOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.workDoneProgress.has_value()) {
      object.emplace("workDoneProgress", booleanToAny(structure.workDoneProgress.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToInlineValueContext(
    const LSPAny &any
  ) const -> std::unique_ptr<InlineValueContext> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) InlineValueContext must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<InlineValueContext> value =
      std::make_unique<InlineValueContext>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) InlineValueContext: " + std::to_string(object.size())
      );
    }

    iter = object.find("frameId");
    if (iter != object.end()) {
      value->frameId = anyToInteger(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required InlineValueContext attribute: frameId"
      );
    }

    iter = object.find("stoppedLocation");
    if (iter != object.end()) {
      value->stoppedLocation = anyToRange(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required InlineValueContext attribute: stoppedLocation"
      );
    }

    return value;
  }

  auto LspTransformer::inlineValueContextToAny(
    const InlineValueContext &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("frameId", integerToAny(structure.frameId));
    object.emplace("stoppedLocation", rangeToAny(*structure.stoppedLocation));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToInlineValueText(
    const LSPAny &any
  ) const -> std::unique_ptr<InlineValueText> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) InlineValueText must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<InlineValueText> value =
      std::make_unique<InlineValueText>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) InlineValueText: " + std::to_string(object.size())
      );
    }

    iter = object.find("range");
    if (iter != object.end()) {
      value->range = anyToRange(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required InlineValueText attribute: range"
      );
    }

    iter = object.find("text");
    if (iter != object.end()) {
      value->text = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required InlineValueText attribute: text"
      );
    }

    return value;
  }

  auto LspTransformer::inlineValueTextToAny(
    const InlineValueText &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("range", rangeToAny(*structure.range));
    object.emplace("text", stringToAny(structure.text));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToInlineValueVariableLookup(
    const LSPAny &any
  ) const -> std::unique_ptr<InlineValueVariableLookup> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) InlineValueVariableLookup must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<InlineValueVariableLookup> value =
      std::make_unique<InlineValueVariableLookup>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) InlineValueVariableLookup: " + std::to_string(object.size())
      );
    }

    iter = object.find("range");
    if (iter != object.end()) {
      value->range = anyToRange(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required InlineValueVariableLookup attribute: range"
      );
    }

    iter = object.find("variableName");
    if (iter != object.end()) {
      value->variableName = anyToString(*iter->second);
    }

    iter = object.find("caseSensitiveLookup");
    if (iter != object.end()) {
      value->caseSensitiveLookup = anyToBoolean(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required InlineValueVariableLookup attribute: caseSensitiveLookup"
      );
    }

    return value;
  }

  auto LspTransformer::inlineValueVariableLookupToAny(
    const InlineValueVariableLookup &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("range", rangeToAny(*structure.range));
    if (structure.variableName.has_value()) {
      object.emplace("variableName", stringToAny(structure.variableName.value()));
    }
    object.emplace("caseSensitiveLookup", booleanToAny(structure.caseSensitiveLookup));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToInlineValueEvaluatableExpression(
    const LSPAny &any
  ) const -> std::unique_ptr<InlineValueEvaluatableExpression> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) InlineValueEvaluatableExpression must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<InlineValueEvaluatableExpression> value =
      std::make_unique<InlineValueEvaluatableExpression>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) InlineValueEvaluatableExpression: " + std::to_string(object.size())
      );
    }

    iter = object.find("range");
    if (iter != object.end()) {
      value->range = anyToRange(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required InlineValueEvaluatableExpression attribute: range"
      );
    }

    iter = object.find("expression");
    if (iter != object.end()) {
      value->expression = anyToString(*iter->second);
    }

    return value;
  }

  auto LspTransformer::inlineValueEvaluatableExpressionToAny(
    const InlineValueEvaluatableExpression &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("range", rangeToAny(*structure.range));
    if (structure.expression.has_value()) {
      object.emplace("expression", stringToAny(structure.expression.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToInlineValueOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<InlineValueOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) InlineValueOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<InlineValueOptions> value =
      std::make_unique<InlineValueOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) InlineValueOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("workDoneProgress");
    if (iter != object.end()) {
      value->workDoneProgress = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::inlineValueOptionsToAny(
    const InlineValueOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.workDoneProgress.has_value()) {
      object.emplace("workDoneProgress", booleanToAny(structure.workDoneProgress.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToInlayHintLabelPart_tooltip(
    const LSPAny &any
  ) const -> InlayHintLabelPart_tooltip {
    InlayHintLabelPart_tooltip value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::OBJECT_TYPE: {
      try {
        value = anyToMarkupContent(any);
      } catch (LspException &e) {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          "Failed to transform LSPAny to InlayHintLabelPart_tooltip"
        );
      }
      break;
    }
    case LSPAnyType::STRING_TYPE: {
      value = anyToString(any);
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) InlayHintLabelPart_tooltip: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::inlayHintLabelPart_tooltipToAny(
    const InlayHintLabelPart_tooltip &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<InlayHintLabelPart_tooltipType>(variant.index())) {
    case InlayHintLabelPart_tooltipType::STRING_TYPE: {
      return stringToAny(
        std::get<string_t>(variant)
      );
    }
    case InlayHintLabelPart_tooltipType::MARKUP_CONTENT: {
      return markupContentToAny(
        *std::get<std::unique_ptr<MarkupContent>>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported InlayHintLabelPart_tooltipType: " +
         InlayHintLabelPart_tooltipTypeNames.at(static_cast<InlayHintLabelPart_tooltipType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToInlayHintLabelPart(
    const LSPAny &any
  ) const -> std::unique_ptr<InlayHintLabelPart> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) InlayHintLabelPart must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<InlayHintLabelPart> value =
      std::make_unique<InlayHintLabelPart>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 4) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) InlayHintLabelPart: " + std::to_string(object.size())
      );
    }

    iter = object.find("value");
    if (iter != object.end()) {
      value->value = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required InlayHintLabelPart attribute: value"
      );
    }

    iter = object.find("tooltip");
    if (iter != object.end()) {
      value->tooltip = anyToInlayHintLabelPart_tooltip(*iter->second);
    }

    iter = object.find("location");
    if (iter != object.end()) {
      value->location = anyToLocation(*iter->second);
    }

    iter = object.find("command");
    if (iter != object.end()) {
      value->command = anyToCommand(*iter->second);
    }

    return value;
  }

  auto LspTransformer::inlayHintLabelPartToAny(
    const InlayHintLabelPart &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("value", stringToAny(structure.value));
    if (structure.tooltip.has_value()) {
      object.emplace("tooltip", inlayHintLabelPart_tooltipToAny(structure.tooltip.value()));
    }
    if (structure.location.has_value()) {
      object.emplace("location", locationToAny(*structure.location.value()));
    }
    if (structure.command.has_value()) {
      object.emplace("command", commandToAny(*structure.command.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToMarkupContent(
    const LSPAny &any
  ) const -> std::unique_ptr<MarkupContent> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) MarkupContent must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<MarkupContent> value =
      std::make_unique<MarkupContent>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) MarkupContent: " + std::to_string(object.size())
      );
    }

    iter = object.find("kind");
    if (iter != object.end()) {
      value->kind = anyToMarkupKind(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required MarkupContent attribute: kind"
      );
    }

    iter = object.find("value");
    if (iter != object.end()) {
      value->value = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required MarkupContent attribute: value"
      );
    }

    return value;
  }

  auto LspTransformer::markupContentToAny(
    const MarkupContent &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("kind", markupKindToAny(structure.kind));
    object.emplace("value", stringToAny(structure.value));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToInlayHintOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<InlayHintOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) InlayHintOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<InlayHintOptions> value =
      std::make_unique<InlayHintOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) InlayHintOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("resolveProvider");
    if (iter != object.end()) {
      value->resolveProvider = anyToBoolean(*iter->second);
    }

    iter = object.find("workDoneProgress");
    if (iter != object.end()) {
      value->workDoneProgress = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::inlayHintOptionsToAny(
    const InlayHintOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.resolveProvider.has_value()) {
      object.emplace("resolveProvider", booleanToAny(structure.resolveProvider.value()));
    }
    if (structure.workDoneProgress.has_value()) {
      object.emplace("workDoneProgress", booleanToAny(structure.workDoneProgress.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToRelatedFullDocumentDiagnosticReport_relatedDocuments(
    const LSPAny &any
  ) const -> RelatedFullDocumentDiagnosticReport_relatedDocuments {
    RelatedFullDocumentDiagnosticReport_relatedDocuments value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::OBJECT_TYPE: {
      try {
        value = anyToFullDocumentDiagnosticReport(any);
      } catch (LspException &e) {
        try {
          value = anyToUnchangedDocumentDiagnosticReport(any);
        } catch (LspException &e) {
          throw LSP_EXCEPTION(
            ErrorCodes::INVALID_PARAMS,
            "Failed to transform LSPAny to RelatedFullDocumentDiagnosticReport_relatedDocuments"
          );
        }
      }
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) RelatedFullDocumentDiagnosticReport_relatedDocuments: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::relatedFullDocumentDiagnosticReport_relatedDocumentsToAny(
    const RelatedFullDocumentDiagnosticReport_relatedDocuments &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<RelatedFullDocumentDiagnosticReport_relatedDocumentsType>(variant.index())) {
    case RelatedFullDocumentDiagnosticReport_relatedDocumentsType::FULL_DOCUMENT_DIAGNOSTIC_REPORT: {
      return fullDocumentDiagnosticReportToAny(
        *std::get<std::unique_ptr<FullDocumentDiagnosticReport>>(variant)
      );
    }
    case RelatedFullDocumentDiagnosticReport_relatedDocumentsType::UNCHANGED_DOCUMENT_DIAGNOSTIC_REPORT: {
      return unchangedDocumentDiagnosticReportToAny(
        *std::get<std::unique_ptr<UnchangedDocumentDiagnosticReport>>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported RelatedFullDocumentDiagnosticReport_relatedDocumentsType: " +
         RelatedFullDocumentDiagnosticReport_relatedDocumentsTypeNames.at(static_cast<RelatedFullDocumentDiagnosticReport_relatedDocumentsType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToRelatedFullDocumentDiagnosticReport(
    const LSPAny &any
  ) const -> std::unique_ptr<RelatedFullDocumentDiagnosticReport> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) RelatedFullDocumentDiagnosticReport must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<RelatedFullDocumentDiagnosticReport> value =
      std::make_unique<RelatedFullDocumentDiagnosticReport>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 4) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) RelatedFullDocumentDiagnosticReport: " + std::to_string(object.size())
      );
    }

    iter = object.find("relatedDocuments");
    if (iter != object.end()) {
      const LSPObject &object_map = std::get<LSPObject>(*iter->second);
      std::map<DocumentUri, RelatedFullDocumentDiagnosticReport_relatedDocuments> map;
      for (const auto &[map_key, map_value] : object_map) {
        map.emplace(map_key, anyToRelatedFullDocumentDiagnosticReport_relatedDocuments(*map_value));
      }
      value->relatedDocuments = std::move(map);
    }

    iter = object.find("kind");
    if (iter != object.end()) {
      const string_t &stringValue = anyToString(*iter->second);
      if (stringValue != "full") {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          "String value for RelatedFullDocumentDiagnosticReport.kind must be \"full\" but was: \"" + stringValue + "\""
        );
      }
      value->kind = stringValue;
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required RelatedFullDocumentDiagnosticReport attribute: kind"
      );
    }

    iter = object.find("resultId");
    if (iter != object.end()) {
      value->resultId = anyToString(*iter->second);
    }

    iter = object.find("items");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<std::unique_ptr<Diagnostic>> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToDiagnostic(*elem));
      }
      value->items = std::move(values);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required RelatedFullDocumentDiagnosticReport attribute: items"
      );
    }

    return value;
  }

  auto LspTransformer::relatedFullDocumentDiagnosticReportToAny(
    const RelatedFullDocumentDiagnosticReport &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.relatedDocuments.has_value()) {
      LSPObject map;
      for (const auto &[mapKey, mapValue] : structure.relatedDocuments.value()) {
        map.emplace(mapKey, relatedFullDocumentDiagnosticReport_relatedDocumentsToAny(mapValue));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(map);
      object.emplace("relatedDocuments", std::move(any));
    }
    object.emplace("kind", stringToAny(structure.kind));
    if (structure.resultId.has_value()) {
      object.emplace("resultId", stringToAny(structure.resultId.value()));
    }
    {
      LSPArray array;
      for (const std::unique_ptr<Diagnostic> &elem : structure.items) {
        array.push_back(diagnosticToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("items", std::move(any));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToRelatedUnchangedDocumentDiagnosticReport_relatedDocuments(
    const LSPAny &any
  ) const -> RelatedUnchangedDocumentDiagnosticReport_relatedDocuments {
    RelatedUnchangedDocumentDiagnosticReport_relatedDocuments value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::OBJECT_TYPE: {
      try {
        value = anyToFullDocumentDiagnosticReport(any);
      } catch (LspException &e) {
        try {
          value = anyToUnchangedDocumentDiagnosticReport(any);
        } catch (LspException &e) {
          throw LSP_EXCEPTION(
            ErrorCodes::INVALID_PARAMS,
            "Failed to transform LSPAny to RelatedUnchangedDocumentDiagnosticReport_relatedDocuments"
          );
        }
      }
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) RelatedUnchangedDocumentDiagnosticReport_relatedDocuments: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::relatedUnchangedDocumentDiagnosticReport_relatedDocumentsToAny(
    const RelatedUnchangedDocumentDiagnosticReport_relatedDocuments &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<RelatedUnchangedDocumentDiagnosticReport_relatedDocumentsType>(variant.index())) {
    case RelatedUnchangedDocumentDiagnosticReport_relatedDocumentsType::FULL_DOCUMENT_DIAGNOSTIC_REPORT: {
      return fullDocumentDiagnosticReportToAny(
        *std::get<std::unique_ptr<FullDocumentDiagnosticReport>>(variant)
      );
    }
    case RelatedUnchangedDocumentDiagnosticReport_relatedDocumentsType::UNCHANGED_DOCUMENT_DIAGNOSTIC_REPORT: {
      return unchangedDocumentDiagnosticReportToAny(
        *std::get<std::unique_ptr<UnchangedDocumentDiagnosticReport>>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported RelatedUnchangedDocumentDiagnosticReport_relatedDocumentsType: " +
         RelatedUnchangedDocumentDiagnosticReport_relatedDocumentsTypeNames.at(static_cast<RelatedUnchangedDocumentDiagnosticReport_relatedDocumentsType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToRelatedUnchangedDocumentDiagnosticReport(
    const LSPAny &any
  ) const -> std::unique_ptr<RelatedUnchangedDocumentDiagnosticReport> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) RelatedUnchangedDocumentDiagnosticReport must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<RelatedUnchangedDocumentDiagnosticReport> value =
      std::make_unique<RelatedUnchangedDocumentDiagnosticReport>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) RelatedUnchangedDocumentDiagnosticReport: " + std::to_string(object.size())
      );
    }

    iter = object.find("relatedDocuments");
    if (iter != object.end()) {
      const LSPObject &object_map = std::get<LSPObject>(*iter->second);
      std::map<DocumentUri, RelatedUnchangedDocumentDiagnosticReport_relatedDocuments> map;
      for (const auto &[map_key, map_value] : object_map) {
        map.emplace(map_key, anyToRelatedUnchangedDocumentDiagnosticReport_relatedDocuments(*map_value));
      }
      value->relatedDocuments = std::move(map);
    }

    iter = object.find("kind");
    if (iter != object.end()) {
      const string_t &stringValue = anyToString(*iter->second);
      if (stringValue != "unchanged") {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          "String value for RelatedUnchangedDocumentDiagnosticReport.kind must be \"unchanged\" but was: \"" + stringValue + "\""
        );
      }
      value->kind = stringValue;
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required RelatedUnchangedDocumentDiagnosticReport attribute: kind"
      );
    }

    iter = object.find("resultId");
    if (iter != object.end()) {
      value->resultId = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required RelatedUnchangedDocumentDiagnosticReport attribute: resultId"
      );
    }

    return value;
  }

  auto LspTransformer::relatedUnchangedDocumentDiagnosticReportToAny(
    const RelatedUnchangedDocumentDiagnosticReport &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.relatedDocuments.has_value()) {
      LSPObject map;
      for (const auto &[mapKey, mapValue] : structure.relatedDocuments.value()) {
        map.emplace(mapKey, relatedUnchangedDocumentDiagnosticReport_relatedDocumentsToAny(mapValue));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(map);
      object.emplace("relatedDocuments", std::move(any));
    }
    object.emplace("kind", stringToAny(structure.kind));
    object.emplace("resultId", stringToAny(structure.resultId));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToFullDocumentDiagnosticReport(
    const LSPAny &any
  ) const -> std::unique_ptr<FullDocumentDiagnosticReport> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) FullDocumentDiagnosticReport must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<FullDocumentDiagnosticReport> value =
      std::make_unique<FullDocumentDiagnosticReport>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) FullDocumentDiagnosticReport: " + std::to_string(object.size())
      );
    }

    iter = object.find("kind");
    if (iter != object.end()) {
      const string_t &stringValue = anyToString(*iter->second);
      if (stringValue != "full") {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          "String value for FullDocumentDiagnosticReport.kind must be \"full\" but was: \"" + stringValue + "\""
        );
      }
      value->kind = stringValue;
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required FullDocumentDiagnosticReport attribute: kind"
      );
    }

    iter = object.find("resultId");
    if (iter != object.end()) {
      value->resultId = anyToString(*iter->second);
    }

    iter = object.find("items");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<std::unique_ptr<Diagnostic>> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToDiagnostic(*elem));
      }
      value->items = std::move(values);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required FullDocumentDiagnosticReport attribute: items"
      );
    }

    return value;
  }

  auto LspTransformer::fullDocumentDiagnosticReportToAny(
    const FullDocumentDiagnosticReport &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("kind", stringToAny(structure.kind));
    if (structure.resultId.has_value()) {
      object.emplace("resultId", stringToAny(structure.resultId.value()));
    }
    {
      LSPArray array;
      for (const std::unique_ptr<Diagnostic> &elem : structure.items) {
        array.push_back(diagnosticToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("items", std::move(any));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToUnchangedDocumentDiagnosticReport(
    const LSPAny &any
  ) const -> std::unique_ptr<UnchangedDocumentDiagnosticReport> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) UnchangedDocumentDiagnosticReport must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<UnchangedDocumentDiagnosticReport> value =
      std::make_unique<UnchangedDocumentDiagnosticReport>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) UnchangedDocumentDiagnosticReport: " + std::to_string(object.size())
      );
    }

    iter = object.find("kind");
    if (iter != object.end()) {
      const string_t &stringValue = anyToString(*iter->second);
      if (stringValue != "unchanged") {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          "String value for UnchangedDocumentDiagnosticReport.kind must be \"unchanged\" but was: \"" + stringValue + "\""
        );
      }
      value->kind = stringValue;
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required UnchangedDocumentDiagnosticReport attribute: kind"
      );
    }

    iter = object.find("resultId");
    if (iter != object.end()) {
      value->resultId = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required UnchangedDocumentDiagnosticReport attribute: resultId"
      );
    }

    return value;
  }

  auto LspTransformer::unchangedDocumentDiagnosticReportToAny(
    const UnchangedDocumentDiagnosticReport &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("kind", stringToAny(structure.kind));
    object.emplace("resultId", stringToAny(structure.resultId));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToDiagnosticOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<DiagnosticOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) DiagnosticOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<DiagnosticOptions> value =
      std::make_unique<DiagnosticOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 4) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) DiagnosticOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("identifier");
    if (iter != object.end()) {
      value->identifier = anyToString(*iter->second);
    }

    iter = object.find("interFileDependencies");
    if (iter != object.end()) {
      value->interFileDependencies = anyToBoolean(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DiagnosticOptions attribute: interFileDependencies"
      );
    }

    iter = object.find("workspaceDiagnostics");
    if (iter != object.end()) {
      value->workspaceDiagnostics = anyToBoolean(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DiagnosticOptions attribute: workspaceDiagnostics"
      );
    }

    iter = object.find("workDoneProgress");
    if (iter != object.end()) {
      value->workDoneProgress = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::diagnosticOptionsToAny(
    const DiagnosticOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.identifier.has_value()) {
      object.emplace("identifier", stringToAny(structure.identifier.value()));
    }
    object.emplace("interFileDependencies", booleanToAny(structure.interFileDependencies));
    object.emplace("workspaceDiagnostics", booleanToAny(structure.workspaceDiagnostics));
    if (structure.workDoneProgress.has_value()) {
      object.emplace("workDoneProgress", booleanToAny(structure.workDoneProgress.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToPreviousResultId(
    const LSPAny &any
  ) const -> std::unique_ptr<PreviousResultId> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) PreviousResultId must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<PreviousResultId> value =
      std::make_unique<PreviousResultId>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) PreviousResultId: " + std::to_string(object.size())
      );
    }

    iter = object.find("uri");
    if (iter != object.end()) {
      value->uri = anyToDocumentUri(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required PreviousResultId attribute: uri"
      );
    }

    iter = object.find("value");
    if (iter != object.end()) {
      value->value = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required PreviousResultId attribute: value"
      );
    }

    return value;
  }

  auto LspTransformer::previousResultIdToAny(
    const PreviousResultId &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("uri", documentUriToAny(structure.uri));
    object.emplace("value", stringToAny(structure.value));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToNotebookDocument(
    const LSPAny &any
  ) const -> std::unique_ptr<NotebookDocument> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) NotebookDocument must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<NotebookDocument> value =
      std::make_unique<NotebookDocument>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 5) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) NotebookDocument: " + std::to_string(object.size())
      );
    }

    iter = object.find("uri");
    if (iter != object.end()) {
      value->uri = anyToURI(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required NotebookDocument attribute: uri"
      );
    }

    iter = object.find("notebookType");
    if (iter != object.end()) {
      value->notebookType = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required NotebookDocument attribute: notebookType"
      );
    }

    iter = object.find("version");
    if (iter != object.end()) {
      value->version = anyToInteger(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required NotebookDocument attribute: version"
      );
    }

    iter = object.find("metadata");
    if (iter != object.end()) {
      const LSPObject &object = std::get<LSPObject>(*iter->second);
      value->metadata = copy(object);
    }

    iter = object.find("cells");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<std::unique_ptr<NotebookCell>> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToNotebookCell(*elem));
      }
      value->cells = std::move(values);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required NotebookDocument attribute: cells"
      );
    }

    return value;
  }

  auto LspTransformer::notebookDocumentToAny(
    const NotebookDocument &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("uri", uriToAny(structure.uri));
    object.emplace("notebookType", stringToAny(structure.notebookType));
    object.emplace("version", integerToAny(structure.version));
    if (structure.metadata.has_value()) {
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = copy(structure.metadata.value());
      object.emplace("metadata", std::move(any));
    }
    {
      LSPArray array;
      for (const std::unique_ptr<NotebookCell> &elem : structure.cells) {
        array.push_back(notebookCellToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("cells", std::move(any));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToTextDocumentItem(
    const LSPAny &any
  ) const -> std::unique_ptr<TextDocumentItem> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) TextDocumentItem must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<TextDocumentItem> value =
      std::make_unique<TextDocumentItem>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 4) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) TextDocumentItem: " + std::to_string(object.size())
      );
    }

    iter = object.find("uri");
    if (iter != object.end()) {
      value->uri = anyToDocumentUri(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required TextDocumentItem attribute: uri"
      );
    }

    iter = object.find("languageId");
    if (iter != object.end()) {
      value->languageId = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required TextDocumentItem attribute: languageId"
      );
    }

    iter = object.find("version");
    if (iter != object.end()) {
      value->version = anyToInteger(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required TextDocumentItem attribute: version"
      );
    }

    iter = object.find("text");
    if (iter != object.end()) {
      value->text = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required TextDocumentItem attribute: text"
      );
    }

    return value;
  }

  auto LspTransformer::textDocumentItemToAny(
    const TextDocumentItem &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("uri", documentUriToAny(structure.uri));
    object.emplace("languageId", stringToAny(structure.languageId));
    object.emplace("version", integerToAny(structure.version));
    object.emplace("text", stringToAny(structure.text));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToVersionedNotebookDocumentIdentifier(
    const LSPAny &any
  ) const -> std::unique_ptr<VersionedNotebookDocumentIdentifier> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) VersionedNotebookDocumentIdentifier must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<VersionedNotebookDocumentIdentifier> value =
      std::make_unique<VersionedNotebookDocumentIdentifier>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) VersionedNotebookDocumentIdentifier: " + std::to_string(object.size())
      );
    }

    iter = object.find("version");
    if (iter != object.end()) {
      value->version = anyToInteger(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required VersionedNotebookDocumentIdentifier attribute: version"
      );
    }

    iter = object.find("uri");
    if (iter != object.end()) {
      value->uri = anyToURI(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required VersionedNotebookDocumentIdentifier attribute: uri"
      );
    }

    return value;
  }

  auto LspTransformer::versionedNotebookDocumentIdentifierToAny(
    const VersionedNotebookDocumentIdentifier &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("version", integerToAny(structure.version));
    object.emplace("uri", uriToAny(structure.uri));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToNotebookDocumentChangeEvent_cells_textContent(
    const LSPAny &any
  ) const -> std::unique_ptr<NotebookDocumentChangeEvent_cells_textContent> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) NotebookDocumentChangeEvent_cells_textContent must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<NotebookDocumentChangeEvent_cells_textContent> value =
      std::make_unique<NotebookDocumentChangeEvent_cells_textContent>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) NotebookDocumentChangeEvent_cells_textContent: " + std::to_string(object.size())
      );
    }

    iter = object.find("document");
    if (iter != object.end()) {
      value->document = anyToVersionedTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required NotebookDocumentChangeEvent_cells_textContent attribute: document"
      );
    }

    iter = object.find("changes");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<TextDocumentContentChangeEvent> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToTextDocumentContentChangeEvent(*elem));
      }
      value->changes = std::move(values);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required NotebookDocumentChangeEvent_cells_textContent attribute: changes"
      );
    }

    return value;
  }

  auto LspTransformer::notebookDocumentChangeEvent_cells_textContentToAny(
    const NotebookDocumentChangeEvent_cells_textContent &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("document", versionedTextDocumentIdentifierToAny(*structure.document));
    {
      LSPArray array;
      for (const TextDocumentContentChangeEvent &elem : structure.changes) {
        array.push_back(textDocumentContentChangeEventToAny(elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("changes", std::move(any));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToNotebookDocumentChangeEvent_cells_structure(
    const LSPAny &any
  ) const -> std::unique_ptr<NotebookDocumentChangeEvent_cells_structure> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) NotebookDocumentChangeEvent_cells_structure must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<NotebookDocumentChangeEvent_cells_structure> value =
      std::make_unique<NotebookDocumentChangeEvent_cells_structure>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) NotebookDocumentChangeEvent_cells_structure: " + std::to_string(object.size())
      );
    }

    iter = object.find("array");
    if (iter != object.end()) {
      value->array = anyToNotebookCellArrayChange(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required NotebookDocumentChangeEvent_cells_structure attribute: array"
      );
    }

    iter = object.find("didOpen");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<std::unique_ptr<TextDocumentItem>> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToTextDocumentItem(*elem));
      }
      value->didOpen = std::move(values);
    }

    iter = object.find("didClose");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<std::unique_ptr<TextDocumentIdentifier>> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToTextDocumentIdentifier(*elem));
      }
      value->didClose = std::move(values);
    }

    return value;
  }

  auto LspTransformer::notebookDocumentChangeEvent_cells_structureToAny(
    const NotebookDocumentChangeEvent_cells_structure &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("array", notebookCellArrayChangeToAny(*structure.array));
    if (structure.didOpen.has_value()) {
      LSPArray array;
      for (const std::unique_ptr<TextDocumentItem> &elem : structure.didOpen.value()) {
        array.push_back(textDocumentItemToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("didOpen", std::move(any));
    }
    if (structure.didClose.has_value()) {
      LSPArray array;
      for (const std::unique_ptr<TextDocumentIdentifier> &elem : structure.didClose.value()) {
        array.push_back(textDocumentIdentifierToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("didClose", std::move(any));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToNotebookDocumentChangeEvent_cells(
    const LSPAny &any
  ) const -> std::unique_ptr<NotebookDocumentChangeEvent_cells> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) NotebookDocumentChangeEvent_cells must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<NotebookDocumentChangeEvent_cells> value =
      std::make_unique<NotebookDocumentChangeEvent_cells>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) NotebookDocumentChangeEvent_cells: " + std::to_string(object.size())
      );
    }

    iter = object.find("structure");
    if (iter != object.end()) {
      value->structure = anyToNotebookDocumentChangeEvent_cells_structure(*iter->second);
    }

    iter = object.find("data");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<std::unique_ptr<NotebookCell>> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToNotebookCell(*elem));
      }
      value->data = std::move(values);
    }

    iter = object.find("textContent");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<std::unique_ptr<NotebookDocumentChangeEvent_cells_textContent>> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToNotebookDocumentChangeEvent_cells_textContent(*elem));
      }
      value->textContent = std::move(values);
    }

    return value;
  }

  auto LspTransformer::notebookDocumentChangeEvent_cellsToAny(
    const NotebookDocumentChangeEvent_cells &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.structure.has_value()) {
      object.emplace("structure", notebookDocumentChangeEvent_cells_structureToAny(*structure.structure.value()));
    }
    if (structure.data.has_value()) {
      LSPArray array;
      for (const std::unique_ptr<NotebookCell> &elem : structure.data.value()) {
        array.push_back(notebookCellToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("data", std::move(any));
    }
    if (structure.textContent.has_value()) {
      LSPArray array;
      for (const std::unique_ptr<NotebookDocumentChangeEvent_cells_textContent> &elem : structure.textContent.value()) {
        array.push_back(notebookDocumentChangeEvent_cells_textContentToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("textContent", std::move(any));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToNotebookDocumentChangeEvent(
    const LSPAny &any
  ) const -> std::unique_ptr<NotebookDocumentChangeEvent> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) NotebookDocumentChangeEvent must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<NotebookDocumentChangeEvent> value =
      std::make_unique<NotebookDocumentChangeEvent>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) NotebookDocumentChangeEvent: " + std::to_string(object.size())
      );
    }

    iter = object.find("metadata");
    if (iter != object.end()) {
      const LSPObject &object = std::get<LSPObject>(*iter->second);
      value->metadata = copy(object);
    }

    iter = object.find("cells");
    if (iter != object.end()) {
      value->cells = anyToNotebookDocumentChangeEvent_cells(*iter->second);
    }

    return value;
  }

  auto LspTransformer::notebookDocumentChangeEventToAny(
    const NotebookDocumentChangeEvent &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.metadata.has_value()) {
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = copy(structure.metadata.value());
      object.emplace("metadata", std::move(any));
    }
    if (structure.cells.has_value()) {
      object.emplace("cells", notebookDocumentChangeEvent_cellsToAny(*structure.cells.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToNotebookDocumentIdentifier(
    const LSPAny &any
  ) const -> std::unique_ptr<NotebookDocumentIdentifier> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) NotebookDocumentIdentifier must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<NotebookDocumentIdentifier> value =
      std::make_unique<NotebookDocumentIdentifier>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) NotebookDocumentIdentifier: " + std::to_string(object.size())
      );
    }

    iter = object.find("uri");
    if (iter != object.end()) {
      value->uri = anyToURI(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required NotebookDocumentIdentifier attribute: uri"
      );
    }

    return value;
  }

  auto LspTransformer::notebookDocumentIdentifierToAny(
    const NotebookDocumentIdentifier &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("uri", uriToAny(structure.uri));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToInlineCompletionContext(
    const LSPAny &any
  ) const -> std::unique_ptr<InlineCompletionContext> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) InlineCompletionContext must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<InlineCompletionContext> value =
      std::make_unique<InlineCompletionContext>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) InlineCompletionContext: " + std::to_string(object.size())
      );
    }

    iter = object.find("triggerKind");
    if (iter != object.end()) {
      value->triggerKind = anyToInlineCompletionTriggerKind(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required InlineCompletionContext attribute: triggerKind"
      );
    }

    iter = object.find("selectedCompletionInfo");
    if (iter != object.end()) {
      value->selectedCompletionInfo = anyToSelectedCompletionInfo(*iter->second);
    }

    return value;
  }

  auto LspTransformer::inlineCompletionContextToAny(
    const InlineCompletionContext &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("triggerKind", inlineCompletionTriggerKindToAny(structure.triggerKind));
    if (structure.selectedCompletionInfo.has_value()) {
      object.emplace("selectedCompletionInfo", selectedCompletionInfoToAny(*structure.selectedCompletionInfo.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToStringValue(
    const LSPAny &any
  ) const -> std::unique_ptr<StringValue> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) StringValue must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<StringValue> value =
      std::make_unique<StringValue>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) StringValue: " + std::to_string(object.size())
      );
    }

    iter = object.find("kind");
    if (iter != object.end()) {
      const string_t &stringValue = anyToString(*iter->second);
      if (stringValue != "snippet") {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          "String value for StringValue.kind must be \"snippet\" but was: \"" + stringValue + "\""
        );
      }
      value->kind = stringValue;
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required StringValue attribute: kind"
      );
    }

    iter = object.find("value");
    if (iter != object.end()) {
      value->value = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required StringValue attribute: value"
      );
    }

    return value;
  }

  auto LspTransformer::stringValueToAny(
    const StringValue &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("kind", stringToAny(structure.kind));
    object.emplace("value", stringToAny(structure.value));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToInlineCompletionOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<InlineCompletionOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) InlineCompletionOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<InlineCompletionOptions> value =
      std::make_unique<InlineCompletionOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) InlineCompletionOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("workDoneProgress");
    if (iter != object.end()) {
      value->workDoneProgress = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::inlineCompletionOptionsToAny(
    const InlineCompletionOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.workDoneProgress.has_value()) {
      object.emplace("workDoneProgress", booleanToAny(structure.workDoneProgress.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToRegistration(
    const LSPAny &any
  ) const -> std::unique_ptr<Registration> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) Registration must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<Registration> value =
      std::make_unique<Registration>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) Registration: " + std::to_string(object.size())
      );
    }

    iter = object.find("id");
    if (iter != object.end()) {
      value->id = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required Registration attribute: id"
      );
    }

    iter = object.find("method");
    if (iter != object.end()) {
      value->method = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required Registration attribute: method"
      );
    }

    iter = object.find("registerOptions");
    if (iter != object.end()) {
      value->registerOptions = copy(iter->second);
    }

    return value;
  }

  auto LspTransformer::registrationToAny(
    const Registration &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("id", stringToAny(structure.id));
    object.emplace("method", stringToAny(structure.method));
    if (structure.registerOptions.has_value()) {
      object.emplace("registerOptions", copy(structure.registerOptions.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToUnregistration(
    const LSPAny &any
  ) const -> std::unique_ptr<Unregistration> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) Unregistration must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<Unregistration> value =
      std::make_unique<Unregistration>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) Unregistration: " + std::to_string(object.size())
      );
    }

    iter = object.find("id");
    if (iter != object.end()) {
      value->id = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required Unregistration attribute: id"
      );
    }

    iter = object.find("method");
    if (iter != object.end()) {
      value->method = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required Unregistration attribute: method"
      );
    }

    return value;
  }

  auto LspTransformer::unregistrationToAny(
    const Unregistration &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("id", stringToAny(structure.id));
    object.emplace("method", stringToAny(structure.method));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyTo_InitializeParams_processId(
    const LSPAny &any
  ) const -> _InitializeParams_processId {
    _InitializeParams_processId value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::INTEGER_TYPE: {
      value = anyToInteger(any);
      break;
    }
    case LSPAnyType::NULL_TYPE: {
      value = anyToNull(any);
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) _InitializeParams_processId: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::_InitializeParams_processIdToAny(
    const _InitializeParams_processId &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<_InitializeParams_processIdType>(variant.index())) {
    case _InitializeParams_processIdType::INTEGER_TYPE: {
      return integerToAny(
        std::get<integer_t>(variant)
      );
    }
    case _InitializeParams_processIdType::NULL_TYPE: {
      return nullToAny(
        std::get<null_t>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported _InitializeParams_processIdType: " +
         _InitializeParams_processIdTypeNames.at(static_cast<_InitializeParams_processIdType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyTo_InitializeParams_clientInfo(
    const LSPAny &any
  ) const -> std::unique_ptr<_InitializeParams_clientInfo> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) _InitializeParams_clientInfo must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<_InitializeParams_clientInfo> value =
      std::make_unique<_InitializeParams_clientInfo>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) _InitializeParams_clientInfo: " + std::to_string(object.size())
      );
    }

    iter = object.find("name");
    if (iter != object.end()) {
      value->name = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required _InitializeParams_clientInfo attribute: name"
      );
    }

    iter = object.find("version");
    if (iter != object.end()) {
      value->version = anyToString(*iter->second);
    }

    return value;
  }

  auto LspTransformer::_InitializeParams_clientInfoToAny(
    const _InitializeParams_clientInfo &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("name", stringToAny(structure.name));
    if (structure.version.has_value()) {
      object.emplace("version", stringToAny(structure.version.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyTo_InitializeParams_rootPath(
    const LSPAny &any
  ) const -> _InitializeParams_rootPath {
    _InitializeParams_rootPath value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::STRING_TYPE: {
      value = anyToString(any);
      break;
    }
    case LSPAnyType::NULL_TYPE: {
      value = anyToNull(any);
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) _InitializeParams_rootPath: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::_InitializeParams_rootPathToAny(
    const _InitializeParams_rootPath &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<_InitializeParams_rootPathType>(variant.index())) {
    case _InitializeParams_rootPathType::STRING_TYPE: {
      return stringToAny(
        std::get<string_t>(variant)
      );
    }
    case _InitializeParams_rootPathType::NULL_TYPE: {
      return nullToAny(
        std::get<null_t>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported _InitializeParams_rootPathType: " +
         _InitializeParams_rootPathTypeNames.at(static_cast<_InitializeParams_rootPathType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyTo_InitializeParams_rootUri(
    const LSPAny &any
  ) const -> _InitializeParams_rootUri {
    _InitializeParams_rootUri value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::STRING_TYPE: {
      value = anyToString(any);
      break;
    }
    case LSPAnyType::NULL_TYPE: {
      value = anyToNull(any);
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) _InitializeParams_rootUri: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::_InitializeParams_rootUriToAny(
    const _InitializeParams_rootUri &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<_InitializeParams_rootUriType>(variant.index())) {
    case _InitializeParams_rootUriType::DOCUMENT_URI: {
      return documentUriToAny(
        std::get<DocumentUri>(variant)
      );
    }
    case _InitializeParams_rootUriType::NULL_TYPE: {
      return nullToAny(
        std::get<null_t>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported _InitializeParams_rootUriType: " +
         _InitializeParams_rootUriTypeNames.at(static_cast<_InitializeParams_rootUriType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyTo_InitializeParams(
    const LSPAny &any
  ) const -> std::unique_ptr<_InitializeParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) _InitializeParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<_InitializeParams> value =
      std::make_unique<_InitializeParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 9) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) _InitializeParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("processId");
    if (iter != object.end()) {
      value->processId = anyTo_InitializeParams_processId(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required _InitializeParams attribute: processId"
      );
    }

    iter = object.find("clientInfo");
    if (iter != object.end()) {
      value->clientInfo = anyTo_InitializeParams_clientInfo(*iter->second);
    }

    iter = object.find("locale");
    if (iter != object.end()) {
      value->locale = anyToString(*iter->second);
    }

    iter = object.find("rootPath");
    if (iter != object.end()) {
      value->rootPath = anyTo_InitializeParams_rootPath(*iter->second);
    }

    iter = object.find("rootUri");
    if (iter != object.end()) {
      value->rootUri = anyTo_InitializeParams_rootUri(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required _InitializeParams attribute: rootUri"
      );
    }

    iter = object.find("capabilities");
    if (iter != object.end()) {
      value->capabilities = anyToClientCapabilities(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required _InitializeParams attribute: capabilities"
      );
    }

    iter = object.find("initializationOptions");
    if (iter != object.end()) {
      value->initializationOptions = copy(iter->second);
    }

    iter = object.find("trace");
    if (iter != object.end()) {
      value->trace = anyToTraceValues(*iter->second);
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      value->workDoneToken = anyToProgressToken(*iter->second);
    }

    return value;
  }

  auto LspTransformer::_InitializeParamsToAny(
    const _InitializeParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("processId", _InitializeParams_processIdToAny(structure.processId));
    if (structure.clientInfo.has_value()) {
      object.emplace("clientInfo", _InitializeParams_clientInfoToAny(*structure.clientInfo.value()));
    }
    if (structure.locale.has_value()) {
      object.emplace("locale", stringToAny(structure.locale.value()));
    }
    if (structure.rootPath.has_value()) {
      object.emplace("rootPath", _InitializeParams_rootPathToAny(structure.rootPath.value()));
    }
    object.emplace("rootUri", _InitializeParams_rootUriToAny(structure.rootUri));
    object.emplace("capabilities", clientCapabilitiesToAny(*structure.capabilities));
    if (structure.initializationOptions.has_value()) {
      object.emplace("initializationOptions", copy(structure.initializationOptions.value()));
    }
    if (structure.trace.has_value()) {
      object.emplace("trace", traceValuesToAny(structure.trace.value()));
    }
    if (structure.workDoneToken.has_value()) {
      object.emplace("workDoneToken", progressTokenToAny(structure.workDoneToken.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToWorkspaceFoldersInitializeParams_workspaceFolders(
    const LSPAny &any
  ) const -> WorkspaceFoldersInitializeParams_workspaceFolders {
    WorkspaceFoldersInitializeParams_workspaceFolders value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::ARRAY_TYPE: {
      try {
        std::vector<std::unique_ptr<WorkspaceFolder>> values;
        for (const std::unique_ptr<LSPAny> &elem
            : std::get<LSPArray>(any)) {
          values.push_back(anyToWorkspaceFolder(*elem));
        }
        value = std::move(values);
      } catch (LspException &e) {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          "Failed to transform LSPAny to array"
        );
      }
      break;
    }
    case LSPAnyType::NULL_TYPE: {
      value = anyToNull(any);
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) WorkspaceFoldersInitializeParams_workspaceFolders: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::workspaceFoldersInitializeParams_workspaceFoldersToAny(
    const WorkspaceFoldersInitializeParams_workspaceFolders &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<WorkspaceFoldersInitializeParams_workspaceFoldersType>(variant.index())) {
    case WorkspaceFoldersInitializeParams_workspaceFoldersType::WORKSPACE_FOLDER_ARRAY: {
      LSPArray array;
      for (const std::unique_ptr<WorkspaceFolder> &elem
          : std::get<std::vector<std::unique_ptr<WorkspaceFolder>>>(variant)) {
        array.push_back(workspaceFolderToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      return any;
    }
    case WorkspaceFoldersInitializeParams_workspaceFoldersType::NULL_TYPE: {
      return nullToAny(
        std::get<null_t>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported WorkspaceFoldersInitializeParams_workspaceFoldersType: " +
         WorkspaceFoldersInitializeParams_workspaceFoldersTypeNames.at(static_cast<WorkspaceFoldersInitializeParams_workspaceFoldersType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToWorkspaceFoldersInitializeParams(
    const LSPAny &any
  ) const -> std::unique_ptr<WorkspaceFoldersInitializeParams> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) WorkspaceFoldersInitializeParams must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<WorkspaceFoldersInitializeParams> value =
      std::make_unique<WorkspaceFoldersInitializeParams>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) WorkspaceFoldersInitializeParams: " + std::to_string(object.size())
      );
    }

    iter = object.find("workspaceFolders");
    if (iter != object.end()) {
      value->workspaceFolders = anyToWorkspaceFoldersInitializeParams_workspaceFolders(*iter->second);
    }

    return value;
  }

  auto LspTransformer::workspaceFoldersInitializeParamsToAny(
    const WorkspaceFoldersInitializeParams &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.workspaceFolders.has_value()) {
      object.emplace("workspaceFolders", workspaceFoldersInitializeParams_workspaceFoldersToAny(structure.workspaceFolders.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToServerCapabilities_textDocumentSync(
    const LSPAny &any
  ) const -> ServerCapabilities_textDocumentSync {
    ServerCapabilities_textDocumentSync value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::OBJECT_TYPE: {
      try {
        value = anyToTextDocumentSyncOptions(any);
      } catch (LspException &e) {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          "Failed to transform LSPAny to ServerCapabilities_textDocumentSync"
        );
      }
      break;
    }
    case LSPAnyType::UINTEGER_TYPE: {
      try {
        value = anyToTextDocumentSyncKind(any);
      } catch (LspException &e) {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          "Failed to transform LSPAny to ServerCapabilities_textDocumentSync"
        );
      }
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) ServerCapabilities_textDocumentSync: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::serverCapabilities_textDocumentSyncToAny(
    const ServerCapabilities_textDocumentSync &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<ServerCapabilities_textDocumentSyncType>(variant.index())) {
    case ServerCapabilities_textDocumentSyncType::TEXT_DOCUMENT_SYNC_OPTIONS: {
      return textDocumentSyncOptionsToAny(
        *std::get<std::unique_ptr<TextDocumentSyncOptions>>(variant)
      );
    }
    case ServerCapabilities_textDocumentSyncType::TEXT_DOCUMENT_SYNC_KIND: {
      return textDocumentSyncKindToAny(
        std::get<TextDocumentSyncKind>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported ServerCapabilities_textDocumentSyncType: " +
         ServerCapabilities_textDocumentSyncTypeNames.at(static_cast<ServerCapabilities_textDocumentSyncType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToServerCapabilities_notebookDocumentSync(
    const LSPAny &any
  ) const -> ServerCapabilities_notebookDocumentSync {
    ServerCapabilities_notebookDocumentSync value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::OBJECT_TYPE: {
      try {
        value = anyToNotebookDocumentSyncOptions(any);
      } catch (LspException &e) {
        try {
          value = anyToNotebookDocumentSyncRegistrationOptions(any);
        } catch (LspException &e) {
          throw LSP_EXCEPTION(
            ErrorCodes::INVALID_PARAMS,
            "Failed to transform LSPAny to ServerCapabilities_notebookDocumentSync"
          );
        }
      }
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) ServerCapabilities_notebookDocumentSync: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::serverCapabilities_notebookDocumentSyncToAny(
    const ServerCapabilities_notebookDocumentSync &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<ServerCapabilities_notebookDocumentSyncType>(variant.index())) {
    case ServerCapabilities_notebookDocumentSyncType::NOTEBOOK_DOCUMENT_SYNC_OPTIONS: {
      return notebookDocumentSyncOptionsToAny(
        *std::get<std::unique_ptr<NotebookDocumentSyncOptions>>(variant)
      );
    }
    case ServerCapabilities_notebookDocumentSyncType::NOTEBOOK_DOCUMENT_SYNC_REGISTRATION_OPTIONS: {
      return notebookDocumentSyncRegistrationOptionsToAny(
        *std::get<std::unique_ptr<NotebookDocumentSyncRegistrationOptions>>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported ServerCapabilities_notebookDocumentSyncType: " +
         ServerCapabilities_notebookDocumentSyncTypeNames.at(static_cast<ServerCapabilities_notebookDocumentSyncType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToServerCapabilities_hoverProvider(
    const LSPAny &any
  ) const -> ServerCapabilities_hoverProvider {
    ServerCapabilities_hoverProvider value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::OBJECT_TYPE: {
      try {
        value = anyToHoverOptions(any);
      } catch (LspException &e) {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          "Failed to transform LSPAny to ServerCapabilities_hoverProvider"
        );
      }
      break;
    }
    case LSPAnyType::BOOLEAN_TYPE: {
      value = anyToBoolean(any);
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) ServerCapabilities_hoverProvider: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::serverCapabilities_hoverProviderToAny(
    const ServerCapabilities_hoverProvider &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<ServerCapabilities_hoverProviderType>(variant.index())) {
    case ServerCapabilities_hoverProviderType::BOOLEAN_TYPE: {
      return booleanToAny(
        std::get<boolean_t>(variant)
      );
    }
    case ServerCapabilities_hoverProviderType::HOVER_OPTIONS: {
      return hoverOptionsToAny(
        *std::get<std::unique_ptr<HoverOptions>>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported ServerCapabilities_hoverProviderType: " +
         ServerCapabilities_hoverProviderTypeNames.at(static_cast<ServerCapabilities_hoverProviderType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToServerCapabilities_declarationProvider(
    const LSPAny &any
  ) const -> ServerCapabilities_declarationProvider {
    ServerCapabilities_declarationProvider value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::OBJECT_TYPE: {
      try {
        value = anyToDeclarationOptions(any);
      } catch (LspException &e) {
        try {
          value = anyToDeclarationRegistrationOptions(any);
        } catch (LspException &e) {
          throw LSP_EXCEPTION(
            ErrorCodes::INVALID_PARAMS,
            "Failed to transform LSPAny to ServerCapabilities_declarationProvider"
          );
        }
      }
      break;
    }
    case LSPAnyType::BOOLEAN_TYPE: {
      value = anyToBoolean(any);
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) ServerCapabilities_declarationProvider: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::serverCapabilities_declarationProviderToAny(
    const ServerCapabilities_declarationProvider &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<ServerCapabilities_declarationProviderType>(variant.index())) {
    case ServerCapabilities_declarationProviderType::BOOLEAN_TYPE: {
      return booleanToAny(
        std::get<boolean_t>(variant)
      );
    }
    case ServerCapabilities_declarationProviderType::DECLARATION_OPTIONS: {
      return declarationOptionsToAny(
        *std::get<std::unique_ptr<DeclarationOptions>>(variant)
      );
    }
    case ServerCapabilities_declarationProviderType::DECLARATION_REGISTRATION_OPTIONS: {
      return declarationRegistrationOptionsToAny(
        *std::get<std::unique_ptr<DeclarationRegistrationOptions>>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported ServerCapabilities_declarationProviderType: " +
         ServerCapabilities_declarationProviderTypeNames.at(static_cast<ServerCapabilities_declarationProviderType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToServerCapabilities_definitionProvider(
    const LSPAny &any
  ) const -> ServerCapabilities_definitionProvider {
    ServerCapabilities_definitionProvider value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::OBJECT_TYPE: {
      try {
        value = anyToDefinitionOptions(any);
      } catch (LspException &e) {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          "Failed to transform LSPAny to ServerCapabilities_definitionProvider"
        );
      }
      break;
    }
    case LSPAnyType::BOOLEAN_TYPE: {
      value = anyToBoolean(any);
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) ServerCapabilities_definitionProvider: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::serverCapabilities_definitionProviderToAny(
    const ServerCapabilities_definitionProvider &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<ServerCapabilities_definitionProviderType>(variant.index())) {
    case ServerCapabilities_definitionProviderType::BOOLEAN_TYPE: {
      return booleanToAny(
        std::get<boolean_t>(variant)
      );
    }
    case ServerCapabilities_definitionProviderType::DEFINITION_OPTIONS: {
      return definitionOptionsToAny(
        *std::get<std::unique_ptr<DefinitionOptions>>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported ServerCapabilities_definitionProviderType: " +
         ServerCapabilities_definitionProviderTypeNames.at(static_cast<ServerCapabilities_definitionProviderType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToServerCapabilities_typeDefinitionProvider(
    const LSPAny &any
  ) const -> ServerCapabilities_typeDefinitionProvider {
    ServerCapabilities_typeDefinitionProvider value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::OBJECT_TYPE: {
      try {
        value = anyToTypeDefinitionOptions(any);
      } catch (LspException &e) {
        try {
          value = anyToTypeDefinitionRegistrationOptions(any);
        } catch (LspException &e) {
          throw LSP_EXCEPTION(
            ErrorCodes::INVALID_PARAMS,
            "Failed to transform LSPAny to ServerCapabilities_typeDefinitionProvider"
          );
        }
      }
      break;
    }
    case LSPAnyType::BOOLEAN_TYPE: {
      value = anyToBoolean(any);
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) ServerCapabilities_typeDefinitionProvider: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::serverCapabilities_typeDefinitionProviderToAny(
    const ServerCapabilities_typeDefinitionProvider &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<ServerCapabilities_typeDefinitionProviderType>(variant.index())) {
    case ServerCapabilities_typeDefinitionProviderType::BOOLEAN_TYPE: {
      return booleanToAny(
        std::get<boolean_t>(variant)
      );
    }
    case ServerCapabilities_typeDefinitionProviderType::TYPE_DEFINITION_OPTIONS: {
      return typeDefinitionOptionsToAny(
        *std::get<std::unique_ptr<TypeDefinitionOptions>>(variant)
      );
    }
    case ServerCapabilities_typeDefinitionProviderType::TYPE_DEFINITION_REGISTRATION_OPTIONS: {
      return typeDefinitionRegistrationOptionsToAny(
        *std::get<std::unique_ptr<TypeDefinitionRegistrationOptions>>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported ServerCapabilities_typeDefinitionProviderType: " +
         ServerCapabilities_typeDefinitionProviderTypeNames.at(static_cast<ServerCapabilities_typeDefinitionProviderType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToServerCapabilities_implementationProvider(
    const LSPAny &any
  ) const -> ServerCapabilities_implementationProvider {
    ServerCapabilities_implementationProvider value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::OBJECT_TYPE: {
      try {
        value = anyToImplementationOptions(any);
      } catch (LspException &e) {
        try {
          value = anyToImplementationRegistrationOptions(any);
        } catch (LspException &e) {
          throw LSP_EXCEPTION(
            ErrorCodes::INVALID_PARAMS,
            "Failed to transform LSPAny to ServerCapabilities_implementationProvider"
          );
        }
      }
      break;
    }
    case LSPAnyType::BOOLEAN_TYPE: {
      value = anyToBoolean(any);
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) ServerCapabilities_implementationProvider: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::serverCapabilities_implementationProviderToAny(
    const ServerCapabilities_implementationProvider &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<ServerCapabilities_implementationProviderType>(variant.index())) {
    case ServerCapabilities_implementationProviderType::BOOLEAN_TYPE: {
      return booleanToAny(
        std::get<boolean_t>(variant)
      );
    }
    case ServerCapabilities_implementationProviderType::IMPLEMENTATION_OPTIONS: {
      return implementationOptionsToAny(
        *std::get<std::unique_ptr<ImplementationOptions>>(variant)
      );
    }
    case ServerCapabilities_implementationProviderType::IMPLEMENTATION_REGISTRATION_OPTIONS: {
      return implementationRegistrationOptionsToAny(
        *std::get<std::unique_ptr<ImplementationRegistrationOptions>>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported ServerCapabilities_implementationProviderType: " +
         ServerCapabilities_implementationProviderTypeNames.at(static_cast<ServerCapabilities_implementationProviderType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToServerCapabilities_referencesProvider(
    const LSPAny &any
  ) const -> ServerCapabilities_referencesProvider {
    ServerCapabilities_referencesProvider value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::OBJECT_TYPE: {
      try {
        value = anyToReferenceOptions(any);
      } catch (LspException &e) {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          "Failed to transform LSPAny to ServerCapabilities_referencesProvider"
        );
      }
      break;
    }
    case LSPAnyType::BOOLEAN_TYPE: {
      value = anyToBoolean(any);
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) ServerCapabilities_referencesProvider: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::serverCapabilities_referencesProviderToAny(
    const ServerCapabilities_referencesProvider &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<ServerCapabilities_referencesProviderType>(variant.index())) {
    case ServerCapabilities_referencesProviderType::BOOLEAN_TYPE: {
      return booleanToAny(
        std::get<boolean_t>(variant)
      );
    }
    case ServerCapabilities_referencesProviderType::REFERENCE_OPTIONS: {
      return referenceOptionsToAny(
        *std::get<std::unique_ptr<ReferenceOptions>>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported ServerCapabilities_referencesProviderType: " +
         ServerCapabilities_referencesProviderTypeNames.at(static_cast<ServerCapabilities_referencesProviderType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToServerCapabilities_documentHighlightProvider(
    const LSPAny &any
  ) const -> ServerCapabilities_documentHighlightProvider {
    ServerCapabilities_documentHighlightProvider value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::OBJECT_TYPE: {
      try {
        value = anyToDocumentHighlightOptions(any);
      } catch (LspException &e) {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          "Failed to transform LSPAny to ServerCapabilities_documentHighlightProvider"
        );
      }
      break;
    }
    case LSPAnyType::BOOLEAN_TYPE: {
      value = anyToBoolean(any);
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) ServerCapabilities_documentHighlightProvider: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::serverCapabilities_documentHighlightProviderToAny(
    const ServerCapabilities_documentHighlightProvider &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<ServerCapabilities_documentHighlightProviderType>(variant.index())) {
    case ServerCapabilities_documentHighlightProviderType::BOOLEAN_TYPE: {
      return booleanToAny(
        std::get<boolean_t>(variant)
      );
    }
    case ServerCapabilities_documentHighlightProviderType::DOCUMENT_HIGHLIGHT_OPTIONS: {
      return documentHighlightOptionsToAny(
        *std::get<std::unique_ptr<DocumentHighlightOptions>>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported ServerCapabilities_documentHighlightProviderType: " +
         ServerCapabilities_documentHighlightProviderTypeNames.at(static_cast<ServerCapabilities_documentHighlightProviderType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToServerCapabilities_documentSymbolProvider(
    const LSPAny &any
  ) const -> ServerCapabilities_documentSymbolProvider {
    ServerCapabilities_documentSymbolProvider value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::OBJECT_TYPE: {
      try {
        value = anyToDocumentSymbolOptions(any);
      } catch (LspException &e) {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          "Failed to transform LSPAny to ServerCapabilities_documentSymbolProvider"
        );
      }
      break;
    }
    case LSPAnyType::BOOLEAN_TYPE: {
      value = anyToBoolean(any);
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) ServerCapabilities_documentSymbolProvider: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::serverCapabilities_documentSymbolProviderToAny(
    const ServerCapabilities_documentSymbolProvider &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<ServerCapabilities_documentSymbolProviderType>(variant.index())) {
    case ServerCapabilities_documentSymbolProviderType::BOOLEAN_TYPE: {
      return booleanToAny(
        std::get<boolean_t>(variant)
      );
    }
    case ServerCapabilities_documentSymbolProviderType::DOCUMENT_SYMBOL_OPTIONS: {
      return documentSymbolOptionsToAny(
        *std::get<std::unique_ptr<DocumentSymbolOptions>>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported ServerCapabilities_documentSymbolProviderType: " +
         ServerCapabilities_documentSymbolProviderTypeNames.at(static_cast<ServerCapabilities_documentSymbolProviderType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToServerCapabilities_codeActionProvider(
    const LSPAny &any
  ) const -> ServerCapabilities_codeActionProvider {
    ServerCapabilities_codeActionProvider value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::OBJECT_TYPE: {
      try {
        value = anyToCodeActionOptions(any);
      } catch (LspException &e) {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          "Failed to transform LSPAny to ServerCapabilities_codeActionProvider"
        );
      }
      break;
    }
    case LSPAnyType::BOOLEAN_TYPE: {
      value = anyToBoolean(any);
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) ServerCapabilities_codeActionProvider: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::serverCapabilities_codeActionProviderToAny(
    const ServerCapabilities_codeActionProvider &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<ServerCapabilities_codeActionProviderType>(variant.index())) {
    case ServerCapabilities_codeActionProviderType::BOOLEAN_TYPE: {
      return booleanToAny(
        std::get<boolean_t>(variant)
      );
    }
    case ServerCapabilities_codeActionProviderType::CODE_ACTION_OPTIONS: {
      return codeActionOptionsToAny(
        *std::get<std::unique_ptr<CodeActionOptions>>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported ServerCapabilities_codeActionProviderType: " +
         ServerCapabilities_codeActionProviderTypeNames.at(static_cast<ServerCapabilities_codeActionProviderType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToServerCapabilities_colorProvider(
    const LSPAny &any
  ) const -> ServerCapabilities_colorProvider {
    ServerCapabilities_colorProvider value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::OBJECT_TYPE: {
      try {
        value = anyToDocumentColorOptions(any);
      } catch (LspException &e) {
        try {
          value = anyToDocumentColorRegistrationOptions(any);
        } catch (LspException &e) {
          throw LSP_EXCEPTION(
            ErrorCodes::INVALID_PARAMS,
            "Failed to transform LSPAny to ServerCapabilities_colorProvider"
          );
        }
      }
      break;
    }
    case LSPAnyType::BOOLEAN_TYPE: {
      value = anyToBoolean(any);
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) ServerCapabilities_colorProvider: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::serverCapabilities_colorProviderToAny(
    const ServerCapabilities_colorProvider &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<ServerCapabilities_colorProviderType>(variant.index())) {
    case ServerCapabilities_colorProviderType::BOOLEAN_TYPE: {
      return booleanToAny(
        std::get<boolean_t>(variant)
      );
    }
    case ServerCapabilities_colorProviderType::DOCUMENT_COLOR_OPTIONS: {
      return documentColorOptionsToAny(
        *std::get<std::unique_ptr<DocumentColorOptions>>(variant)
      );
    }
    case ServerCapabilities_colorProviderType::DOCUMENT_COLOR_REGISTRATION_OPTIONS: {
      return documentColorRegistrationOptionsToAny(
        *std::get<std::unique_ptr<DocumentColorRegistrationOptions>>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported ServerCapabilities_colorProviderType: " +
         ServerCapabilities_colorProviderTypeNames.at(static_cast<ServerCapabilities_colorProviderType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToServerCapabilities_workspaceSymbolProvider(
    const LSPAny &any
  ) const -> ServerCapabilities_workspaceSymbolProvider {
    ServerCapabilities_workspaceSymbolProvider value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::OBJECT_TYPE: {
      try {
        value = anyToWorkspaceSymbolOptions(any);
      } catch (LspException &e) {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          "Failed to transform LSPAny to ServerCapabilities_workspaceSymbolProvider"
        );
      }
      break;
    }
    case LSPAnyType::BOOLEAN_TYPE: {
      value = anyToBoolean(any);
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) ServerCapabilities_workspaceSymbolProvider: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::serverCapabilities_workspaceSymbolProviderToAny(
    const ServerCapabilities_workspaceSymbolProvider &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<ServerCapabilities_workspaceSymbolProviderType>(variant.index())) {
    case ServerCapabilities_workspaceSymbolProviderType::BOOLEAN_TYPE: {
      return booleanToAny(
        std::get<boolean_t>(variant)
      );
    }
    case ServerCapabilities_workspaceSymbolProviderType::WORKSPACE_SYMBOL_OPTIONS: {
      return workspaceSymbolOptionsToAny(
        *std::get<std::unique_ptr<WorkspaceSymbolOptions>>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported ServerCapabilities_workspaceSymbolProviderType: " +
         ServerCapabilities_workspaceSymbolProviderTypeNames.at(static_cast<ServerCapabilities_workspaceSymbolProviderType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToServerCapabilities_documentFormattingProvider(
    const LSPAny &any
  ) const -> ServerCapabilities_documentFormattingProvider {
    ServerCapabilities_documentFormattingProvider value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::OBJECT_TYPE: {
      try {
        value = anyToDocumentFormattingOptions(any);
      } catch (LspException &e) {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          "Failed to transform LSPAny to ServerCapabilities_documentFormattingProvider"
        );
      }
      break;
    }
    case LSPAnyType::BOOLEAN_TYPE: {
      value = anyToBoolean(any);
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) ServerCapabilities_documentFormattingProvider: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::serverCapabilities_documentFormattingProviderToAny(
    const ServerCapabilities_documentFormattingProvider &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<ServerCapabilities_documentFormattingProviderType>(variant.index())) {
    case ServerCapabilities_documentFormattingProviderType::BOOLEAN_TYPE: {
      return booleanToAny(
        std::get<boolean_t>(variant)
      );
    }
    case ServerCapabilities_documentFormattingProviderType::DOCUMENT_FORMATTING_OPTIONS: {
      return documentFormattingOptionsToAny(
        *std::get<std::unique_ptr<DocumentFormattingOptions>>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported ServerCapabilities_documentFormattingProviderType: " +
         ServerCapabilities_documentFormattingProviderTypeNames.at(static_cast<ServerCapabilities_documentFormattingProviderType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToServerCapabilities_documentRangeFormattingProvider(
    const LSPAny &any
  ) const -> ServerCapabilities_documentRangeFormattingProvider {
    ServerCapabilities_documentRangeFormattingProvider value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::OBJECT_TYPE: {
      try {
        value = anyToDocumentRangeFormattingOptions(any);
      } catch (LspException &e) {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          "Failed to transform LSPAny to ServerCapabilities_documentRangeFormattingProvider"
        );
      }
      break;
    }
    case LSPAnyType::BOOLEAN_TYPE: {
      value = anyToBoolean(any);
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) ServerCapabilities_documentRangeFormattingProvider: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::serverCapabilities_documentRangeFormattingProviderToAny(
    const ServerCapabilities_documentRangeFormattingProvider &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<ServerCapabilities_documentRangeFormattingProviderType>(variant.index())) {
    case ServerCapabilities_documentRangeFormattingProviderType::BOOLEAN_TYPE: {
      return booleanToAny(
        std::get<boolean_t>(variant)
      );
    }
    case ServerCapabilities_documentRangeFormattingProviderType::DOCUMENT_RANGE_FORMATTING_OPTIONS: {
      return documentRangeFormattingOptionsToAny(
        *std::get<std::unique_ptr<DocumentRangeFormattingOptions>>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported ServerCapabilities_documentRangeFormattingProviderType: " +
         ServerCapabilities_documentRangeFormattingProviderTypeNames.at(static_cast<ServerCapabilities_documentRangeFormattingProviderType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToServerCapabilities_renameProvider(
    const LSPAny &any
  ) const -> ServerCapabilities_renameProvider {
    ServerCapabilities_renameProvider value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::OBJECT_TYPE: {
      try {
        value = anyToRenameOptions(any);
      } catch (LspException &e) {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          "Failed to transform LSPAny to ServerCapabilities_renameProvider"
        );
      }
      break;
    }
    case LSPAnyType::BOOLEAN_TYPE: {
      value = anyToBoolean(any);
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) ServerCapabilities_renameProvider: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::serverCapabilities_renameProviderToAny(
    const ServerCapabilities_renameProvider &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<ServerCapabilities_renameProviderType>(variant.index())) {
    case ServerCapabilities_renameProviderType::BOOLEAN_TYPE: {
      return booleanToAny(
        std::get<boolean_t>(variant)
      );
    }
    case ServerCapabilities_renameProviderType::RENAME_OPTIONS: {
      return renameOptionsToAny(
        *std::get<std::unique_ptr<RenameOptions>>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported ServerCapabilities_renameProviderType: " +
         ServerCapabilities_renameProviderTypeNames.at(static_cast<ServerCapabilities_renameProviderType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToServerCapabilities_foldingRangeProvider(
    const LSPAny &any
  ) const -> ServerCapabilities_foldingRangeProvider {
    ServerCapabilities_foldingRangeProvider value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::OBJECT_TYPE: {
      try {
        value = anyToFoldingRangeOptions(any);
      } catch (LspException &e) {
        try {
          value = anyToFoldingRangeRegistrationOptions(any);
        } catch (LspException &e) {
          throw LSP_EXCEPTION(
            ErrorCodes::INVALID_PARAMS,
            "Failed to transform LSPAny to ServerCapabilities_foldingRangeProvider"
          );
        }
      }
      break;
    }
    case LSPAnyType::BOOLEAN_TYPE: {
      value = anyToBoolean(any);
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) ServerCapabilities_foldingRangeProvider: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::serverCapabilities_foldingRangeProviderToAny(
    const ServerCapabilities_foldingRangeProvider &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<ServerCapabilities_foldingRangeProviderType>(variant.index())) {
    case ServerCapabilities_foldingRangeProviderType::BOOLEAN_TYPE: {
      return booleanToAny(
        std::get<boolean_t>(variant)
      );
    }
    case ServerCapabilities_foldingRangeProviderType::FOLDING_RANGE_OPTIONS: {
      return foldingRangeOptionsToAny(
        *std::get<std::unique_ptr<FoldingRangeOptions>>(variant)
      );
    }
    case ServerCapabilities_foldingRangeProviderType::FOLDING_RANGE_REGISTRATION_OPTIONS: {
      return foldingRangeRegistrationOptionsToAny(
        *std::get<std::unique_ptr<FoldingRangeRegistrationOptions>>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported ServerCapabilities_foldingRangeProviderType: " +
         ServerCapabilities_foldingRangeProviderTypeNames.at(static_cast<ServerCapabilities_foldingRangeProviderType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToServerCapabilities_selectionRangeProvider(
    const LSPAny &any
  ) const -> ServerCapabilities_selectionRangeProvider {
    ServerCapabilities_selectionRangeProvider value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::OBJECT_TYPE: {
      try {
        value = anyToSelectionRangeOptions(any);
      } catch (LspException &e) {
        try {
          value = anyToSelectionRangeRegistrationOptions(any);
        } catch (LspException &e) {
          throw LSP_EXCEPTION(
            ErrorCodes::INVALID_PARAMS,
            "Failed to transform LSPAny to ServerCapabilities_selectionRangeProvider"
          );
        }
      }
      break;
    }
    case LSPAnyType::BOOLEAN_TYPE: {
      value = anyToBoolean(any);
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) ServerCapabilities_selectionRangeProvider: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::serverCapabilities_selectionRangeProviderToAny(
    const ServerCapabilities_selectionRangeProvider &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<ServerCapabilities_selectionRangeProviderType>(variant.index())) {
    case ServerCapabilities_selectionRangeProviderType::BOOLEAN_TYPE: {
      return booleanToAny(
        std::get<boolean_t>(variant)
      );
    }
    case ServerCapabilities_selectionRangeProviderType::SELECTION_RANGE_OPTIONS: {
      return selectionRangeOptionsToAny(
        *std::get<std::unique_ptr<SelectionRangeOptions>>(variant)
      );
    }
    case ServerCapabilities_selectionRangeProviderType::SELECTION_RANGE_REGISTRATION_OPTIONS: {
      return selectionRangeRegistrationOptionsToAny(
        *std::get<std::unique_ptr<SelectionRangeRegistrationOptions>>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported ServerCapabilities_selectionRangeProviderType: " +
         ServerCapabilities_selectionRangeProviderTypeNames.at(static_cast<ServerCapabilities_selectionRangeProviderType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToServerCapabilities_callHierarchyProvider(
    const LSPAny &any
  ) const -> ServerCapabilities_callHierarchyProvider {
    ServerCapabilities_callHierarchyProvider value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::OBJECT_TYPE: {
      try {
        value = anyToCallHierarchyOptions(any);
      } catch (LspException &e) {
        try {
          value = anyToCallHierarchyRegistrationOptions(any);
        } catch (LspException &e) {
          throw LSP_EXCEPTION(
            ErrorCodes::INVALID_PARAMS,
            "Failed to transform LSPAny to ServerCapabilities_callHierarchyProvider"
          );
        }
      }
      break;
    }
    case LSPAnyType::BOOLEAN_TYPE: {
      value = anyToBoolean(any);
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) ServerCapabilities_callHierarchyProvider: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::serverCapabilities_callHierarchyProviderToAny(
    const ServerCapabilities_callHierarchyProvider &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<ServerCapabilities_callHierarchyProviderType>(variant.index())) {
    case ServerCapabilities_callHierarchyProviderType::BOOLEAN_TYPE: {
      return booleanToAny(
        std::get<boolean_t>(variant)
      );
    }
    case ServerCapabilities_callHierarchyProviderType::CALL_HIERARCHY_OPTIONS: {
      return callHierarchyOptionsToAny(
        *std::get<std::unique_ptr<CallHierarchyOptions>>(variant)
      );
    }
    case ServerCapabilities_callHierarchyProviderType::CALL_HIERARCHY_REGISTRATION_OPTIONS: {
      return callHierarchyRegistrationOptionsToAny(
        *std::get<std::unique_ptr<CallHierarchyRegistrationOptions>>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported ServerCapabilities_callHierarchyProviderType: " +
         ServerCapabilities_callHierarchyProviderTypeNames.at(static_cast<ServerCapabilities_callHierarchyProviderType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToServerCapabilities_linkedEditingRangeProvider(
    const LSPAny &any
  ) const -> ServerCapabilities_linkedEditingRangeProvider {
    ServerCapabilities_linkedEditingRangeProvider value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::OBJECT_TYPE: {
      try {
        value = anyToLinkedEditingRangeOptions(any);
      } catch (LspException &e) {
        try {
          value = anyToLinkedEditingRangeRegistrationOptions(any);
        } catch (LspException &e) {
          throw LSP_EXCEPTION(
            ErrorCodes::INVALID_PARAMS,
            "Failed to transform LSPAny to ServerCapabilities_linkedEditingRangeProvider"
          );
        }
      }
      break;
    }
    case LSPAnyType::BOOLEAN_TYPE: {
      value = anyToBoolean(any);
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) ServerCapabilities_linkedEditingRangeProvider: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::serverCapabilities_linkedEditingRangeProviderToAny(
    const ServerCapabilities_linkedEditingRangeProvider &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<ServerCapabilities_linkedEditingRangeProviderType>(variant.index())) {
    case ServerCapabilities_linkedEditingRangeProviderType::BOOLEAN_TYPE: {
      return booleanToAny(
        std::get<boolean_t>(variant)
      );
    }
    case ServerCapabilities_linkedEditingRangeProviderType::LINKED_EDITING_RANGE_OPTIONS: {
      return linkedEditingRangeOptionsToAny(
        *std::get<std::unique_ptr<LinkedEditingRangeOptions>>(variant)
      );
    }
    case ServerCapabilities_linkedEditingRangeProviderType::LINKED_EDITING_RANGE_REGISTRATION_OPTIONS: {
      return linkedEditingRangeRegistrationOptionsToAny(
        *std::get<std::unique_ptr<LinkedEditingRangeRegistrationOptions>>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported ServerCapabilities_linkedEditingRangeProviderType: " +
         ServerCapabilities_linkedEditingRangeProviderTypeNames.at(static_cast<ServerCapabilities_linkedEditingRangeProviderType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToServerCapabilities_semanticTokensProvider(
    const LSPAny &any
  ) const -> ServerCapabilities_semanticTokensProvider {
    ServerCapabilities_semanticTokensProvider value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::OBJECT_TYPE: {
      try {
        value = anyToSemanticTokensOptions(any);
      } catch (LspException &e) {
        try {
          value = anyToSemanticTokensRegistrationOptions(any);
        } catch (LspException &e) {
          throw LSP_EXCEPTION(
            ErrorCodes::INVALID_PARAMS,
            "Failed to transform LSPAny to ServerCapabilities_semanticTokensProvider"
          );
        }
      }
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) ServerCapabilities_semanticTokensProvider: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::serverCapabilities_semanticTokensProviderToAny(
    const ServerCapabilities_semanticTokensProvider &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<ServerCapabilities_semanticTokensProviderType>(variant.index())) {
    case ServerCapabilities_semanticTokensProviderType::SEMANTIC_TOKENS_OPTIONS: {
      return semanticTokensOptionsToAny(
        *std::get<std::unique_ptr<SemanticTokensOptions>>(variant)
      );
    }
    case ServerCapabilities_semanticTokensProviderType::SEMANTIC_TOKENS_REGISTRATION_OPTIONS: {
      return semanticTokensRegistrationOptionsToAny(
        *std::get<std::unique_ptr<SemanticTokensRegistrationOptions>>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported ServerCapabilities_semanticTokensProviderType: " +
         ServerCapabilities_semanticTokensProviderTypeNames.at(static_cast<ServerCapabilities_semanticTokensProviderType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToServerCapabilities_monikerProvider(
    const LSPAny &any
  ) const -> ServerCapabilities_monikerProvider {
    ServerCapabilities_monikerProvider value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::OBJECT_TYPE: {
      try {
        value = anyToMonikerOptions(any);
      } catch (LspException &e) {
        try {
          value = anyToMonikerRegistrationOptions(any);
        } catch (LspException &e) {
          throw LSP_EXCEPTION(
            ErrorCodes::INVALID_PARAMS,
            "Failed to transform LSPAny to ServerCapabilities_monikerProvider"
          );
        }
      }
      break;
    }
    case LSPAnyType::BOOLEAN_TYPE: {
      value = anyToBoolean(any);
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) ServerCapabilities_monikerProvider: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::serverCapabilities_monikerProviderToAny(
    const ServerCapabilities_monikerProvider &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<ServerCapabilities_monikerProviderType>(variant.index())) {
    case ServerCapabilities_monikerProviderType::BOOLEAN_TYPE: {
      return booleanToAny(
        std::get<boolean_t>(variant)
      );
    }
    case ServerCapabilities_monikerProviderType::MONIKER_OPTIONS: {
      return monikerOptionsToAny(
        *std::get<std::unique_ptr<MonikerOptions>>(variant)
      );
    }
    case ServerCapabilities_monikerProviderType::MONIKER_REGISTRATION_OPTIONS: {
      return monikerRegistrationOptionsToAny(
        *std::get<std::unique_ptr<MonikerRegistrationOptions>>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported ServerCapabilities_monikerProviderType: " +
         ServerCapabilities_monikerProviderTypeNames.at(static_cast<ServerCapabilities_monikerProviderType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToServerCapabilities_typeHierarchyProvider(
    const LSPAny &any
  ) const -> ServerCapabilities_typeHierarchyProvider {
    ServerCapabilities_typeHierarchyProvider value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::OBJECT_TYPE: {
      try {
        value = anyToTypeHierarchyOptions(any);
      } catch (LspException &e) {
        try {
          value = anyToTypeHierarchyRegistrationOptions(any);
        } catch (LspException &e) {
          throw LSP_EXCEPTION(
            ErrorCodes::INVALID_PARAMS,
            "Failed to transform LSPAny to ServerCapabilities_typeHierarchyProvider"
          );
        }
      }
      break;
    }
    case LSPAnyType::BOOLEAN_TYPE: {
      value = anyToBoolean(any);
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) ServerCapabilities_typeHierarchyProvider: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::serverCapabilities_typeHierarchyProviderToAny(
    const ServerCapabilities_typeHierarchyProvider &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<ServerCapabilities_typeHierarchyProviderType>(variant.index())) {
    case ServerCapabilities_typeHierarchyProviderType::BOOLEAN_TYPE: {
      return booleanToAny(
        std::get<boolean_t>(variant)
      );
    }
    case ServerCapabilities_typeHierarchyProviderType::TYPE_HIERARCHY_OPTIONS: {
      return typeHierarchyOptionsToAny(
        *std::get<std::unique_ptr<TypeHierarchyOptions>>(variant)
      );
    }
    case ServerCapabilities_typeHierarchyProviderType::TYPE_HIERARCHY_REGISTRATION_OPTIONS: {
      return typeHierarchyRegistrationOptionsToAny(
        *std::get<std::unique_ptr<TypeHierarchyRegistrationOptions>>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported ServerCapabilities_typeHierarchyProviderType: " +
         ServerCapabilities_typeHierarchyProviderTypeNames.at(static_cast<ServerCapabilities_typeHierarchyProviderType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToServerCapabilities_inlineValueProvider(
    const LSPAny &any
  ) const -> ServerCapabilities_inlineValueProvider {
    ServerCapabilities_inlineValueProvider value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::OBJECT_TYPE: {
      try {
        value = anyToInlineValueOptions(any);
      } catch (LspException &e) {
        try {
          value = anyToInlineValueRegistrationOptions(any);
        } catch (LspException &e) {
          throw LSP_EXCEPTION(
            ErrorCodes::INVALID_PARAMS,
            "Failed to transform LSPAny to ServerCapabilities_inlineValueProvider"
          );
        }
      }
      break;
    }
    case LSPAnyType::BOOLEAN_TYPE: {
      value = anyToBoolean(any);
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) ServerCapabilities_inlineValueProvider: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::serverCapabilities_inlineValueProviderToAny(
    const ServerCapabilities_inlineValueProvider &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<ServerCapabilities_inlineValueProviderType>(variant.index())) {
    case ServerCapabilities_inlineValueProviderType::BOOLEAN_TYPE: {
      return booleanToAny(
        std::get<boolean_t>(variant)
      );
    }
    case ServerCapabilities_inlineValueProviderType::INLINE_VALUE_OPTIONS: {
      return inlineValueOptionsToAny(
        *std::get<std::unique_ptr<InlineValueOptions>>(variant)
      );
    }
    case ServerCapabilities_inlineValueProviderType::INLINE_VALUE_REGISTRATION_OPTIONS: {
      return inlineValueRegistrationOptionsToAny(
        *std::get<std::unique_ptr<InlineValueRegistrationOptions>>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported ServerCapabilities_inlineValueProviderType: " +
         ServerCapabilities_inlineValueProviderTypeNames.at(static_cast<ServerCapabilities_inlineValueProviderType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToServerCapabilities_inlayHintProvider(
    const LSPAny &any
  ) const -> ServerCapabilities_inlayHintProvider {
    ServerCapabilities_inlayHintProvider value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::OBJECT_TYPE: {
      try {
        value = anyToInlayHintOptions(any);
      } catch (LspException &e) {
        try {
          value = anyToInlayHintRegistrationOptions(any);
        } catch (LspException &e) {
          throw LSP_EXCEPTION(
            ErrorCodes::INVALID_PARAMS,
            "Failed to transform LSPAny to ServerCapabilities_inlayHintProvider"
          );
        }
      }
      break;
    }
    case LSPAnyType::BOOLEAN_TYPE: {
      value = anyToBoolean(any);
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) ServerCapabilities_inlayHintProvider: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::serverCapabilities_inlayHintProviderToAny(
    const ServerCapabilities_inlayHintProvider &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<ServerCapabilities_inlayHintProviderType>(variant.index())) {
    case ServerCapabilities_inlayHintProviderType::BOOLEAN_TYPE: {
      return booleanToAny(
        std::get<boolean_t>(variant)
      );
    }
    case ServerCapabilities_inlayHintProviderType::INLAY_HINT_OPTIONS: {
      return inlayHintOptionsToAny(
        *std::get<std::unique_ptr<InlayHintOptions>>(variant)
      );
    }
    case ServerCapabilities_inlayHintProviderType::INLAY_HINT_REGISTRATION_OPTIONS: {
      return inlayHintRegistrationOptionsToAny(
        *std::get<std::unique_ptr<InlayHintRegistrationOptions>>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported ServerCapabilities_inlayHintProviderType: " +
         ServerCapabilities_inlayHintProviderTypeNames.at(static_cast<ServerCapabilities_inlayHintProviderType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToServerCapabilities_diagnosticProvider(
    const LSPAny &any
  ) const -> ServerCapabilities_diagnosticProvider {
    ServerCapabilities_diagnosticProvider value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::OBJECT_TYPE: {
      try {
        value = anyToDiagnosticOptions(any);
      } catch (LspException &e) {
        try {
          value = anyToDiagnosticRegistrationOptions(any);
        } catch (LspException &e) {
          throw LSP_EXCEPTION(
            ErrorCodes::INVALID_PARAMS,
            "Failed to transform LSPAny to ServerCapabilities_diagnosticProvider"
          );
        }
      }
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) ServerCapabilities_diagnosticProvider: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::serverCapabilities_diagnosticProviderToAny(
    const ServerCapabilities_diagnosticProvider &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<ServerCapabilities_diagnosticProviderType>(variant.index())) {
    case ServerCapabilities_diagnosticProviderType::DIAGNOSTIC_OPTIONS: {
      return diagnosticOptionsToAny(
        *std::get<std::unique_ptr<DiagnosticOptions>>(variant)
      );
    }
    case ServerCapabilities_diagnosticProviderType::DIAGNOSTIC_REGISTRATION_OPTIONS: {
      return diagnosticRegistrationOptionsToAny(
        *std::get<std::unique_ptr<DiagnosticRegistrationOptions>>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported ServerCapabilities_diagnosticProviderType: " +
         ServerCapabilities_diagnosticProviderTypeNames.at(static_cast<ServerCapabilities_diagnosticProviderType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToServerCapabilities_inlineCompletionProvider(
    const LSPAny &any
  ) const -> ServerCapabilities_inlineCompletionProvider {
    ServerCapabilities_inlineCompletionProvider value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::OBJECT_TYPE: {
      try {
        value = anyToInlineCompletionOptions(any);
      } catch (LspException &e) {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          "Failed to transform LSPAny to ServerCapabilities_inlineCompletionProvider"
        );
      }
      break;
    }
    case LSPAnyType::BOOLEAN_TYPE: {
      value = anyToBoolean(any);
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) ServerCapabilities_inlineCompletionProvider: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::serverCapabilities_inlineCompletionProviderToAny(
    const ServerCapabilities_inlineCompletionProvider &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<ServerCapabilities_inlineCompletionProviderType>(variant.index())) {
    case ServerCapabilities_inlineCompletionProviderType::BOOLEAN_TYPE: {
      return booleanToAny(
        std::get<boolean_t>(variant)
      );
    }
    case ServerCapabilities_inlineCompletionProviderType::INLINE_COMPLETION_OPTIONS: {
      return inlineCompletionOptionsToAny(
        *std::get<std::unique_ptr<InlineCompletionOptions>>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported ServerCapabilities_inlineCompletionProviderType: " +
         ServerCapabilities_inlineCompletionProviderTypeNames.at(static_cast<ServerCapabilities_inlineCompletionProviderType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToServerCapabilities_workspace(
    const LSPAny &any
  ) const -> std::unique_ptr<ServerCapabilities_workspace> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) ServerCapabilities_workspace must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<ServerCapabilities_workspace> value =
      std::make_unique<ServerCapabilities_workspace>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) ServerCapabilities_workspace: " + std::to_string(object.size())
      );
    }

    iter = object.find("workspaceFolders");
    if (iter != object.end()) {
      value->workspaceFolders = anyToWorkspaceFoldersServerCapabilities(*iter->second);
    }

    iter = object.find("fileOperations");
    if (iter != object.end()) {
      value->fileOperations = anyToFileOperationOptions(*iter->second);
    }

    return value;
  }

  auto LspTransformer::serverCapabilities_workspaceToAny(
    const ServerCapabilities_workspace &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.workspaceFolders.has_value()) {
      object.emplace("workspaceFolders", workspaceFoldersServerCapabilitiesToAny(*structure.workspaceFolders.value()));
    }
    if (structure.fileOperations.has_value()) {
      object.emplace("fileOperations", fileOperationOptionsToAny(*structure.fileOperations.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToServerCapabilities(
    const LSPAny &any
  ) const -> std::unique_ptr<ServerCapabilities> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) ServerCapabilities must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<ServerCapabilities> value =
      std::make_unique<ServerCapabilities>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 36) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) ServerCapabilities: " + std::to_string(object.size())
      );
    }

    iter = object.find("positionEncoding");
    if (iter != object.end()) {
      value->positionEncoding = anyToPositionEncodingKind(*iter->second);
    }

    iter = object.find("textDocumentSync");
    if (iter != object.end()) {
      value->textDocumentSync = anyToServerCapabilities_textDocumentSync(*iter->second);
    }

    iter = object.find("notebookDocumentSync");
    if (iter != object.end()) {
      value->notebookDocumentSync = anyToServerCapabilities_notebookDocumentSync(*iter->second);
    }

    iter = object.find("completionProvider");
    if (iter != object.end()) {
      value->completionProvider = anyToCompletionOptions(*iter->second);
    }

    iter = object.find("hoverProvider");
    if (iter != object.end()) {
      value->hoverProvider = anyToServerCapabilities_hoverProvider(*iter->second);
    }

    iter = object.find("signatureHelpProvider");
    if (iter != object.end()) {
      value->signatureHelpProvider = anyToSignatureHelpOptions(*iter->second);
    }

    iter = object.find("declarationProvider");
    if (iter != object.end()) {
      value->declarationProvider = anyToServerCapabilities_declarationProvider(*iter->second);
    }

    iter = object.find("definitionProvider");
    if (iter != object.end()) {
      value->definitionProvider = anyToServerCapabilities_definitionProvider(*iter->second);
    }

    iter = object.find("typeDefinitionProvider");
    if (iter != object.end()) {
      value->typeDefinitionProvider = anyToServerCapabilities_typeDefinitionProvider(*iter->second);
    }

    iter = object.find("implementationProvider");
    if (iter != object.end()) {
      value->implementationProvider = anyToServerCapabilities_implementationProvider(*iter->second);
    }

    iter = object.find("referencesProvider");
    if (iter != object.end()) {
      value->referencesProvider = anyToServerCapabilities_referencesProvider(*iter->second);
    }

    iter = object.find("documentHighlightProvider");
    if (iter != object.end()) {
      value->documentHighlightProvider = anyToServerCapabilities_documentHighlightProvider(*iter->second);
    }

    iter = object.find("documentSymbolProvider");
    if (iter != object.end()) {
      value->documentSymbolProvider = anyToServerCapabilities_documentSymbolProvider(*iter->second);
    }

    iter = object.find("codeActionProvider");
    if (iter != object.end()) {
      value->codeActionProvider = anyToServerCapabilities_codeActionProvider(*iter->second);
    }

    iter = object.find("codeLensProvider");
    if (iter != object.end()) {
      value->codeLensProvider = anyToCodeLensOptions(*iter->second);
    }

    iter = object.find("documentLinkProvider");
    if (iter != object.end()) {
      value->documentLinkProvider = anyToDocumentLinkOptions(*iter->second);
    }

    iter = object.find("colorProvider");
    if (iter != object.end()) {
      value->colorProvider = anyToServerCapabilities_colorProvider(*iter->second);
    }

    iter = object.find("workspaceSymbolProvider");
    if (iter != object.end()) {
      value->workspaceSymbolProvider = anyToServerCapabilities_workspaceSymbolProvider(*iter->second);
    }

    iter = object.find("documentFormattingProvider");
    if (iter != object.end()) {
      value->documentFormattingProvider = anyToServerCapabilities_documentFormattingProvider(*iter->second);
    }

    iter = object.find("documentRangeFormattingProvider");
    if (iter != object.end()) {
      value->documentRangeFormattingProvider = anyToServerCapabilities_documentRangeFormattingProvider(*iter->second);
    }

    iter = object.find("documentOnTypeFormattingProvider");
    if (iter != object.end()) {
      value->documentOnTypeFormattingProvider = anyToDocumentOnTypeFormattingOptions(*iter->second);
    }

    iter = object.find("renameProvider");
    if (iter != object.end()) {
      value->renameProvider = anyToServerCapabilities_renameProvider(*iter->second);
    }

    iter = object.find("foldingRangeProvider");
    if (iter != object.end()) {
      value->foldingRangeProvider = anyToServerCapabilities_foldingRangeProvider(*iter->second);
    }

    iter = object.find("selectionRangeProvider");
    if (iter != object.end()) {
      value->selectionRangeProvider = anyToServerCapabilities_selectionRangeProvider(*iter->second);
    }

    iter = object.find("executeCommandProvider");
    if (iter != object.end()) {
      value->executeCommandProvider = anyToExecuteCommandOptions(*iter->second);
    }

    iter = object.find("callHierarchyProvider");
    if (iter != object.end()) {
      value->callHierarchyProvider = anyToServerCapabilities_callHierarchyProvider(*iter->second);
    }

    iter = object.find("linkedEditingRangeProvider");
    if (iter != object.end()) {
      value->linkedEditingRangeProvider = anyToServerCapabilities_linkedEditingRangeProvider(*iter->second);
    }

    iter = object.find("semanticTokensProvider");
    if (iter != object.end()) {
      value->semanticTokensProvider = anyToServerCapabilities_semanticTokensProvider(*iter->second);
    }

    iter = object.find("monikerProvider");
    if (iter != object.end()) {
      value->monikerProvider = anyToServerCapabilities_monikerProvider(*iter->second);
    }

    iter = object.find("typeHierarchyProvider");
    if (iter != object.end()) {
      value->typeHierarchyProvider = anyToServerCapabilities_typeHierarchyProvider(*iter->second);
    }

    iter = object.find("inlineValueProvider");
    if (iter != object.end()) {
      value->inlineValueProvider = anyToServerCapabilities_inlineValueProvider(*iter->second);
    }

    iter = object.find("inlayHintProvider");
    if (iter != object.end()) {
      value->inlayHintProvider = anyToServerCapabilities_inlayHintProvider(*iter->second);
    }

    iter = object.find("diagnosticProvider");
    if (iter != object.end()) {
      value->diagnosticProvider = anyToServerCapabilities_diagnosticProvider(*iter->second);
    }

    iter = object.find("inlineCompletionProvider");
    if (iter != object.end()) {
      value->inlineCompletionProvider = anyToServerCapabilities_inlineCompletionProvider(*iter->second);
    }

    iter = object.find("workspace");
    if (iter != object.end()) {
      value->workspace = anyToServerCapabilities_workspace(*iter->second);
    }

    iter = object.find("experimental");
    if (iter != object.end()) {
      value->experimental = copy(iter->second);
    }

    return value;
  }

  auto LspTransformer::serverCapabilitiesToAny(
    const ServerCapabilities &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.positionEncoding.has_value()) {
      object.emplace("positionEncoding", positionEncodingKindToAny(structure.positionEncoding.value()));
    }
    if (structure.textDocumentSync.has_value()) {
      object.emplace("textDocumentSync", serverCapabilities_textDocumentSyncToAny(structure.textDocumentSync.value()));
    }
    if (structure.notebookDocumentSync.has_value()) {
      object.emplace("notebookDocumentSync", serverCapabilities_notebookDocumentSyncToAny(structure.notebookDocumentSync.value()));
    }
    if (structure.completionProvider.has_value()) {
      object.emplace("completionProvider", completionOptionsToAny(*structure.completionProvider.value()));
    }
    if (structure.hoverProvider.has_value()) {
      object.emplace("hoverProvider", serverCapabilities_hoverProviderToAny(structure.hoverProvider.value()));
    }
    if (structure.signatureHelpProvider.has_value()) {
      object.emplace("signatureHelpProvider", signatureHelpOptionsToAny(*structure.signatureHelpProvider.value()));
    }
    if (structure.declarationProvider.has_value()) {
      object.emplace("declarationProvider", serverCapabilities_declarationProviderToAny(structure.declarationProvider.value()));
    }
    if (structure.definitionProvider.has_value()) {
      object.emplace("definitionProvider", serverCapabilities_definitionProviderToAny(structure.definitionProvider.value()));
    }
    if (structure.typeDefinitionProvider.has_value()) {
      object.emplace("typeDefinitionProvider", serverCapabilities_typeDefinitionProviderToAny(structure.typeDefinitionProvider.value()));
    }
    if (structure.implementationProvider.has_value()) {
      object.emplace("implementationProvider", serverCapabilities_implementationProviderToAny(structure.implementationProvider.value()));
    }
    if (structure.referencesProvider.has_value()) {
      object.emplace("referencesProvider", serverCapabilities_referencesProviderToAny(structure.referencesProvider.value()));
    }
    if (structure.documentHighlightProvider.has_value()) {
      object.emplace("documentHighlightProvider", serverCapabilities_documentHighlightProviderToAny(structure.documentHighlightProvider.value()));
    }
    if (structure.documentSymbolProvider.has_value()) {
      object.emplace("documentSymbolProvider", serverCapabilities_documentSymbolProviderToAny(structure.documentSymbolProvider.value()));
    }
    if (structure.codeActionProvider.has_value()) {
      object.emplace("codeActionProvider", serverCapabilities_codeActionProviderToAny(structure.codeActionProvider.value()));
    }
    if (structure.codeLensProvider.has_value()) {
      object.emplace("codeLensProvider", codeLensOptionsToAny(*structure.codeLensProvider.value()));
    }
    if (structure.documentLinkProvider.has_value()) {
      object.emplace("documentLinkProvider", documentLinkOptionsToAny(*structure.documentLinkProvider.value()));
    }
    if (structure.colorProvider.has_value()) {
      object.emplace("colorProvider", serverCapabilities_colorProviderToAny(structure.colorProvider.value()));
    }
    if (structure.workspaceSymbolProvider.has_value()) {
      object.emplace("workspaceSymbolProvider", serverCapabilities_workspaceSymbolProviderToAny(structure.workspaceSymbolProvider.value()));
    }
    if (structure.documentFormattingProvider.has_value()) {
      object.emplace("documentFormattingProvider", serverCapabilities_documentFormattingProviderToAny(structure.documentFormattingProvider.value()));
    }
    if (structure.documentRangeFormattingProvider.has_value()) {
      object.emplace("documentRangeFormattingProvider", serverCapabilities_documentRangeFormattingProviderToAny(structure.documentRangeFormattingProvider.value()));
    }
    if (structure.documentOnTypeFormattingProvider.has_value()) {
      object.emplace("documentOnTypeFormattingProvider", documentOnTypeFormattingOptionsToAny(*structure.documentOnTypeFormattingProvider.value()));
    }
    if (structure.renameProvider.has_value()) {
      object.emplace("renameProvider", serverCapabilities_renameProviderToAny(structure.renameProvider.value()));
    }
    if (structure.foldingRangeProvider.has_value()) {
      object.emplace("foldingRangeProvider", serverCapabilities_foldingRangeProviderToAny(structure.foldingRangeProvider.value()));
    }
    if (structure.selectionRangeProvider.has_value()) {
      object.emplace("selectionRangeProvider", serverCapabilities_selectionRangeProviderToAny(structure.selectionRangeProvider.value()));
    }
    if (structure.executeCommandProvider.has_value()) {
      object.emplace("executeCommandProvider", executeCommandOptionsToAny(*structure.executeCommandProvider.value()));
    }
    if (structure.callHierarchyProvider.has_value()) {
      object.emplace("callHierarchyProvider", serverCapabilities_callHierarchyProviderToAny(structure.callHierarchyProvider.value()));
    }
    if (structure.linkedEditingRangeProvider.has_value()) {
      object.emplace("linkedEditingRangeProvider", serverCapabilities_linkedEditingRangeProviderToAny(structure.linkedEditingRangeProvider.value()));
    }
    if (structure.semanticTokensProvider.has_value()) {
      object.emplace("semanticTokensProvider", serverCapabilities_semanticTokensProviderToAny(structure.semanticTokensProvider.value()));
    }
    if (structure.monikerProvider.has_value()) {
      object.emplace("monikerProvider", serverCapabilities_monikerProviderToAny(structure.monikerProvider.value()));
    }
    if (structure.typeHierarchyProvider.has_value()) {
      object.emplace("typeHierarchyProvider", serverCapabilities_typeHierarchyProviderToAny(structure.typeHierarchyProvider.value()));
    }
    if (structure.inlineValueProvider.has_value()) {
      object.emplace("inlineValueProvider", serverCapabilities_inlineValueProviderToAny(structure.inlineValueProvider.value()));
    }
    if (structure.inlayHintProvider.has_value()) {
      object.emplace("inlayHintProvider", serverCapabilities_inlayHintProviderToAny(structure.inlayHintProvider.value()));
    }
    if (structure.diagnosticProvider.has_value()) {
      object.emplace("diagnosticProvider", serverCapabilities_diagnosticProviderToAny(structure.diagnosticProvider.value()));
    }
    if (structure.inlineCompletionProvider.has_value()) {
      object.emplace("inlineCompletionProvider", serverCapabilities_inlineCompletionProviderToAny(structure.inlineCompletionProvider.value()));
    }
    if (structure.workspace.has_value()) {
      object.emplace("workspace", serverCapabilities_workspaceToAny(*structure.workspace.value()));
    }
    if (structure.experimental.has_value()) {
      object.emplace("experimental", copy(structure.experimental.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToVersionedTextDocumentIdentifier(
    const LSPAny &any
  ) const -> std::unique_ptr<VersionedTextDocumentIdentifier> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) VersionedTextDocumentIdentifier must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<VersionedTextDocumentIdentifier> value =
      std::make_unique<VersionedTextDocumentIdentifier>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) VersionedTextDocumentIdentifier: " + std::to_string(object.size())
      );
    }

    iter = object.find("version");
    if (iter != object.end()) {
      value->version = anyToInteger(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required VersionedTextDocumentIdentifier attribute: version"
      );
    }

    iter = object.find("uri");
    if (iter != object.end()) {
      value->uri = anyToDocumentUri(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required VersionedTextDocumentIdentifier attribute: uri"
      );
    }

    return value;
  }

  auto LspTransformer::versionedTextDocumentIdentifierToAny(
    const VersionedTextDocumentIdentifier &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("version", integerToAny(structure.version));
    object.emplace("uri", documentUriToAny(structure.uri));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToSaveOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<SaveOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) SaveOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<SaveOptions> value =
      std::make_unique<SaveOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) SaveOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("includeText");
    if (iter != object.end()) {
      value->includeText = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::saveOptionsToAny(
    const SaveOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.includeText.has_value()) {
      object.emplace("includeText", booleanToAny(structure.includeText.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToFileEvent(
    const LSPAny &any
  ) const -> std::unique_ptr<FileEvent> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) FileEvent must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<FileEvent> value =
      std::make_unique<FileEvent>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) FileEvent: " + std::to_string(object.size())
      );
    }

    iter = object.find("uri");
    if (iter != object.end()) {
      value->uri = anyToDocumentUri(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required FileEvent attribute: uri"
      );
    }

    iter = object.find("type");
    if (iter != object.end()) {
      value->type = anyToFileChangeType(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required FileEvent attribute: type"
      );
    }

    return value;
  }

  auto LspTransformer::fileEventToAny(
    const FileEvent &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("uri", documentUriToAny(structure.uri));
    object.emplace("type", fileChangeTypeToAny(structure.type));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToFileSystemWatcher(
    const LSPAny &any
  ) const -> std::unique_ptr<FileSystemWatcher> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) FileSystemWatcher must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<FileSystemWatcher> value =
      std::make_unique<FileSystemWatcher>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) FileSystemWatcher: " + std::to_string(object.size())
      );
    }

    iter = object.find("globPattern");
    if (iter != object.end()) {
      value->globPattern = anyToGlobPattern(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required FileSystemWatcher attribute: globPattern"
      );
    }

    iter = object.find("kind");
    if (iter != object.end()) {
      value->kind = anyToWatchKind(*iter->second);
    }

    return value;
  }

  auto LspTransformer::fileSystemWatcherToAny(
    const FileSystemWatcher &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("globPattern", globPatternToAny(structure.globPattern));
    if (structure.kind.has_value()) {
      object.emplace("kind", watchKindToAny(structure.kind.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToDiagnostic_code(
    const LSPAny &any
  ) const -> Diagnostic_code {
    Diagnostic_code value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::STRING_TYPE: {
      value = anyToString(any);
      break;
    }
    case LSPAnyType::INTEGER_TYPE: {
      value = anyToInteger(any);
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) Diagnostic_code: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::diagnostic_codeToAny(
    const Diagnostic_code &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<Diagnostic_codeType>(variant.index())) {
    case Diagnostic_codeType::INTEGER_TYPE: {
      return integerToAny(
        std::get<integer_t>(variant)
      );
    }
    case Diagnostic_codeType::STRING_TYPE: {
      return stringToAny(
        std::get<string_t>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported Diagnostic_codeType: " +
         Diagnostic_codeTypeNames.at(static_cast<Diagnostic_codeType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToDiagnostic(
    const LSPAny &any
  ) const -> std::unique_ptr<Diagnostic> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) Diagnostic must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<Diagnostic> value =
      std::make_unique<Diagnostic>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 9) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) Diagnostic: " + std::to_string(object.size())
      );
    }

    iter = object.find("range");
    if (iter != object.end()) {
      value->range = anyToRange(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required Diagnostic attribute: range"
      );
    }

    iter = object.find("severity");
    if (iter != object.end()) {
      value->severity = anyToDiagnosticSeverity(*iter->second);
    }

    iter = object.find("code");
    if (iter != object.end()) {
      value->code = anyToDiagnostic_code(*iter->second);
    }

    iter = object.find("codeDescription");
    if (iter != object.end()) {
      value->codeDescription = anyToCodeDescription(*iter->second);
    }

    iter = object.find("source");
    if (iter != object.end()) {
      value->source = anyToString(*iter->second);
    }

    iter = object.find("message");
    if (iter != object.end()) {
      value->message = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required Diagnostic attribute: message"
      );
    }

    iter = object.find("tags");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<DiagnosticTag> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToDiagnosticTag(*elem));
      }
      value->tags = std::move(values);
    }

    iter = object.find("relatedInformation");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<std::unique_ptr<DiagnosticRelatedInformation>> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToDiagnosticRelatedInformation(*elem));
      }
      value->relatedInformation = std::move(values);
    }

    iter = object.find("data");
    if (iter != object.end()) {
      value->data = copy(iter->second);
    }

    return value;
  }

  auto LspTransformer::diagnosticToAny(
    const Diagnostic &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("range", rangeToAny(*structure.range));
    if (structure.severity.has_value()) {
      object.emplace("severity", diagnosticSeverityToAny(structure.severity.value()));
    }
    if (structure.code.has_value()) {
      object.emplace("code", diagnostic_codeToAny(structure.code.value()));
    }
    if (structure.codeDescription.has_value()) {
      object.emplace("codeDescription", codeDescriptionToAny(*structure.codeDescription.value()));
    }
    if (structure.source.has_value()) {
      object.emplace("source", stringToAny(structure.source.value()));
    }
    object.emplace("message", stringToAny(structure.message));
    if (structure.tags.has_value()) {
      LSPArray array;
      for (const DiagnosticTag &elem : structure.tags.value()) {
        array.push_back(diagnosticTagToAny(elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("tags", std::move(any));
    }
    if (structure.relatedInformation.has_value()) {
      LSPArray array;
      for (const std::unique_ptr<DiagnosticRelatedInformation> &elem : structure.relatedInformation.value()) {
        array.push_back(diagnosticRelatedInformationToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("relatedInformation", std::move(any));
    }
    if (structure.data.has_value()) {
      object.emplace("data", copy(structure.data.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToCompletionContext(
    const LSPAny &any
  ) const -> std::unique_ptr<CompletionContext> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) CompletionContext must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<CompletionContext> value =
      std::make_unique<CompletionContext>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) CompletionContext: " + std::to_string(object.size())
      );
    }

    iter = object.find("triggerKind");
    if (iter != object.end()) {
      value->triggerKind = anyToCompletionTriggerKind(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required CompletionContext attribute: triggerKind"
      );
    }

    iter = object.find("triggerCharacter");
    if (iter != object.end()) {
      value->triggerCharacter = anyToString(*iter->second);
    }

    return value;
  }

  auto LspTransformer::completionContextToAny(
    const CompletionContext &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("triggerKind", completionTriggerKindToAny(structure.triggerKind));
    if (structure.triggerCharacter.has_value()) {
      object.emplace("triggerCharacter", stringToAny(structure.triggerCharacter.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToCompletionItemLabelDetails(
    const LSPAny &any
  ) const -> std::unique_ptr<CompletionItemLabelDetails> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) CompletionItemLabelDetails must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<CompletionItemLabelDetails> value =
      std::make_unique<CompletionItemLabelDetails>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) CompletionItemLabelDetails: " + std::to_string(object.size())
      );
    }

    iter = object.find("detail");
    if (iter != object.end()) {
      value->detail = anyToString(*iter->second);
    }

    iter = object.find("description");
    if (iter != object.end()) {
      value->description = anyToString(*iter->second);
    }

    return value;
  }

  auto LspTransformer::completionItemLabelDetailsToAny(
    const CompletionItemLabelDetails &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.detail.has_value()) {
      object.emplace("detail", stringToAny(structure.detail.value()));
    }
    if (structure.description.has_value()) {
      object.emplace("description", stringToAny(structure.description.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToInsertReplaceEdit(
    const LSPAny &any
  ) const -> std::unique_ptr<InsertReplaceEdit> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) InsertReplaceEdit must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<InsertReplaceEdit> value =
      std::make_unique<InsertReplaceEdit>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) InsertReplaceEdit: " + std::to_string(object.size())
      );
    }

    iter = object.find("newText");
    if (iter != object.end()) {
      value->newText = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required InsertReplaceEdit attribute: newText"
      );
    }

    iter = object.find("insert");
    if (iter != object.end()) {
      value->insert = anyToRange(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required InsertReplaceEdit attribute: insert"
      );
    }

    iter = object.find("replace");
    if (iter != object.end()) {
      value->replace = anyToRange(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required InsertReplaceEdit attribute: replace"
      );
    }

    return value;
  }

  auto LspTransformer::insertReplaceEditToAny(
    const InsertReplaceEdit &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("newText", stringToAny(structure.newText));
    object.emplace("insert", rangeToAny(*structure.insert));
    object.emplace("replace", rangeToAny(*structure.replace));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToCompletionOptions_completionItem(
    const LSPAny &any
  ) const -> std::unique_ptr<CompletionOptions_completionItem> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) CompletionOptions_completionItem must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<CompletionOptions_completionItem> value =
      std::make_unique<CompletionOptions_completionItem>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) CompletionOptions_completionItem: " + std::to_string(object.size())
      );
    }

    iter = object.find("labelDetailsSupport");
    if (iter != object.end()) {
      value->labelDetailsSupport = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::completionOptions_completionItemToAny(
    const CompletionOptions_completionItem &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.labelDetailsSupport.has_value()) {
      object.emplace("labelDetailsSupport", booleanToAny(structure.labelDetailsSupport.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToCompletionOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<CompletionOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) CompletionOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<CompletionOptions> value =
      std::make_unique<CompletionOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 5) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) CompletionOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("triggerCharacters");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<string_t> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToString(*elem));
      }
      value->triggerCharacters = std::move(values);
    }

    iter = object.find("allCommitCharacters");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<string_t> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToString(*elem));
      }
      value->allCommitCharacters = std::move(values);
    }

    iter = object.find("resolveProvider");
    if (iter != object.end()) {
      value->resolveProvider = anyToBoolean(*iter->second);
    }

    iter = object.find("completionItem");
    if (iter != object.end()) {
      value->completionItem = anyToCompletionOptions_completionItem(*iter->second);
    }

    iter = object.find("workDoneProgress");
    if (iter != object.end()) {
      value->workDoneProgress = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::completionOptionsToAny(
    const CompletionOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.triggerCharacters.has_value()) {
      LSPArray array;
      for (const string_t &elem : structure.triggerCharacters.value()) {
        array.push_back(stringToAny(elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("triggerCharacters", std::move(any));
    }
    if (structure.allCommitCharacters.has_value()) {
      LSPArray array;
      for (const string_t &elem : structure.allCommitCharacters.value()) {
        array.push_back(stringToAny(elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("allCommitCharacters", std::move(any));
    }
    if (structure.resolveProvider.has_value()) {
      object.emplace("resolveProvider", booleanToAny(structure.resolveProvider.value()));
    }
    if (structure.completionItem.has_value()) {
      object.emplace("completionItem", completionOptions_completionItemToAny(*structure.completionItem.value()));
    }
    if (structure.workDoneProgress.has_value()) {
      object.emplace("workDoneProgress", booleanToAny(structure.workDoneProgress.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToHoverOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<HoverOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) HoverOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<HoverOptions> value =
      std::make_unique<HoverOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) HoverOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("workDoneProgress");
    if (iter != object.end()) {
      value->workDoneProgress = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::hoverOptionsToAny(
    const HoverOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.workDoneProgress.has_value()) {
      object.emplace("workDoneProgress", booleanToAny(structure.workDoneProgress.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToSignatureHelpContext(
    const LSPAny &any
  ) const -> std::unique_ptr<SignatureHelpContext> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) SignatureHelpContext must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<SignatureHelpContext> value =
      std::make_unique<SignatureHelpContext>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 4) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) SignatureHelpContext: " + std::to_string(object.size())
      );
    }

    iter = object.find("triggerKind");
    if (iter != object.end()) {
      value->triggerKind = anyToSignatureHelpTriggerKind(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required SignatureHelpContext attribute: triggerKind"
      );
    }

    iter = object.find("triggerCharacter");
    if (iter != object.end()) {
      value->triggerCharacter = anyToString(*iter->second);
    }

    iter = object.find("isRetrigger");
    if (iter != object.end()) {
      value->isRetrigger = anyToBoolean(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required SignatureHelpContext attribute: isRetrigger"
      );
    }

    iter = object.find("activeSignatureHelp");
    if (iter != object.end()) {
      value->activeSignatureHelp = anyToSignatureHelp(*iter->second);
    }

    return value;
  }

  auto LspTransformer::signatureHelpContextToAny(
    const SignatureHelpContext &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("triggerKind", signatureHelpTriggerKindToAny(structure.triggerKind));
    if (structure.triggerCharacter.has_value()) {
      object.emplace("triggerCharacter", stringToAny(structure.triggerCharacter.value()));
    }
    object.emplace("isRetrigger", booleanToAny(structure.isRetrigger));
    if (structure.activeSignatureHelp.has_value()) {
      object.emplace("activeSignatureHelp", signatureHelpToAny(*structure.activeSignatureHelp.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToSignatureInformation_documentation(
    const LSPAny &any
  ) const -> SignatureInformation_documentation {
    SignatureInformation_documentation value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::OBJECT_TYPE: {
      try {
        value = anyToMarkupContent(any);
      } catch (LspException &e) {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          "Failed to transform LSPAny to SignatureInformation_documentation"
        );
      }
      break;
    }
    case LSPAnyType::STRING_TYPE: {
      value = anyToString(any);
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) SignatureInformation_documentation: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::signatureInformation_documentationToAny(
    const SignatureInformation_documentation &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<SignatureInformation_documentationType>(variant.index())) {
    case SignatureInformation_documentationType::STRING_TYPE: {
      return stringToAny(
        std::get<string_t>(variant)
      );
    }
    case SignatureInformation_documentationType::MARKUP_CONTENT: {
      return markupContentToAny(
        *std::get<std::unique_ptr<MarkupContent>>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported SignatureInformation_documentationType: " +
         SignatureInformation_documentationTypeNames.at(static_cast<SignatureInformation_documentationType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToSignatureInformation(
    const LSPAny &any
  ) const -> std::unique_ptr<SignatureInformation> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) SignatureInformation must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<SignatureInformation> value =
      std::make_unique<SignatureInformation>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 4) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) SignatureInformation: " + std::to_string(object.size())
      );
    }

    iter = object.find("label");
    if (iter != object.end()) {
      value->label = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required SignatureInformation attribute: label"
      );
    }

    iter = object.find("documentation");
    if (iter != object.end()) {
      value->documentation = anyToSignatureInformation_documentation(*iter->second);
    }

    iter = object.find("parameters");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<std::unique_ptr<ParameterInformation>> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToParameterInformation(*elem));
      }
      value->parameters = std::move(values);
    }

    iter = object.find("activeParameter");
    if (iter != object.end()) {
      value->activeParameter = anyToUInteger(*iter->second);
    }

    return value;
  }

  auto LspTransformer::signatureInformationToAny(
    const SignatureInformation &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("label", stringToAny(structure.label));
    if (structure.documentation.has_value()) {
      object.emplace("documentation", signatureInformation_documentationToAny(structure.documentation.value()));
    }
    if (structure.parameters.has_value()) {
      LSPArray array;
      for (const std::unique_ptr<ParameterInformation> &elem : structure.parameters.value()) {
        array.push_back(parameterInformationToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("parameters", std::move(any));
    }
    if (structure.activeParameter.has_value()) {
      object.emplace("activeParameter", uintegerToAny(structure.activeParameter.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToSignatureHelpOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<SignatureHelpOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) SignatureHelpOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<SignatureHelpOptions> value =
      std::make_unique<SignatureHelpOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) SignatureHelpOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("triggerCharacters");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<string_t> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToString(*elem));
      }
      value->triggerCharacters = std::move(values);
    }

    iter = object.find("retriggerCharacters");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<string_t> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToString(*elem));
      }
      value->retriggerCharacters = std::move(values);
    }

    iter = object.find("workDoneProgress");
    if (iter != object.end()) {
      value->workDoneProgress = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::signatureHelpOptionsToAny(
    const SignatureHelpOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.triggerCharacters.has_value()) {
      LSPArray array;
      for (const string_t &elem : structure.triggerCharacters.value()) {
        array.push_back(stringToAny(elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("triggerCharacters", std::move(any));
    }
    if (structure.retriggerCharacters.has_value()) {
      LSPArray array;
      for (const string_t &elem : structure.retriggerCharacters.value()) {
        array.push_back(stringToAny(elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("retriggerCharacters", std::move(any));
    }
    if (structure.workDoneProgress.has_value()) {
      object.emplace("workDoneProgress", booleanToAny(structure.workDoneProgress.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToDefinitionOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<DefinitionOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) DefinitionOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<DefinitionOptions> value =
      std::make_unique<DefinitionOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) DefinitionOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("workDoneProgress");
    if (iter != object.end()) {
      value->workDoneProgress = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::definitionOptionsToAny(
    const DefinitionOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.workDoneProgress.has_value()) {
      object.emplace("workDoneProgress", booleanToAny(structure.workDoneProgress.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToReferenceContext(
    const LSPAny &any
  ) const -> std::unique_ptr<ReferenceContext> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) ReferenceContext must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<ReferenceContext> value =
      std::make_unique<ReferenceContext>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) ReferenceContext: " + std::to_string(object.size())
      );
    }

    iter = object.find("includeDeclaration");
    if (iter != object.end()) {
      value->includeDeclaration = anyToBoolean(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required ReferenceContext attribute: includeDeclaration"
      );
    }

    return value;
  }

  auto LspTransformer::referenceContextToAny(
    const ReferenceContext &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("includeDeclaration", booleanToAny(structure.includeDeclaration));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToReferenceOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<ReferenceOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) ReferenceOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<ReferenceOptions> value =
      std::make_unique<ReferenceOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) ReferenceOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("workDoneProgress");
    if (iter != object.end()) {
      value->workDoneProgress = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::referenceOptionsToAny(
    const ReferenceOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.workDoneProgress.has_value()) {
      object.emplace("workDoneProgress", booleanToAny(structure.workDoneProgress.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToDocumentHighlightOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<DocumentHighlightOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) DocumentHighlightOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<DocumentHighlightOptions> value =
      std::make_unique<DocumentHighlightOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) DocumentHighlightOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("workDoneProgress");
    if (iter != object.end()) {
      value->workDoneProgress = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::documentHighlightOptionsToAny(
    const DocumentHighlightOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.workDoneProgress.has_value()) {
      object.emplace("workDoneProgress", booleanToAny(structure.workDoneProgress.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToBaseSymbolInformation(
    const LSPAny &any
  ) const -> std::unique_ptr<BaseSymbolInformation> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) BaseSymbolInformation must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<BaseSymbolInformation> value =
      std::make_unique<BaseSymbolInformation>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 4) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) BaseSymbolInformation: " + std::to_string(object.size())
      );
    }

    iter = object.find("name");
    if (iter != object.end()) {
      value->name = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required BaseSymbolInformation attribute: name"
      );
    }

    iter = object.find("kind");
    if (iter != object.end()) {
      value->kind = anyToSymbolKind(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required BaseSymbolInformation attribute: kind"
      );
    }

    iter = object.find("tags");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<SymbolTag> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToSymbolTag(*elem));
      }
      value->tags = std::move(values);
    }

    iter = object.find("containerName");
    if (iter != object.end()) {
      value->containerName = anyToString(*iter->second);
    }

    return value;
  }

  auto LspTransformer::baseSymbolInformationToAny(
    const BaseSymbolInformation &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("name", stringToAny(structure.name));
    object.emplace("kind", symbolKindToAny(structure.kind));
    if (structure.tags.has_value()) {
      LSPArray array;
      for (const SymbolTag &elem : structure.tags.value()) {
        array.push_back(symbolTagToAny(elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("tags", std::move(any));
    }
    if (structure.containerName.has_value()) {
      object.emplace("containerName", stringToAny(structure.containerName.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToDocumentSymbolOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<DocumentSymbolOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) DocumentSymbolOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<DocumentSymbolOptions> value =
      std::make_unique<DocumentSymbolOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) DocumentSymbolOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("label");
    if (iter != object.end()) {
      value->label = anyToString(*iter->second);
    }

    iter = object.find("workDoneProgress");
    if (iter != object.end()) {
      value->workDoneProgress = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::documentSymbolOptionsToAny(
    const DocumentSymbolOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.label.has_value()) {
      object.emplace("label", stringToAny(structure.label.value()));
    }
    if (structure.workDoneProgress.has_value()) {
      object.emplace("workDoneProgress", booleanToAny(structure.workDoneProgress.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToCodeActionContext(
    const LSPAny &any
  ) const -> std::unique_ptr<CodeActionContext> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) CodeActionContext must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<CodeActionContext> value =
      std::make_unique<CodeActionContext>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) CodeActionContext: " + std::to_string(object.size())
      );
    }

    iter = object.find("diagnostics");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<std::unique_ptr<Diagnostic>> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToDiagnostic(*elem));
      }
      value->diagnostics = std::move(values);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required CodeActionContext attribute: diagnostics"
      );
    }

    iter = object.find("only");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<CodeActionKind> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToCodeActionKind(*elem));
      }
      value->only = std::move(values);
    }

    iter = object.find("triggerKind");
    if (iter != object.end()) {
      value->triggerKind = anyToCodeActionTriggerKind(*iter->second);
    }

    return value;
  }

  auto LspTransformer::codeActionContextToAny(
    const CodeActionContext &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    {
      LSPArray array;
      for (const std::unique_ptr<Diagnostic> &elem : structure.diagnostics) {
        array.push_back(diagnosticToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("diagnostics", std::move(any));
    }
    if (structure.only.has_value()) {
      LSPArray array;
      for (const CodeActionKind &elem : structure.only.value()) {
        array.push_back(codeActionKindToAny(elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("only", std::move(any));
    }
    if (structure.triggerKind.has_value()) {
      object.emplace("triggerKind", codeActionTriggerKindToAny(structure.triggerKind.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToCodeActionOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<CodeActionOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) CodeActionOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<CodeActionOptions> value =
      std::make_unique<CodeActionOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) CodeActionOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("codeActionKinds");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<CodeActionKind> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToCodeActionKind(*elem));
      }
      value->codeActionKinds = std::move(values);
    }

    iter = object.find("resolveProvider");
    if (iter != object.end()) {
      value->resolveProvider = anyToBoolean(*iter->second);
    }

    iter = object.find("workDoneProgress");
    if (iter != object.end()) {
      value->workDoneProgress = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::codeActionOptionsToAny(
    const CodeActionOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.codeActionKinds.has_value()) {
      LSPArray array;
      for (const CodeActionKind &elem : structure.codeActionKinds.value()) {
        array.push_back(codeActionKindToAny(elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("codeActionKinds", std::move(any));
    }
    if (structure.resolveProvider.has_value()) {
      object.emplace("resolveProvider", booleanToAny(structure.resolveProvider.value()));
    }
    if (structure.workDoneProgress.has_value()) {
      object.emplace("workDoneProgress", booleanToAny(structure.workDoneProgress.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToWorkspaceSymbolOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<WorkspaceSymbolOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) WorkspaceSymbolOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<WorkspaceSymbolOptions> value =
      std::make_unique<WorkspaceSymbolOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) WorkspaceSymbolOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("resolveProvider");
    if (iter != object.end()) {
      value->resolveProvider = anyToBoolean(*iter->second);
    }

    iter = object.find("workDoneProgress");
    if (iter != object.end()) {
      value->workDoneProgress = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::workspaceSymbolOptionsToAny(
    const WorkspaceSymbolOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.resolveProvider.has_value()) {
      object.emplace("resolveProvider", booleanToAny(structure.resolveProvider.value()));
    }
    if (structure.workDoneProgress.has_value()) {
      object.emplace("workDoneProgress", booleanToAny(structure.workDoneProgress.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToCodeLensOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<CodeLensOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) CodeLensOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<CodeLensOptions> value =
      std::make_unique<CodeLensOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) CodeLensOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("resolveProvider");
    if (iter != object.end()) {
      value->resolveProvider = anyToBoolean(*iter->second);
    }

    iter = object.find("workDoneProgress");
    if (iter != object.end()) {
      value->workDoneProgress = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::codeLensOptionsToAny(
    const CodeLensOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.resolveProvider.has_value()) {
      object.emplace("resolveProvider", booleanToAny(structure.resolveProvider.value()));
    }
    if (structure.workDoneProgress.has_value()) {
      object.emplace("workDoneProgress", booleanToAny(structure.workDoneProgress.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToDocumentLinkOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<DocumentLinkOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) DocumentLinkOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<DocumentLinkOptions> value =
      std::make_unique<DocumentLinkOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) DocumentLinkOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("resolveProvider");
    if (iter != object.end()) {
      value->resolveProvider = anyToBoolean(*iter->second);
    }

    iter = object.find("workDoneProgress");
    if (iter != object.end()) {
      value->workDoneProgress = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::documentLinkOptionsToAny(
    const DocumentLinkOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.resolveProvider.has_value()) {
      object.emplace("resolveProvider", booleanToAny(structure.resolveProvider.value()));
    }
    if (structure.workDoneProgress.has_value()) {
      object.emplace("workDoneProgress", booleanToAny(structure.workDoneProgress.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToFormattingOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<FormattingOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) FormattingOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<FormattingOptions> value =
      std::make_unique<FormattingOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 5) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) FormattingOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("tabSize");
    if (iter != object.end()) {
      value->tabSize = anyToUInteger(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required FormattingOptions attribute: tabSize"
      );
    }

    iter = object.find("insertSpaces");
    if (iter != object.end()) {
      value->insertSpaces = anyToBoolean(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required FormattingOptions attribute: insertSpaces"
      );
    }

    iter = object.find("trimTrailingWhitespace");
    if (iter != object.end()) {
      value->trimTrailingWhitespace = anyToBoolean(*iter->second);
    }

    iter = object.find("insertFinalNewline");
    if (iter != object.end()) {
      value->insertFinalNewline = anyToBoolean(*iter->second);
    }

    iter = object.find("trimFinalNewlines");
    if (iter != object.end()) {
      value->trimFinalNewlines = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::formattingOptionsToAny(
    const FormattingOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("tabSize", uintegerToAny(structure.tabSize));
    object.emplace("insertSpaces", booleanToAny(structure.insertSpaces));
    if (structure.trimTrailingWhitespace.has_value()) {
      object.emplace("trimTrailingWhitespace", booleanToAny(structure.trimTrailingWhitespace.value()));
    }
    if (structure.insertFinalNewline.has_value()) {
      object.emplace("insertFinalNewline", booleanToAny(structure.insertFinalNewline.value()));
    }
    if (structure.trimFinalNewlines.has_value()) {
      object.emplace("trimFinalNewlines", booleanToAny(structure.trimFinalNewlines.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToDocumentFormattingOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<DocumentFormattingOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) DocumentFormattingOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<DocumentFormattingOptions> value =
      std::make_unique<DocumentFormattingOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) DocumentFormattingOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("workDoneProgress");
    if (iter != object.end()) {
      value->workDoneProgress = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::documentFormattingOptionsToAny(
    const DocumentFormattingOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.workDoneProgress.has_value()) {
      object.emplace("workDoneProgress", booleanToAny(structure.workDoneProgress.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToDocumentRangeFormattingOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<DocumentRangeFormattingOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) DocumentRangeFormattingOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<DocumentRangeFormattingOptions> value =
      std::make_unique<DocumentRangeFormattingOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) DocumentRangeFormattingOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("rangesSupport");
    if (iter != object.end()) {
      value->rangesSupport = anyToBoolean(*iter->second);
    }

    iter = object.find("workDoneProgress");
    if (iter != object.end()) {
      value->workDoneProgress = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::documentRangeFormattingOptionsToAny(
    const DocumentRangeFormattingOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.rangesSupport.has_value()) {
      object.emplace("rangesSupport", booleanToAny(structure.rangesSupport.value()));
    }
    if (structure.workDoneProgress.has_value()) {
      object.emplace("workDoneProgress", booleanToAny(structure.workDoneProgress.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToDocumentOnTypeFormattingOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<DocumentOnTypeFormattingOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) DocumentOnTypeFormattingOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<DocumentOnTypeFormattingOptions> value =
      std::make_unique<DocumentOnTypeFormattingOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) DocumentOnTypeFormattingOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("firstTriggerCharacter");
    if (iter != object.end()) {
      value->firstTriggerCharacter = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DocumentOnTypeFormattingOptions attribute: firstTriggerCharacter"
      );
    }

    iter = object.find("moreTriggerCharacter");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<string_t> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToString(*elem));
      }
      value->moreTriggerCharacter = std::move(values);
    }

    return value;
  }

  auto LspTransformer::documentOnTypeFormattingOptionsToAny(
    const DocumentOnTypeFormattingOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("firstTriggerCharacter", stringToAny(structure.firstTriggerCharacter));
    if (structure.moreTriggerCharacter.has_value()) {
      LSPArray array;
      for (const string_t &elem : structure.moreTriggerCharacter.value()) {
        array.push_back(stringToAny(elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("moreTriggerCharacter", std::move(any));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToRenameOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<RenameOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) RenameOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<RenameOptions> value =
      std::make_unique<RenameOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) RenameOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("prepareProvider");
    if (iter != object.end()) {
      value->prepareProvider = anyToBoolean(*iter->second);
    }

    iter = object.find("workDoneProgress");
    if (iter != object.end()) {
      value->workDoneProgress = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::renameOptionsToAny(
    const RenameOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.prepareProvider.has_value()) {
      object.emplace("prepareProvider", booleanToAny(structure.prepareProvider.value()));
    }
    if (structure.workDoneProgress.has_value()) {
      object.emplace("workDoneProgress", booleanToAny(structure.workDoneProgress.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToExecuteCommandOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<ExecuteCommandOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) ExecuteCommandOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<ExecuteCommandOptions> value =
      std::make_unique<ExecuteCommandOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) ExecuteCommandOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("commands");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<string_t> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToString(*elem));
      }
      value->commands = std::move(values);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required ExecuteCommandOptions attribute: commands"
      );
    }

    iter = object.find("workDoneProgress");
    if (iter != object.end()) {
      value->workDoneProgress = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::executeCommandOptionsToAny(
    const ExecuteCommandOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    {
      LSPArray array;
      for (const string_t &elem : structure.commands) {
        array.push_back(stringToAny(elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("commands", std::move(any));
    }
    if (structure.workDoneProgress.has_value()) {
      object.emplace("workDoneProgress", booleanToAny(structure.workDoneProgress.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToSemanticTokensLegend(
    const LSPAny &any
  ) const -> std::unique_ptr<SemanticTokensLegend> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) SemanticTokensLegend must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<SemanticTokensLegend> value =
      std::make_unique<SemanticTokensLegend>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) SemanticTokensLegend: " + std::to_string(object.size())
      );
    }

    iter = object.find("tokenTypes");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<string_t> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToString(*elem));
      }
      value->tokenTypes = std::move(values);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required SemanticTokensLegend attribute: tokenTypes"
      );
    }

    iter = object.find("tokenModifiers");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<string_t> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToString(*elem));
      }
      value->tokenModifiers = std::move(values);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required SemanticTokensLegend attribute: tokenModifiers"
      );
    }

    return value;
  }

  auto LspTransformer::semanticTokensLegendToAny(
    const SemanticTokensLegend &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    {
      LSPArray array;
      for (const string_t &elem : structure.tokenTypes) {
        array.push_back(stringToAny(elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("tokenTypes", std::move(any));
    }
    {
      LSPArray array;
      for (const string_t &elem : structure.tokenModifiers) {
        array.push_back(stringToAny(elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("tokenModifiers", std::move(any));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToOptionalVersionedTextDocumentIdentifier_version(
    const LSPAny &any
  ) const -> OptionalVersionedTextDocumentIdentifier_version {
    OptionalVersionedTextDocumentIdentifier_version value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::INTEGER_TYPE: {
      value = anyToInteger(any);
      break;
    }
    case LSPAnyType::NULL_TYPE: {
      value = anyToNull(any);
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) OptionalVersionedTextDocumentIdentifier_version: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::optionalVersionedTextDocumentIdentifier_versionToAny(
    const OptionalVersionedTextDocumentIdentifier_version &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<OptionalVersionedTextDocumentIdentifier_versionType>(variant.index())) {
    case OptionalVersionedTextDocumentIdentifier_versionType::INTEGER_TYPE: {
      return integerToAny(
        std::get<integer_t>(variant)
      );
    }
    case OptionalVersionedTextDocumentIdentifier_versionType::NULL_TYPE: {
      return nullToAny(
        std::get<null_t>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported OptionalVersionedTextDocumentIdentifier_versionType: " +
         OptionalVersionedTextDocumentIdentifier_versionTypeNames.at(static_cast<OptionalVersionedTextDocumentIdentifier_versionType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToOptionalVersionedTextDocumentIdentifier(
    const LSPAny &any
  ) const -> std::unique_ptr<OptionalVersionedTextDocumentIdentifier> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) OptionalVersionedTextDocumentIdentifier must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<OptionalVersionedTextDocumentIdentifier> value =
      std::make_unique<OptionalVersionedTextDocumentIdentifier>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) OptionalVersionedTextDocumentIdentifier: " + std::to_string(object.size())
      );
    }

    iter = object.find("version");
    if (iter != object.end()) {
      value->version = anyToOptionalVersionedTextDocumentIdentifier_version(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required OptionalVersionedTextDocumentIdentifier attribute: version"
      );
    }

    iter = object.find("uri");
    if (iter != object.end()) {
      value->uri = anyToDocumentUri(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required OptionalVersionedTextDocumentIdentifier attribute: uri"
      );
    }

    return value;
  }

  auto LspTransformer::optionalVersionedTextDocumentIdentifierToAny(
    const OptionalVersionedTextDocumentIdentifier &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("version", optionalVersionedTextDocumentIdentifier_versionToAny(structure.version));
    object.emplace("uri", documentUriToAny(structure.uri));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToAnnotatedTextEdit(
    const LSPAny &any
  ) const -> std::unique_ptr<AnnotatedTextEdit> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) AnnotatedTextEdit must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<AnnotatedTextEdit> value =
      std::make_unique<AnnotatedTextEdit>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) AnnotatedTextEdit: " + std::to_string(object.size())
      );
    }

    iter = object.find("annotationId");
    if (iter != object.end()) {
      value->annotationId = anyToChangeAnnotationIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required AnnotatedTextEdit attribute: annotationId"
      );
    }

    iter = object.find("range");
    if (iter != object.end()) {
      value->range = anyToRange(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required AnnotatedTextEdit attribute: range"
      );
    }

    iter = object.find("newText");
    if (iter != object.end()) {
      value->newText = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required AnnotatedTextEdit attribute: newText"
      );
    }

    return value;
  }

  auto LspTransformer::annotatedTextEditToAny(
    const AnnotatedTextEdit &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("annotationId", changeAnnotationIdentifierToAny(structure.annotationId));
    object.emplace("range", rangeToAny(*structure.range));
    object.emplace("newText", stringToAny(structure.newText));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToResourceOperation(
    const LSPAny &any
  ) const -> std::unique_ptr<ResourceOperation> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) ResourceOperation must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<ResourceOperation> value =
      std::make_unique<ResourceOperation>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) ResourceOperation: " + std::to_string(object.size())
      );
    }

    iter = object.find("kind");
    if (iter != object.end()) {
      value->kind = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required ResourceOperation attribute: kind"
      );
    }

    iter = object.find("annotationId");
    if (iter != object.end()) {
      value->annotationId = anyToChangeAnnotationIdentifier(*iter->second);
    }

    return value;
  }

  auto LspTransformer::resourceOperationToAny(
    const ResourceOperation &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("kind", stringToAny(structure.kind));
    if (structure.annotationId.has_value()) {
      object.emplace("annotationId", changeAnnotationIdentifierToAny(structure.annotationId.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToCreateFileOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<CreateFileOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) CreateFileOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<CreateFileOptions> value =
      std::make_unique<CreateFileOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) CreateFileOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("overwrite");
    if (iter != object.end()) {
      value->overwrite = anyToBoolean(*iter->second);
    }

    iter = object.find("ignoreIfExists");
    if (iter != object.end()) {
      value->ignoreIfExists = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::createFileOptionsToAny(
    const CreateFileOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.overwrite.has_value()) {
      object.emplace("overwrite", booleanToAny(structure.overwrite.value()));
    }
    if (structure.ignoreIfExists.has_value()) {
      object.emplace("ignoreIfExists", booleanToAny(structure.ignoreIfExists.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToRenameFileOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<RenameFileOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) RenameFileOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<RenameFileOptions> value =
      std::make_unique<RenameFileOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) RenameFileOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("overwrite");
    if (iter != object.end()) {
      value->overwrite = anyToBoolean(*iter->second);
    }

    iter = object.find("ignoreIfExists");
    if (iter != object.end()) {
      value->ignoreIfExists = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::renameFileOptionsToAny(
    const RenameFileOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.overwrite.has_value()) {
      object.emplace("overwrite", booleanToAny(structure.overwrite.value()));
    }
    if (structure.ignoreIfExists.has_value()) {
      object.emplace("ignoreIfExists", booleanToAny(structure.ignoreIfExists.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToDeleteFileOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<DeleteFileOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) DeleteFileOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<DeleteFileOptions> value =
      std::make_unique<DeleteFileOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) DeleteFileOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("recursive");
    if (iter != object.end()) {
      value->recursive = anyToBoolean(*iter->second);
    }

    iter = object.find("ignoreIfNotExists");
    if (iter != object.end()) {
      value->ignoreIfNotExists = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::deleteFileOptionsToAny(
    const DeleteFileOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.recursive.has_value()) {
      object.emplace("recursive", booleanToAny(structure.recursive.value()));
    }
    if (structure.ignoreIfNotExists.has_value()) {
      object.emplace("ignoreIfNotExists", booleanToAny(structure.ignoreIfNotExists.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToFileOperationPattern(
    const LSPAny &any
  ) const -> std::unique_ptr<FileOperationPattern> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) FileOperationPattern must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<FileOperationPattern> value =
      std::make_unique<FileOperationPattern>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) FileOperationPattern: " + std::to_string(object.size())
      );
    }

    iter = object.find("glob");
    if (iter != object.end()) {
      value->glob = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required FileOperationPattern attribute: glob"
      );
    }

    iter = object.find("matches");
    if (iter != object.end()) {
      value->matches = anyToFileOperationPatternKind(*iter->second);
    }

    iter = object.find("options");
    if (iter != object.end()) {
      value->options = anyToFileOperationPatternOptions(*iter->second);
    }

    return value;
  }

  auto LspTransformer::fileOperationPatternToAny(
    const FileOperationPattern &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("glob", stringToAny(structure.glob));
    if (structure.matches.has_value()) {
      object.emplace("matches", fileOperationPatternKindToAny(structure.matches.value()));
    }
    if (structure.options.has_value()) {
      object.emplace("options", fileOperationPatternOptionsToAny(*structure.options.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToWorkspaceFullDocumentDiagnosticReport_version(
    const LSPAny &any
  ) const -> WorkspaceFullDocumentDiagnosticReport_version {
    WorkspaceFullDocumentDiagnosticReport_version value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::INTEGER_TYPE: {
      value = anyToInteger(any);
      break;
    }
    case LSPAnyType::NULL_TYPE: {
      value = anyToNull(any);
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) WorkspaceFullDocumentDiagnosticReport_version: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::workspaceFullDocumentDiagnosticReport_versionToAny(
    const WorkspaceFullDocumentDiagnosticReport_version &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<WorkspaceFullDocumentDiagnosticReport_versionType>(variant.index())) {
    case WorkspaceFullDocumentDiagnosticReport_versionType::INTEGER_TYPE: {
      return integerToAny(
        std::get<integer_t>(variant)
      );
    }
    case WorkspaceFullDocumentDiagnosticReport_versionType::NULL_TYPE: {
      return nullToAny(
        std::get<null_t>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported WorkspaceFullDocumentDiagnosticReport_versionType: " +
         WorkspaceFullDocumentDiagnosticReport_versionTypeNames.at(static_cast<WorkspaceFullDocumentDiagnosticReport_versionType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToWorkspaceFullDocumentDiagnosticReport(
    const LSPAny &any
  ) const -> std::unique_ptr<WorkspaceFullDocumentDiagnosticReport> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) WorkspaceFullDocumentDiagnosticReport must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<WorkspaceFullDocumentDiagnosticReport> value =
      std::make_unique<WorkspaceFullDocumentDiagnosticReport>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 5) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) WorkspaceFullDocumentDiagnosticReport: " + std::to_string(object.size())
      );
    }

    iter = object.find("uri");
    if (iter != object.end()) {
      value->uri = anyToDocumentUri(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required WorkspaceFullDocumentDiagnosticReport attribute: uri"
      );
    }

    iter = object.find("version");
    if (iter != object.end()) {
      value->version = anyToWorkspaceFullDocumentDiagnosticReport_version(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required WorkspaceFullDocumentDiagnosticReport attribute: version"
      );
    }

    iter = object.find("kind");
    if (iter != object.end()) {
      const string_t &stringValue = anyToString(*iter->second);
      if (stringValue != "full") {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          "String value for WorkspaceFullDocumentDiagnosticReport.kind must be \"full\" but was: \"" + stringValue + "\""
        );
      }
      value->kind = stringValue;
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required WorkspaceFullDocumentDiagnosticReport attribute: kind"
      );
    }

    iter = object.find("resultId");
    if (iter != object.end()) {
      value->resultId = anyToString(*iter->second);
    }

    iter = object.find("items");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<std::unique_ptr<Diagnostic>> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToDiagnostic(*elem));
      }
      value->items = std::move(values);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required WorkspaceFullDocumentDiagnosticReport attribute: items"
      );
    }

    return value;
  }

  auto LspTransformer::workspaceFullDocumentDiagnosticReportToAny(
    const WorkspaceFullDocumentDiagnosticReport &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("uri", documentUriToAny(structure.uri));
    object.emplace("version", workspaceFullDocumentDiagnosticReport_versionToAny(structure.version));
    object.emplace("kind", stringToAny(structure.kind));
    if (structure.resultId.has_value()) {
      object.emplace("resultId", stringToAny(structure.resultId.value()));
    }
    {
      LSPArray array;
      for (const std::unique_ptr<Diagnostic> &elem : structure.items) {
        array.push_back(diagnosticToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("items", std::move(any));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToWorkspaceUnchangedDocumentDiagnosticReport_version(
    const LSPAny &any
  ) const -> WorkspaceUnchangedDocumentDiagnosticReport_version {
    WorkspaceUnchangedDocumentDiagnosticReport_version value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::INTEGER_TYPE: {
      value = anyToInteger(any);
      break;
    }
    case LSPAnyType::NULL_TYPE: {
      value = anyToNull(any);
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) WorkspaceUnchangedDocumentDiagnosticReport_version: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::workspaceUnchangedDocumentDiagnosticReport_versionToAny(
    const WorkspaceUnchangedDocumentDiagnosticReport_version &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<WorkspaceUnchangedDocumentDiagnosticReport_versionType>(variant.index())) {
    case WorkspaceUnchangedDocumentDiagnosticReport_versionType::INTEGER_TYPE: {
      return integerToAny(
        std::get<integer_t>(variant)
      );
    }
    case WorkspaceUnchangedDocumentDiagnosticReport_versionType::NULL_TYPE: {
      return nullToAny(
        std::get<null_t>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported WorkspaceUnchangedDocumentDiagnosticReport_versionType: " +
         WorkspaceUnchangedDocumentDiagnosticReport_versionTypeNames.at(static_cast<WorkspaceUnchangedDocumentDiagnosticReport_versionType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToWorkspaceUnchangedDocumentDiagnosticReport(
    const LSPAny &any
  ) const -> std::unique_ptr<WorkspaceUnchangedDocumentDiagnosticReport> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) WorkspaceUnchangedDocumentDiagnosticReport must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<WorkspaceUnchangedDocumentDiagnosticReport> value =
      std::make_unique<WorkspaceUnchangedDocumentDiagnosticReport>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 4) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) WorkspaceUnchangedDocumentDiagnosticReport: " + std::to_string(object.size())
      );
    }

    iter = object.find("uri");
    if (iter != object.end()) {
      value->uri = anyToDocumentUri(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required WorkspaceUnchangedDocumentDiagnosticReport attribute: uri"
      );
    }

    iter = object.find("version");
    if (iter != object.end()) {
      value->version = anyToWorkspaceUnchangedDocumentDiagnosticReport_version(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required WorkspaceUnchangedDocumentDiagnosticReport attribute: version"
      );
    }

    iter = object.find("kind");
    if (iter != object.end()) {
      const string_t &stringValue = anyToString(*iter->second);
      if (stringValue != "unchanged") {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          "String value for WorkspaceUnchangedDocumentDiagnosticReport.kind must be \"unchanged\" but was: \"" + stringValue + "\""
        );
      }
      value->kind = stringValue;
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required WorkspaceUnchangedDocumentDiagnosticReport attribute: kind"
      );
    }

    iter = object.find("resultId");
    if (iter != object.end()) {
      value->resultId = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required WorkspaceUnchangedDocumentDiagnosticReport attribute: resultId"
      );
    }

    return value;
  }

  auto LspTransformer::workspaceUnchangedDocumentDiagnosticReportToAny(
    const WorkspaceUnchangedDocumentDiagnosticReport &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("uri", documentUriToAny(structure.uri));
    object.emplace("version", workspaceUnchangedDocumentDiagnosticReport_versionToAny(structure.version));
    object.emplace("kind", stringToAny(structure.kind));
    object.emplace("resultId", stringToAny(structure.resultId));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToNotebookCell(
    const LSPAny &any
  ) const -> std::unique_ptr<NotebookCell> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) NotebookCell must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<NotebookCell> value =
      std::make_unique<NotebookCell>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 4) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) NotebookCell: " + std::to_string(object.size())
      );
    }

    iter = object.find("kind");
    if (iter != object.end()) {
      value->kind = anyToNotebookCellKind(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required NotebookCell attribute: kind"
      );
    }

    iter = object.find("document");
    if (iter != object.end()) {
      value->document = anyToDocumentUri(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required NotebookCell attribute: document"
      );
    }

    iter = object.find("metadata");
    if (iter != object.end()) {
      const LSPObject &object = std::get<LSPObject>(*iter->second);
      value->metadata = copy(object);
    }

    iter = object.find("executionSummary");
    if (iter != object.end()) {
      value->executionSummary = anyToExecutionSummary(*iter->second);
    }

    return value;
  }

  auto LspTransformer::notebookCellToAny(
    const NotebookCell &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("kind", notebookCellKindToAny(structure.kind));
    object.emplace("document", documentUriToAny(structure.document));
    if (structure.metadata.has_value()) {
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = copy(structure.metadata.value());
      object.emplace("metadata", std::move(any));
    }
    if (structure.executionSummary.has_value()) {
      object.emplace("executionSummary", executionSummaryToAny(*structure.executionSummary.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToNotebookCellArrayChange(
    const LSPAny &any
  ) const -> std::unique_ptr<NotebookCellArrayChange> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) NotebookCellArrayChange must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<NotebookCellArrayChange> value =
      std::make_unique<NotebookCellArrayChange>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) NotebookCellArrayChange: " + std::to_string(object.size())
      );
    }

    iter = object.find("start");
    if (iter != object.end()) {
      value->start = anyToUInteger(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required NotebookCellArrayChange attribute: start"
      );
    }

    iter = object.find("deleteCount");
    if (iter != object.end()) {
      value->deleteCount = anyToUInteger(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required NotebookCellArrayChange attribute: deleteCount"
      );
    }

    iter = object.find("cells");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<std::unique_ptr<NotebookCell>> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToNotebookCell(*elem));
      }
      value->cells = std::move(values);
    }

    return value;
  }

  auto LspTransformer::notebookCellArrayChangeToAny(
    const NotebookCellArrayChange &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("start", uintegerToAny(structure.start));
    object.emplace("deleteCount", uintegerToAny(structure.deleteCount));
    if (structure.cells.has_value()) {
      LSPArray array;
      for (const std::unique_ptr<NotebookCell> &elem : structure.cells.value()) {
        array.push_back(notebookCellToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("cells", std::move(any));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToSelectedCompletionInfo(
    const LSPAny &any
  ) const -> std::unique_ptr<SelectedCompletionInfo> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) SelectedCompletionInfo must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<SelectedCompletionInfo> value =
      std::make_unique<SelectedCompletionInfo>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) SelectedCompletionInfo: " + std::to_string(object.size())
      );
    }

    iter = object.find("range");
    if (iter != object.end()) {
      value->range = anyToRange(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required SelectedCompletionInfo attribute: range"
      );
    }

    iter = object.find("text");
    if (iter != object.end()) {
      value->text = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required SelectedCompletionInfo attribute: text"
      );
    }

    return value;
  }

  auto LspTransformer::selectedCompletionInfoToAny(
    const SelectedCompletionInfo &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("range", rangeToAny(*structure.range));
    object.emplace("text", stringToAny(structure.text));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToClientCapabilities(
    const LSPAny &any
  ) const -> std::unique_ptr<ClientCapabilities> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) ClientCapabilities must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<ClientCapabilities> value =
      std::make_unique<ClientCapabilities>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 6) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) ClientCapabilities: " + std::to_string(object.size())
      );
    }

    iter = object.find("workspace");
    if (iter != object.end()) {
      value->workspace = anyToWorkspaceClientCapabilities(*iter->second);
    }

    iter = object.find("textDocument");
    if (iter != object.end()) {
      value->textDocument = anyToTextDocumentClientCapabilities(*iter->second);
    }

    iter = object.find("notebookDocument");
    if (iter != object.end()) {
      value->notebookDocument = anyToNotebookDocumentClientCapabilities(*iter->second);
    }

    iter = object.find("window");
    if (iter != object.end()) {
      value->window = anyToWindowClientCapabilities(*iter->second);
    }

    iter = object.find("general");
    if (iter != object.end()) {
      value->general = anyToGeneralClientCapabilities(*iter->second);
    }

    iter = object.find("experimental");
    if (iter != object.end()) {
      value->experimental = copy(iter->second);
    }

    return value;
  }

  auto LspTransformer::clientCapabilitiesToAny(
    const ClientCapabilities &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.workspace.has_value()) {
      object.emplace("workspace", workspaceClientCapabilitiesToAny(*structure.workspace.value()));
    }
    if (structure.textDocument.has_value()) {
      object.emplace("textDocument", textDocumentClientCapabilitiesToAny(*structure.textDocument.value()));
    }
    if (structure.notebookDocument.has_value()) {
      object.emplace("notebookDocument", notebookDocumentClientCapabilitiesToAny(*structure.notebookDocument.value()));
    }
    if (structure.window.has_value()) {
      object.emplace("window", windowClientCapabilitiesToAny(*structure.window.value()));
    }
    if (structure.general.has_value()) {
      object.emplace("general", generalClientCapabilitiesToAny(*structure.general.value()));
    }
    if (structure.experimental.has_value()) {
      object.emplace("experimental", copy(structure.experimental.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToTextDocumentSyncOptions_save(
    const LSPAny &any
  ) const -> TextDocumentSyncOptions_save {
    TextDocumentSyncOptions_save value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::OBJECT_TYPE: {
      try {
        value = anyToSaveOptions(any);
      } catch (LspException &e) {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          "Failed to transform LSPAny to TextDocumentSyncOptions_save"
        );
      }
      break;
    }
    case LSPAnyType::BOOLEAN_TYPE: {
      value = anyToBoolean(any);
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) TextDocumentSyncOptions_save: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::textDocumentSyncOptions_saveToAny(
    const TextDocumentSyncOptions_save &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<TextDocumentSyncOptions_saveType>(variant.index())) {
    case TextDocumentSyncOptions_saveType::BOOLEAN_TYPE: {
      return booleanToAny(
        std::get<boolean_t>(variant)
      );
    }
    case TextDocumentSyncOptions_saveType::SAVE_OPTIONS: {
      return saveOptionsToAny(
        *std::get<std::unique_ptr<SaveOptions>>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported TextDocumentSyncOptions_saveType: " +
         TextDocumentSyncOptions_saveTypeNames.at(static_cast<TextDocumentSyncOptions_saveType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToTextDocumentSyncOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<TextDocumentSyncOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) TextDocumentSyncOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<TextDocumentSyncOptions> value =
      std::make_unique<TextDocumentSyncOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 5) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) TextDocumentSyncOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("openClose");
    if (iter != object.end()) {
      value->openClose = anyToBoolean(*iter->second);
    }

    iter = object.find("change");
    if (iter != object.end()) {
      value->change = anyToTextDocumentSyncKind(*iter->second);
    }

    iter = object.find("willSave");
    if (iter != object.end()) {
      value->willSave = anyToBoolean(*iter->second);
    }

    iter = object.find("willSaveWaitUntil");
    if (iter != object.end()) {
      value->willSaveWaitUntil = anyToBoolean(*iter->second);
    }

    iter = object.find("save");
    if (iter != object.end()) {
      value->save = anyToTextDocumentSyncOptions_save(*iter->second);
    }

    return value;
  }

  auto LspTransformer::textDocumentSyncOptionsToAny(
    const TextDocumentSyncOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.openClose.has_value()) {
      object.emplace("openClose", booleanToAny(structure.openClose.value()));
    }
    if (structure.change.has_value()) {
      object.emplace("change", textDocumentSyncKindToAny(structure.change.value()));
    }
    if (structure.willSave.has_value()) {
      object.emplace("willSave", booleanToAny(structure.willSave.value()));
    }
    if (structure.willSaveWaitUntil.has_value()) {
      object.emplace("willSaveWaitUntil", booleanToAny(structure.willSaveWaitUntil.value()));
    }
    if (structure.save.has_value()) {
      object.emplace("save", textDocumentSyncOptions_saveToAny(structure.save.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToNotebookDocumentSyncOptions_notebookSelector_1_cells(
    const LSPAny &any
  ) const -> std::unique_ptr<NotebookDocumentSyncOptions_notebookSelector_1_cells> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) NotebookDocumentSyncOptions_notebookSelector_1_cells must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<NotebookDocumentSyncOptions_notebookSelector_1_cells> value =
      std::make_unique<NotebookDocumentSyncOptions_notebookSelector_1_cells>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) NotebookDocumentSyncOptions_notebookSelector_1_cells: " + std::to_string(object.size())
      );
    }

    iter = object.find("language");
    if (iter != object.end()) {
      value->language = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required NotebookDocumentSyncOptions_notebookSelector_1_cells attribute: language"
      );
    }

    return value;
  }

  auto LspTransformer::notebookDocumentSyncOptions_notebookSelector_1_cellsToAny(
    const NotebookDocumentSyncOptions_notebookSelector_1_cells &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("language", stringToAny(structure.language));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToNotebookDocumentSyncOptions_notebookSelector_1_notebook(
    const LSPAny &any
  ) const -> NotebookDocumentSyncOptions_notebookSelector_1_notebook {
    NotebookDocumentSyncOptions_notebookSelector_1_notebook value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::OBJECT_TYPE: {
      try {
        value = anyToNotebookDocumentFilter(any);
      } catch (LspException &e) {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          "Failed to transform LSPAny to NotebookDocumentSyncOptions_notebookSelector_1_notebook"
        );
      }
      break;
    }
    case LSPAnyType::STRING_TYPE: {
      value = anyToString(any);
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) NotebookDocumentSyncOptions_notebookSelector_1_notebook: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::notebookDocumentSyncOptions_notebookSelector_1_notebookToAny(
    const NotebookDocumentSyncOptions_notebookSelector_1_notebook &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<NotebookDocumentSyncOptions_notebookSelector_1_notebookType>(variant.index())) {
    case NotebookDocumentSyncOptions_notebookSelector_1_notebookType::STRING_TYPE: {
      return stringToAny(
        std::get<string_t>(variant)
      );
    }
    case NotebookDocumentSyncOptions_notebookSelector_1_notebookType::NOTEBOOK_DOCUMENT_FILTER: {
      return notebookDocumentFilterToAny(
        std::get<NotebookDocumentFilter>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported NotebookDocumentSyncOptions_notebookSelector_1_notebookType: " +
         NotebookDocumentSyncOptions_notebookSelector_1_notebookTypeNames.at(static_cast<NotebookDocumentSyncOptions_notebookSelector_1_notebookType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToNotebookDocumentSyncOptions_notebookSelector_1(
    const LSPAny &any
  ) const -> std::unique_ptr<NotebookDocumentSyncOptions_notebookSelector_1> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) NotebookDocumentSyncOptions_notebookSelector_1 must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<NotebookDocumentSyncOptions_notebookSelector_1> value =
      std::make_unique<NotebookDocumentSyncOptions_notebookSelector_1>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) NotebookDocumentSyncOptions_notebookSelector_1: " + std::to_string(object.size())
      );
    }

    iter = object.find("notebook");
    if (iter != object.end()) {
      value->notebook = anyToNotebookDocumentSyncOptions_notebookSelector_1_notebook(*iter->second);
    }

    iter = object.find("cells");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<std::unique_ptr<NotebookDocumentSyncOptions_notebookSelector_1_cells>> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToNotebookDocumentSyncOptions_notebookSelector_1_cells(*elem));
      }
      value->cells = std::move(values);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required NotebookDocumentSyncOptions_notebookSelector_1 attribute: cells"
      );
    }

    return value;
  }

  auto LspTransformer::notebookDocumentSyncOptions_notebookSelector_1ToAny(
    const NotebookDocumentSyncOptions_notebookSelector_1 &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.notebook.has_value()) {
      object.emplace("notebook", notebookDocumentSyncOptions_notebookSelector_1_notebookToAny(structure.notebook.value()));
    }
    {
      LSPArray array;
      for (const std::unique_ptr<NotebookDocumentSyncOptions_notebookSelector_1_cells> &elem : structure.cells) {
        array.push_back(notebookDocumentSyncOptions_notebookSelector_1_cellsToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("cells", std::move(any));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToNotebookDocumentSyncOptions_notebookSelector_0_cells(
    const LSPAny &any
  ) const -> std::unique_ptr<NotebookDocumentSyncOptions_notebookSelector_0_cells> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) NotebookDocumentSyncOptions_notebookSelector_0_cells must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<NotebookDocumentSyncOptions_notebookSelector_0_cells> value =
      std::make_unique<NotebookDocumentSyncOptions_notebookSelector_0_cells>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) NotebookDocumentSyncOptions_notebookSelector_0_cells: " + std::to_string(object.size())
      );
    }

    iter = object.find("language");
    if (iter != object.end()) {
      value->language = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required NotebookDocumentSyncOptions_notebookSelector_0_cells attribute: language"
      );
    }

    return value;
  }

  auto LspTransformer::notebookDocumentSyncOptions_notebookSelector_0_cellsToAny(
    const NotebookDocumentSyncOptions_notebookSelector_0_cells &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("language", stringToAny(structure.language));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToNotebookDocumentSyncOptions_notebookSelector_0_notebook(
    const LSPAny &any
  ) const -> NotebookDocumentSyncOptions_notebookSelector_0_notebook {
    NotebookDocumentSyncOptions_notebookSelector_0_notebook value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::OBJECT_TYPE: {
      try {
        value = anyToNotebookDocumentFilter(any);
      } catch (LspException &e) {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          "Failed to transform LSPAny to NotebookDocumentSyncOptions_notebookSelector_0_notebook"
        );
      }
      break;
    }
    case LSPAnyType::STRING_TYPE: {
      value = anyToString(any);
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) NotebookDocumentSyncOptions_notebookSelector_0_notebook: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::notebookDocumentSyncOptions_notebookSelector_0_notebookToAny(
    const NotebookDocumentSyncOptions_notebookSelector_0_notebook &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<NotebookDocumentSyncOptions_notebookSelector_0_notebookType>(variant.index())) {
    case NotebookDocumentSyncOptions_notebookSelector_0_notebookType::STRING_TYPE: {
      return stringToAny(
        std::get<string_t>(variant)
      );
    }
    case NotebookDocumentSyncOptions_notebookSelector_0_notebookType::NOTEBOOK_DOCUMENT_FILTER: {
      return notebookDocumentFilterToAny(
        std::get<NotebookDocumentFilter>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported NotebookDocumentSyncOptions_notebookSelector_0_notebookType: " +
         NotebookDocumentSyncOptions_notebookSelector_0_notebookTypeNames.at(static_cast<NotebookDocumentSyncOptions_notebookSelector_0_notebookType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToNotebookDocumentSyncOptions_notebookSelector_0(
    const LSPAny &any
  ) const -> std::unique_ptr<NotebookDocumentSyncOptions_notebookSelector_0> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) NotebookDocumentSyncOptions_notebookSelector_0 must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<NotebookDocumentSyncOptions_notebookSelector_0> value =
      std::make_unique<NotebookDocumentSyncOptions_notebookSelector_0>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) NotebookDocumentSyncOptions_notebookSelector_0: " + std::to_string(object.size())
      );
    }

    iter = object.find("notebook");
    if (iter != object.end()) {
      value->notebook = anyToNotebookDocumentSyncOptions_notebookSelector_0_notebook(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required NotebookDocumentSyncOptions_notebookSelector_0 attribute: notebook"
      );
    }

    iter = object.find("cells");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<std::unique_ptr<NotebookDocumentSyncOptions_notebookSelector_0_cells>> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToNotebookDocumentSyncOptions_notebookSelector_0_cells(*elem));
      }
      value->cells = std::move(values);
    }

    return value;
  }

  auto LspTransformer::notebookDocumentSyncOptions_notebookSelector_0ToAny(
    const NotebookDocumentSyncOptions_notebookSelector_0 &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("notebook", notebookDocumentSyncOptions_notebookSelector_0_notebookToAny(structure.notebook));
    if (structure.cells.has_value()) {
      LSPArray array;
      for (const std::unique_ptr<NotebookDocumentSyncOptions_notebookSelector_0_cells> &elem : structure.cells.value()) {
        array.push_back(notebookDocumentSyncOptions_notebookSelector_0_cellsToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("cells", std::move(any));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToNotebookDocumentSyncOptions_notebookSelector(
    const LSPAny &any
  ) const -> NotebookDocumentSyncOptions_notebookSelector {
    NotebookDocumentSyncOptions_notebookSelector value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::OBJECT_TYPE: {
      try {
        value = anyToNotebookDocumentSyncOptions_notebookSelector_0(any);
      } catch (LspException &e) {
        try {
          value = anyToNotebookDocumentSyncOptions_notebookSelector_1(any);
        } catch (LspException &e) {
          throw LSP_EXCEPTION(
            ErrorCodes::INVALID_PARAMS,
            "Failed to transform LSPAny to NotebookDocumentSyncOptions_notebookSelector"
          );
        }
      }
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) NotebookDocumentSyncOptions_notebookSelector: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::notebookDocumentSyncOptions_notebookSelectorToAny(
    const NotebookDocumentSyncOptions_notebookSelector &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<NotebookDocumentSyncOptions_notebookSelectorType>(variant.index())) {
    case NotebookDocumentSyncOptions_notebookSelectorType::NOTEBOOK_DOCUMENT_SYNC_OPTIONS_NOTEBOOK_SELECTOR_0: {
      return notebookDocumentSyncOptions_notebookSelector_0ToAny(
        *std::get<std::unique_ptr<NotebookDocumentSyncOptions_notebookSelector_0>>(variant)
      );
    }
    case NotebookDocumentSyncOptions_notebookSelectorType::NOTEBOOK_DOCUMENT_SYNC_OPTIONS_NOTEBOOK_SELECTOR_1: {
      return notebookDocumentSyncOptions_notebookSelector_1ToAny(
        *std::get<std::unique_ptr<NotebookDocumentSyncOptions_notebookSelector_1>>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported NotebookDocumentSyncOptions_notebookSelectorType: " +
         NotebookDocumentSyncOptions_notebookSelectorTypeNames.at(static_cast<NotebookDocumentSyncOptions_notebookSelectorType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToNotebookDocumentSyncOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<NotebookDocumentSyncOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) NotebookDocumentSyncOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<NotebookDocumentSyncOptions> value =
      std::make_unique<NotebookDocumentSyncOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) NotebookDocumentSyncOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("notebookSelector");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<NotebookDocumentSyncOptions_notebookSelector> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToNotebookDocumentSyncOptions_notebookSelector(*elem));
      }
      value->notebookSelector = std::move(values);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required NotebookDocumentSyncOptions attribute: notebookSelector"
      );
    }

    iter = object.find("save");
    if (iter != object.end()) {
      value->save = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::notebookDocumentSyncOptionsToAny(
    const NotebookDocumentSyncOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    {
      LSPArray array;
      for (const NotebookDocumentSyncOptions_notebookSelector &elem : structure.notebookSelector) {
        array.push_back(notebookDocumentSyncOptions_notebookSelectorToAny(elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("notebookSelector", std::move(any));
    }
    if (structure.save.has_value()) {
      object.emplace("save", booleanToAny(structure.save.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToNotebookDocumentSyncRegistrationOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<NotebookDocumentSyncRegistrationOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) NotebookDocumentSyncRegistrationOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<NotebookDocumentSyncRegistrationOptions> value =
      std::make_unique<NotebookDocumentSyncRegistrationOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) NotebookDocumentSyncRegistrationOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("notebookSelector");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<NotebookDocumentSyncOptions_notebookSelector> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToNotebookDocumentSyncOptions_notebookSelector(*elem));
      }
      value->notebookSelector = std::move(values);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required NotebookDocumentSyncRegistrationOptions attribute: notebookSelector"
      );
    }

    iter = object.find("save");
    if (iter != object.end()) {
      value->save = anyToBoolean(*iter->second);
    }

    iter = object.find("id");
    if (iter != object.end()) {
      value->id = anyToString(*iter->second);
    }

    return value;
  }

  auto LspTransformer::notebookDocumentSyncRegistrationOptionsToAny(
    const NotebookDocumentSyncRegistrationOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    {
      LSPArray array;
      for (const NotebookDocumentSyncOptions_notebookSelector &elem : structure.notebookSelector) {
        array.push_back(notebookDocumentSyncOptions_notebookSelectorToAny(elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("notebookSelector", std::move(any));
    }
    if (structure.save.has_value()) {
      object.emplace("save", booleanToAny(structure.save.value()));
    }
    if (structure.id.has_value()) {
      object.emplace("id", stringToAny(structure.id.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToWorkspaceFoldersServerCapabilities_changeNotifications(
    const LSPAny &any
  ) const -> WorkspaceFoldersServerCapabilities_changeNotifications {
    WorkspaceFoldersServerCapabilities_changeNotifications value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::STRING_TYPE: {
      value = anyToString(any);
      break;
    }
    case LSPAnyType::BOOLEAN_TYPE: {
      value = anyToBoolean(any);
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) WorkspaceFoldersServerCapabilities_changeNotifications: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::workspaceFoldersServerCapabilities_changeNotificationsToAny(
    const WorkspaceFoldersServerCapabilities_changeNotifications &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<WorkspaceFoldersServerCapabilities_changeNotificationsType>(variant.index())) {
    case WorkspaceFoldersServerCapabilities_changeNotificationsType::STRING_TYPE: {
      return stringToAny(
        std::get<string_t>(variant)
      );
    }
    case WorkspaceFoldersServerCapabilities_changeNotificationsType::BOOLEAN_TYPE: {
      return booleanToAny(
        std::get<boolean_t>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported WorkspaceFoldersServerCapabilities_changeNotificationsType: " +
         WorkspaceFoldersServerCapabilities_changeNotificationsTypeNames.at(static_cast<WorkspaceFoldersServerCapabilities_changeNotificationsType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToWorkspaceFoldersServerCapabilities(
    const LSPAny &any
  ) const -> std::unique_ptr<WorkspaceFoldersServerCapabilities> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) WorkspaceFoldersServerCapabilities must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<WorkspaceFoldersServerCapabilities> value =
      std::make_unique<WorkspaceFoldersServerCapabilities>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) WorkspaceFoldersServerCapabilities: " + std::to_string(object.size())
      );
    }

    iter = object.find("supported");
    if (iter != object.end()) {
      value->supported = anyToBoolean(*iter->second);
    }

    iter = object.find("changeNotifications");
    if (iter != object.end()) {
      value->changeNotifications = anyToWorkspaceFoldersServerCapabilities_changeNotifications(*iter->second);
    }

    return value;
  }

  auto LspTransformer::workspaceFoldersServerCapabilitiesToAny(
    const WorkspaceFoldersServerCapabilities &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.supported.has_value()) {
      object.emplace("supported", booleanToAny(structure.supported.value()));
    }
    if (structure.changeNotifications.has_value()) {
      object.emplace("changeNotifications", workspaceFoldersServerCapabilities_changeNotificationsToAny(structure.changeNotifications.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToFileOperationOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<FileOperationOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) FileOperationOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<FileOperationOptions> value =
      std::make_unique<FileOperationOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 6) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) FileOperationOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("didCreate");
    if (iter != object.end()) {
      value->didCreate = anyToFileOperationRegistrationOptions(*iter->second);
    }

    iter = object.find("willCreate");
    if (iter != object.end()) {
      value->willCreate = anyToFileOperationRegistrationOptions(*iter->second);
    }

    iter = object.find("didRename");
    if (iter != object.end()) {
      value->didRename = anyToFileOperationRegistrationOptions(*iter->second);
    }

    iter = object.find("willRename");
    if (iter != object.end()) {
      value->willRename = anyToFileOperationRegistrationOptions(*iter->second);
    }

    iter = object.find("didDelete");
    if (iter != object.end()) {
      value->didDelete = anyToFileOperationRegistrationOptions(*iter->second);
    }

    iter = object.find("willDelete");
    if (iter != object.end()) {
      value->willDelete = anyToFileOperationRegistrationOptions(*iter->second);
    }

    return value;
  }

  auto LspTransformer::fileOperationOptionsToAny(
    const FileOperationOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.didCreate.has_value()) {
      object.emplace("didCreate", fileOperationRegistrationOptionsToAny(*structure.didCreate.value()));
    }
    if (structure.willCreate.has_value()) {
      object.emplace("willCreate", fileOperationRegistrationOptionsToAny(*structure.willCreate.value()));
    }
    if (structure.didRename.has_value()) {
      object.emplace("didRename", fileOperationRegistrationOptionsToAny(*structure.didRename.value()));
    }
    if (structure.willRename.has_value()) {
      object.emplace("willRename", fileOperationRegistrationOptionsToAny(*structure.willRename.value()));
    }
    if (structure.didDelete.has_value()) {
      object.emplace("didDelete", fileOperationRegistrationOptionsToAny(*structure.didDelete.value()));
    }
    if (structure.willDelete.has_value()) {
      object.emplace("willDelete", fileOperationRegistrationOptionsToAny(*structure.willDelete.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToCodeDescription(
    const LSPAny &any
  ) const -> std::unique_ptr<CodeDescription> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) CodeDescription must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<CodeDescription> value =
      std::make_unique<CodeDescription>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) CodeDescription: " + std::to_string(object.size())
      );
    }

    iter = object.find("href");
    if (iter != object.end()) {
      value->href = anyToURI(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required CodeDescription attribute: href"
      );
    }

    return value;
  }

  auto LspTransformer::codeDescriptionToAny(
    const CodeDescription &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("href", uriToAny(structure.href));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToDiagnosticRelatedInformation(
    const LSPAny &any
  ) const -> std::unique_ptr<DiagnosticRelatedInformation> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) DiagnosticRelatedInformation must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<DiagnosticRelatedInformation> value =
      std::make_unique<DiagnosticRelatedInformation>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) DiagnosticRelatedInformation: " + std::to_string(object.size())
      );
    }

    iter = object.find("location");
    if (iter != object.end()) {
      value->location = anyToLocation(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DiagnosticRelatedInformation attribute: location"
      );
    }

    iter = object.find("message");
    if (iter != object.end()) {
      value->message = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DiagnosticRelatedInformation attribute: message"
      );
    }

    return value;
  }

  auto LspTransformer::diagnosticRelatedInformationToAny(
    const DiagnosticRelatedInformation &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("location", locationToAny(*structure.location));
    object.emplace("message", stringToAny(structure.message));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToParameterInformation_label(
    const LSPAny &any
  ) const -> ParameterInformation_label {
    ParameterInformation_label value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::STRING_TYPE: {
      value = anyToString(any);
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) ParameterInformation_label: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::parameterInformation_labelToAny(
    const ParameterInformation_label &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<ParameterInformation_labelType>(variant.index())) {
    case ParameterInformation_labelType::STRING_TYPE: {
      return stringToAny(
        std::get<string_t>(variant)
      );
    }
    case ParameterInformation_labelType::PAIR_OF_UINTEGER_TYPE_AND_UINTEGER_TYPE: {
      LSPArray array;
      const std::pair<uinteger_t, uinteger_t> &pair =
        std::get<std::pair<uinteger_t, uinteger_t>>(variant);
      array.push_back(uintegerToAny(pair.first));
      array.push_back(uintegerToAny(pair.second));
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      return any;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported ParameterInformation_labelType: " +
         ParameterInformation_labelTypeNames.at(static_cast<ParameterInformation_labelType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToParameterInformation_documentation(
    const LSPAny &any
  ) const -> ParameterInformation_documentation {
    ParameterInformation_documentation value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::OBJECT_TYPE: {
      try {
        value = anyToMarkupContent(any);
      } catch (LspException &e) {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          "Failed to transform LSPAny to ParameterInformation_documentation"
        );
      }
      break;
    }
    case LSPAnyType::STRING_TYPE: {
      value = anyToString(any);
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) ParameterInformation_documentation: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::parameterInformation_documentationToAny(
    const ParameterInformation_documentation &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<ParameterInformation_documentationType>(variant.index())) {
    case ParameterInformation_documentationType::STRING_TYPE: {
      return stringToAny(
        std::get<string_t>(variant)
      );
    }
    case ParameterInformation_documentationType::MARKUP_CONTENT: {
      return markupContentToAny(
        *std::get<std::unique_ptr<MarkupContent>>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported ParameterInformation_documentationType: " +
         ParameterInformation_documentationTypeNames.at(static_cast<ParameterInformation_documentationType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToParameterInformation(
    const LSPAny &any
  ) const -> std::unique_ptr<ParameterInformation> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) ParameterInformation must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<ParameterInformation> value =
      std::make_unique<ParameterInformation>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) ParameterInformation: " + std::to_string(object.size())
      );
    }

    iter = object.find("label");
    if (iter != object.end()) {
      value->label = anyToParameterInformation_label(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required ParameterInformation attribute: label"
      );
    }

    iter = object.find("documentation");
    if (iter != object.end()) {
      value->documentation = anyToParameterInformation_documentation(*iter->second);
    }

    return value;
  }

  auto LspTransformer::parameterInformationToAny(
    const ParameterInformation &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("label", parameterInformation_labelToAny(structure.label));
    if (structure.documentation.has_value()) {
      object.emplace("documentation", parameterInformation_documentationToAny(structure.documentation.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToNotebookCellTextDocumentFilter_notebook(
    const LSPAny &any
  ) const -> NotebookCellTextDocumentFilter_notebook {
    NotebookCellTextDocumentFilter_notebook value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::OBJECT_TYPE: {
      try {
        value = anyToNotebookDocumentFilter(any);
      } catch (LspException &e) {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          "Failed to transform LSPAny to NotebookCellTextDocumentFilter_notebook"
        );
      }
      break;
    }
    case LSPAnyType::STRING_TYPE: {
      value = anyToString(any);
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) NotebookCellTextDocumentFilter_notebook: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::notebookCellTextDocumentFilter_notebookToAny(
    const NotebookCellTextDocumentFilter_notebook &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<NotebookCellTextDocumentFilter_notebookType>(variant.index())) {
    case NotebookCellTextDocumentFilter_notebookType::STRING_TYPE: {
      return stringToAny(
        std::get<string_t>(variant)
      );
    }
    case NotebookCellTextDocumentFilter_notebookType::NOTEBOOK_DOCUMENT_FILTER: {
      return notebookDocumentFilterToAny(
        std::get<NotebookDocumentFilter>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported NotebookCellTextDocumentFilter_notebookType: " +
         NotebookCellTextDocumentFilter_notebookTypeNames.at(static_cast<NotebookCellTextDocumentFilter_notebookType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToNotebookCellTextDocumentFilter(
    const LSPAny &any
  ) const -> std::unique_ptr<NotebookCellTextDocumentFilter> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) NotebookCellTextDocumentFilter must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<NotebookCellTextDocumentFilter> value =
      std::make_unique<NotebookCellTextDocumentFilter>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) NotebookCellTextDocumentFilter: " + std::to_string(object.size())
      );
    }

    iter = object.find("notebook");
    if (iter != object.end()) {
      value->notebook = anyToNotebookCellTextDocumentFilter_notebook(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required NotebookCellTextDocumentFilter attribute: notebook"
      );
    }

    iter = object.find("language");
    if (iter != object.end()) {
      value->language = anyToString(*iter->second);
    }

    return value;
  }

  auto LspTransformer::notebookCellTextDocumentFilterToAny(
    const NotebookCellTextDocumentFilter &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("notebook", notebookCellTextDocumentFilter_notebookToAny(structure.notebook));
    if (structure.language.has_value()) {
      object.emplace("language", stringToAny(structure.language.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToFileOperationPatternOptions(
    const LSPAny &any
  ) const -> std::unique_ptr<FileOperationPatternOptions> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) FileOperationPatternOptions must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<FileOperationPatternOptions> value =
      std::make_unique<FileOperationPatternOptions>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) FileOperationPatternOptions: " + std::to_string(object.size())
      );
    }

    iter = object.find("ignoreCase");
    if (iter != object.end()) {
      value->ignoreCase = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::fileOperationPatternOptionsToAny(
    const FileOperationPatternOptions &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.ignoreCase.has_value()) {
      object.emplace("ignoreCase", booleanToAny(structure.ignoreCase.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToExecutionSummary(
    const LSPAny &any
  ) const -> std::unique_ptr<ExecutionSummary> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) ExecutionSummary must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<ExecutionSummary> value =
      std::make_unique<ExecutionSummary>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) ExecutionSummary: " + std::to_string(object.size())
      );
    }

    iter = object.find("executionOrder");
    if (iter != object.end()) {
      value->executionOrder = anyToUInteger(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required ExecutionSummary attribute: executionOrder"
      );
    }

    iter = object.find("success");
    if (iter != object.end()) {
      value->success = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::executionSummaryToAny(
    const ExecutionSummary &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("executionOrder", uintegerToAny(structure.executionOrder));
    if (structure.success.has_value()) {
      object.emplace("success", booleanToAny(structure.success.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToWorkspaceClientCapabilities(
    const LSPAny &any
  ) const -> std::unique_ptr<WorkspaceClientCapabilities> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) WorkspaceClientCapabilities must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<WorkspaceClientCapabilities> value =
      std::make_unique<WorkspaceClientCapabilities>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 15) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) WorkspaceClientCapabilities: " + std::to_string(object.size())
      );
    }

    iter = object.find("applyEdit");
    if (iter != object.end()) {
      value->applyEdit = anyToBoolean(*iter->second);
    }

    iter = object.find("workspaceEdit");
    if (iter != object.end()) {
      value->workspaceEdit = anyToWorkspaceEditClientCapabilities(*iter->second);
    }

    iter = object.find("didChangeConfiguration");
    if (iter != object.end()) {
      value->didChangeConfiguration = anyToDidChangeConfigurationClientCapabilities(*iter->second);
    }

    iter = object.find("didChangeWatchedFiles");
    if (iter != object.end()) {
      value->didChangeWatchedFiles = anyToDidChangeWatchedFilesClientCapabilities(*iter->second);
    }

    iter = object.find("symbol");
    if (iter != object.end()) {
      value->symbol = anyToWorkspaceSymbolClientCapabilities(*iter->second);
    }

    iter = object.find("executeCommand");
    if (iter != object.end()) {
      value->executeCommand = anyToExecuteCommandClientCapabilities(*iter->second);
    }

    iter = object.find("workspaceFolders");
    if (iter != object.end()) {
      value->workspaceFolders = anyToBoolean(*iter->second);
    }

    iter = object.find("configuration");
    if (iter != object.end()) {
      value->configuration = anyToBoolean(*iter->second);
    }

    iter = object.find("semanticTokens");
    if (iter != object.end()) {
      value->semanticTokens = anyToSemanticTokensWorkspaceClientCapabilities(*iter->second);
    }

    iter = object.find("codeLens");
    if (iter != object.end()) {
      value->codeLens = anyToCodeLensWorkspaceClientCapabilities(*iter->second);
    }

    iter = object.find("fileOperations");
    if (iter != object.end()) {
      value->fileOperations = anyToFileOperationClientCapabilities(*iter->second);
    }

    iter = object.find("inlineValue");
    if (iter != object.end()) {
      value->inlineValue = anyToInlineValueWorkspaceClientCapabilities(*iter->second);
    }

    iter = object.find("inlayHint");
    if (iter != object.end()) {
      value->inlayHint = anyToInlayHintWorkspaceClientCapabilities(*iter->second);
    }

    iter = object.find("diagnostics");
    if (iter != object.end()) {
      value->diagnostics = anyToDiagnosticWorkspaceClientCapabilities(*iter->second);
    }

    iter = object.find("foldingRange");
    if (iter != object.end()) {
      value->foldingRange = anyToFoldingRangeWorkspaceClientCapabilities(*iter->second);
    }

    return value;
  }

  auto LspTransformer::workspaceClientCapabilitiesToAny(
    const WorkspaceClientCapabilities &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.applyEdit.has_value()) {
      object.emplace("applyEdit", booleanToAny(structure.applyEdit.value()));
    }
    if (structure.workspaceEdit.has_value()) {
      object.emplace("workspaceEdit", workspaceEditClientCapabilitiesToAny(*structure.workspaceEdit.value()));
    }
    if (structure.didChangeConfiguration.has_value()) {
      object.emplace("didChangeConfiguration", didChangeConfigurationClientCapabilitiesToAny(*structure.didChangeConfiguration.value()));
    }
    if (structure.didChangeWatchedFiles.has_value()) {
      object.emplace("didChangeWatchedFiles", didChangeWatchedFilesClientCapabilitiesToAny(*structure.didChangeWatchedFiles.value()));
    }
    if (structure.symbol.has_value()) {
      object.emplace("symbol", workspaceSymbolClientCapabilitiesToAny(*structure.symbol.value()));
    }
    if (structure.executeCommand.has_value()) {
      object.emplace("executeCommand", executeCommandClientCapabilitiesToAny(*structure.executeCommand.value()));
    }
    if (structure.workspaceFolders.has_value()) {
      object.emplace("workspaceFolders", booleanToAny(structure.workspaceFolders.value()));
    }
    if (structure.configuration.has_value()) {
      object.emplace("configuration", booleanToAny(structure.configuration.value()));
    }
    if (structure.semanticTokens.has_value()) {
      object.emplace("semanticTokens", semanticTokensWorkspaceClientCapabilitiesToAny(*structure.semanticTokens.value()));
    }
    if (structure.codeLens.has_value()) {
      object.emplace("codeLens", codeLensWorkspaceClientCapabilitiesToAny(*structure.codeLens.value()));
    }
    if (structure.fileOperations.has_value()) {
      object.emplace("fileOperations", fileOperationClientCapabilitiesToAny(*structure.fileOperations.value()));
    }
    if (structure.inlineValue.has_value()) {
      object.emplace("inlineValue", inlineValueWorkspaceClientCapabilitiesToAny(*structure.inlineValue.value()));
    }
    if (structure.inlayHint.has_value()) {
      object.emplace("inlayHint", inlayHintWorkspaceClientCapabilitiesToAny(*structure.inlayHint.value()));
    }
    if (structure.diagnostics.has_value()) {
      object.emplace("diagnostics", diagnosticWorkspaceClientCapabilitiesToAny(*structure.diagnostics.value()));
    }
    if (structure.foldingRange.has_value()) {
      object.emplace("foldingRange", foldingRangeWorkspaceClientCapabilitiesToAny(*structure.foldingRange.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToTextDocumentClientCapabilities(
    const LSPAny &any
  ) const -> std::unique_ptr<TextDocumentClientCapabilities> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) TextDocumentClientCapabilities must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<TextDocumentClientCapabilities> value =
      std::make_unique<TextDocumentClientCapabilities>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 31) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) TextDocumentClientCapabilities: " + std::to_string(object.size())
      );
    }

    iter = object.find("synchronization");
    if (iter != object.end()) {
      value->synchronization = anyToTextDocumentSyncClientCapabilities(*iter->second);
    }

    iter = object.find("completion");
    if (iter != object.end()) {
      value->completion = anyToCompletionClientCapabilities(*iter->second);
    }

    iter = object.find("hover");
    if (iter != object.end()) {
      value->hover = anyToHoverClientCapabilities(*iter->second);
    }

    iter = object.find("signatureHelp");
    if (iter != object.end()) {
      value->signatureHelp = anyToSignatureHelpClientCapabilities(*iter->second);
    }

    iter = object.find("declaration");
    if (iter != object.end()) {
      value->declaration = anyToDeclarationClientCapabilities(*iter->second);
    }

    iter = object.find("definition");
    if (iter != object.end()) {
      value->definition = anyToDefinitionClientCapabilities(*iter->second);
    }

    iter = object.find("typeDefinition");
    if (iter != object.end()) {
      value->typeDefinition = anyToTypeDefinitionClientCapabilities(*iter->second);
    }

    iter = object.find("implementation");
    if (iter != object.end()) {
      value->implementation = anyToImplementationClientCapabilities(*iter->second);
    }

    iter = object.find("references");
    if (iter != object.end()) {
      value->references = anyToReferenceClientCapabilities(*iter->second);
    }

    iter = object.find("documentHighlight");
    if (iter != object.end()) {
      value->documentHighlight = anyToDocumentHighlightClientCapabilities(*iter->second);
    }

    iter = object.find("documentSymbol");
    if (iter != object.end()) {
      value->documentSymbol = anyToDocumentSymbolClientCapabilities(*iter->second);
    }

    iter = object.find("codeAction");
    if (iter != object.end()) {
      value->codeAction = anyToCodeActionClientCapabilities(*iter->second);
    }

    iter = object.find("codeLens");
    if (iter != object.end()) {
      value->codeLens = anyToCodeLensClientCapabilities(*iter->second);
    }

    iter = object.find("documentLink");
    if (iter != object.end()) {
      value->documentLink = anyToDocumentLinkClientCapabilities(*iter->second);
    }

    iter = object.find("colorProvider");
    if (iter != object.end()) {
      value->colorProvider = anyToDocumentColorClientCapabilities(*iter->second);
    }

    iter = object.find("formatting");
    if (iter != object.end()) {
      value->formatting = anyToDocumentFormattingClientCapabilities(*iter->second);
    }

    iter = object.find("rangeFormatting");
    if (iter != object.end()) {
      value->rangeFormatting = anyToDocumentRangeFormattingClientCapabilities(*iter->second);
    }

    iter = object.find("onTypeFormatting");
    if (iter != object.end()) {
      value->onTypeFormatting = anyToDocumentOnTypeFormattingClientCapabilities(*iter->second);
    }

    iter = object.find("rename");
    if (iter != object.end()) {
      value->rename = anyToRenameClientCapabilities(*iter->second);
    }

    iter = object.find("foldingRange");
    if (iter != object.end()) {
      value->foldingRange = anyToFoldingRangeClientCapabilities(*iter->second);
    }

    iter = object.find("selectionRange");
    if (iter != object.end()) {
      value->selectionRange = anyToSelectionRangeClientCapabilities(*iter->second);
    }

    iter = object.find("publishDiagnostics");
    if (iter != object.end()) {
      value->publishDiagnostics = anyToPublishDiagnosticsClientCapabilities(*iter->second);
    }

    iter = object.find("callHierarchy");
    if (iter != object.end()) {
      value->callHierarchy = anyToCallHierarchyClientCapabilities(*iter->second);
    }

    iter = object.find("semanticTokens");
    if (iter != object.end()) {
      value->semanticTokens = anyToSemanticTokensClientCapabilities(*iter->second);
    }

    iter = object.find("linkedEditingRange");
    if (iter != object.end()) {
      value->linkedEditingRange = anyToLinkedEditingRangeClientCapabilities(*iter->second);
    }

    iter = object.find("moniker");
    if (iter != object.end()) {
      value->moniker = anyToMonikerClientCapabilities(*iter->second);
    }

    iter = object.find("typeHierarchy");
    if (iter != object.end()) {
      value->typeHierarchy = anyToTypeHierarchyClientCapabilities(*iter->second);
    }

    iter = object.find("inlineValue");
    if (iter != object.end()) {
      value->inlineValue = anyToInlineValueClientCapabilities(*iter->second);
    }

    iter = object.find("inlayHint");
    if (iter != object.end()) {
      value->inlayHint = anyToInlayHintClientCapabilities(*iter->second);
    }

    iter = object.find("diagnostic");
    if (iter != object.end()) {
      value->diagnostic = anyToDiagnosticClientCapabilities(*iter->second);
    }

    iter = object.find("inlineCompletion");
    if (iter != object.end()) {
      value->inlineCompletion = anyToInlineCompletionClientCapabilities(*iter->second);
    }

    return value;
  }

  auto LspTransformer::textDocumentClientCapabilitiesToAny(
    const TextDocumentClientCapabilities &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.synchronization.has_value()) {
      object.emplace("synchronization", textDocumentSyncClientCapabilitiesToAny(*structure.synchronization.value()));
    }
    if (structure.completion.has_value()) {
      object.emplace("completion", completionClientCapabilitiesToAny(*structure.completion.value()));
    }
    if (structure.hover.has_value()) {
      object.emplace("hover", hoverClientCapabilitiesToAny(*structure.hover.value()));
    }
    if (structure.signatureHelp.has_value()) {
      object.emplace("signatureHelp", signatureHelpClientCapabilitiesToAny(*structure.signatureHelp.value()));
    }
    if (structure.declaration.has_value()) {
      object.emplace("declaration", declarationClientCapabilitiesToAny(*structure.declaration.value()));
    }
    if (structure.definition.has_value()) {
      object.emplace("definition", definitionClientCapabilitiesToAny(*structure.definition.value()));
    }
    if (structure.typeDefinition.has_value()) {
      object.emplace("typeDefinition", typeDefinitionClientCapabilitiesToAny(*structure.typeDefinition.value()));
    }
    if (structure.implementation.has_value()) {
      object.emplace("implementation", implementationClientCapabilitiesToAny(*structure.implementation.value()));
    }
    if (structure.references.has_value()) {
      object.emplace("references", referenceClientCapabilitiesToAny(*structure.references.value()));
    }
    if (structure.documentHighlight.has_value()) {
      object.emplace("documentHighlight", documentHighlightClientCapabilitiesToAny(*structure.documentHighlight.value()));
    }
    if (structure.documentSymbol.has_value()) {
      object.emplace("documentSymbol", documentSymbolClientCapabilitiesToAny(*structure.documentSymbol.value()));
    }
    if (structure.codeAction.has_value()) {
      object.emplace("codeAction", codeActionClientCapabilitiesToAny(*structure.codeAction.value()));
    }
    if (structure.codeLens.has_value()) {
      object.emplace("codeLens", codeLensClientCapabilitiesToAny(*structure.codeLens.value()));
    }
    if (structure.documentLink.has_value()) {
      object.emplace("documentLink", documentLinkClientCapabilitiesToAny(*structure.documentLink.value()));
    }
    if (structure.colorProvider.has_value()) {
      object.emplace("colorProvider", documentColorClientCapabilitiesToAny(*structure.colorProvider.value()));
    }
    if (structure.formatting.has_value()) {
      object.emplace("formatting", documentFormattingClientCapabilitiesToAny(*structure.formatting.value()));
    }
    if (structure.rangeFormatting.has_value()) {
      object.emplace("rangeFormatting", documentRangeFormattingClientCapabilitiesToAny(*structure.rangeFormatting.value()));
    }
    if (structure.onTypeFormatting.has_value()) {
      object.emplace("onTypeFormatting", documentOnTypeFormattingClientCapabilitiesToAny(*structure.onTypeFormatting.value()));
    }
    if (structure.rename.has_value()) {
      object.emplace("rename", renameClientCapabilitiesToAny(*structure.rename.value()));
    }
    if (structure.foldingRange.has_value()) {
      object.emplace("foldingRange", foldingRangeClientCapabilitiesToAny(*structure.foldingRange.value()));
    }
    if (structure.selectionRange.has_value()) {
      object.emplace("selectionRange", selectionRangeClientCapabilitiesToAny(*structure.selectionRange.value()));
    }
    if (structure.publishDiagnostics.has_value()) {
      object.emplace("publishDiagnostics", publishDiagnosticsClientCapabilitiesToAny(*structure.publishDiagnostics.value()));
    }
    if (structure.callHierarchy.has_value()) {
      object.emplace("callHierarchy", callHierarchyClientCapabilitiesToAny(*structure.callHierarchy.value()));
    }
    if (structure.semanticTokens.has_value()) {
      object.emplace("semanticTokens", semanticTokensClientCapabilitiesToAny(*structure.semanticTokens.value()));
    }
    if (structure.linkedEditingRange.has_value()) {
      object.emplace("linkedEditingRange", linkedEditingRangeClientCapabilitiesToAny(*structure.linkedEditingRange.value()));
    }
    if (structure.moniker.has_value()) {
      object.emplace("moniker", monikerClientCapabilitiesToAny(*structure.moniker.value()));
    }
    if (structure.typeHierarchy.has_value()) {
      object.emplace("typeHierarchy", typeHierarchyClientCapabilitiesToAny(*structure.typeHierarchy.value()));
    }
    if (structure.inlineValue.has_value()) {
      object.emplace("inlineValue", inlineValueClientCapabilitiesToAny(*structure.inlineValue.value()));
    }
    if (structure.inlayHint.has_value()) {
      object.emplace("inlayHint", inlayHintClientCapabilitiesToAny(*structure.inlayHint.value()));
    }
    if (structure.diagnostic.has_value()) {
      object.emplace("diagnostic", diagnosticClientCapabilitiesToAny(*structure.diagnostic.value()));
    }
    if (structure.inlineCompletion.has_value()) {
      object.emplace("inlineCompletion", inlineCompletionClientCapabilitiesToAny(*structure.inlineCompletion.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToNotebookDocumentClientCapabilities(
    const LSPAny &any
  ) const -> std::unique_ptr<NotebookDocumentClientCapabilities> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) NotebookDocumentClientCapabilities must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<NotebookDocumentClientCapabilities> value =
      std::make_unique<NotebookDocumentClientCapabilities>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) NotebookDocumentClientCapabilities: " + std::to_string(object.size())
      );
    }

    iter = object.find("synchronization");
    if (iter != object.end()) {
      value->synchronization = anyToNotebookDocumentSyncClientCapabilities(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required NotebookDocumentClientCapabilities attribute: synchronization"
      );
    }

    return value;
  }

  auto LspTransformer::notebookDocumentClientCapabilitiesToAny(
    const NotebookDocumentClientCapabilities &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("synchronization", notebookDocumentSyncClientCapabilitiesToAny(*structure.synchronization));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToWindowClientCapabilities(
    const LSPAny &any
  ) const -> std::unique_ptr<WindowClientCapabilities> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) WindowClientCapabilities must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<WindowClientCapabilities> value =
      std::make_unique<WindowClientCapabilities>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) WindowClientCapabilities: " + std::to_string(object.size())
      );
    }

    iter = object.find("workDoneProgress");
    if (iter != object.end()) {
      value->workDoneProgress = anyToBoolean(*iter->second);
    }

    iter = object.find("showMessage");
    if (iter != object.end()) {
      value->showMessage = anyToShowMessageRequestClientCapabilities(*iter->second);
    }

    iter = object.find("showDocument");
    if (iter != object.end()) {
      value->showDocument = anyToShowDocumentClientCapabilities(*iter->second);
    }

    return value;
  }

  auto LspTransformer::windowClientCapabilitiesToAny(
    const WindowClientCapabilities &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.workDoneProgress.has_value()) {
      object.emplace("workDoneProgress", booleanToAny(structure.workDoneProgress.value()));
    }
    if (structure.showMessage.has_value()) {
      object.emplace("showMessage", showMessageRequestClientCapabilitiesToAny(*structure.showMessage.value()));
    }
    if (structure.showDocument.has_value()) {
      object.emplace("showDocument", showDocumentClientCapabilitiesToAny(*structure.showDocument.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToGeneralClientCapabilities_staleRequestSupport(
    const LSPAny &any
  ) const -> std::unique_ptr<GeneralClientCapabilities_staleRequestSupport> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) GeneralClientCapabilities_staleRequestSupport must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<GeneralClientCapabilities_staleRequestSupport> value =
      std::make_unique<GeneralClientCapabilities_staleRequestSupport>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) GeneralClientCapabilities_staleRequestSupport: " + std::to_string(object.size())
      );
    }

    iter = object.find("cancel");
    if (iter != object.end()) {
      value->cancel = anyToBoolean(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required GeneralClientCapabilities_staleRequestSupport attribute: cancel"
      );
    }

    iter = object.find("retryOnContentModified");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<string_t> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToString(*elem));
      }
      value->retryOnContentModified = std::move(values);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required GeneralClientCapabilities_staleRequestSupport attribute: retryOnContentModified"
      );
    }

    return value;
  }

  auto LspTransformer::generalClientCapabilities_staleRequestSupportToAny(
    const GeneralClientCapabilities_staleRequestSupport &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("cancel", booleanToAny(structure.cancel));
    {
      LSPArray array;
      for (const string_t &elem : structure.retryOnContentModified) {
        array.push_back(stringToAny(elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("retryOnContentModified", std::move(any));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToGeneralClientCapabilities(
    const LSPAny &any
  ) const -> std::unique_ptr<GeneralClientCapabilities> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) GeneralClientCapabilities must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<GeneralClientCapabilities> value =
      std::make_unique<GeneralClientCapabilities>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 4) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) GeneralClientCapabilities: " + std::to_string(object.size())
      );
    }

    iter = object.find("staleRequestSupport");
    if (iter != object.end()) {
      value->staleRequestSupport = anyToGeneralClientCapabilities_staleRequestSupport(*iter->second);
    }

    iter = object.find("regularExpressions");
    if (iter != object.end()) {
      value->regularExpressions = anyToRegularExpressionsClientCapabilities(*iter->second);
    }

    iter = object.find("markdown");
    if (iter != object.end()) {
      value->markdown = anyToMarkdownClientCapabilities(*iter->second);
    }

    iter = object.find("positionEncodings");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<PositionEncodingKind> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToPositionEncodingKind(*elem));
      }
      value->positionEncodings = std::move(values);
    }

    return value;
  }

  auto LspTransformer::generalClientCapabilitiesToAny(
    const GeneralClientCapabilities &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.staleRequestSupport.has_value()) {
      object.emplace("staleRequestSupport", generalClientCapabilities_staleRequestSupportToAny(*structure.staleRequestSupport.value()));
    }
    if (structure.regularExpressions.has_value()) {
      object.emplace("regularExpressions", regularExpressionsClientCapabilitiesToAny(*structure.regularExpressions.value()));
    }
    if (structure.markdown.has_value()) {
      object.emplace("markdown", markdownClientCapabilitiesToAny(*structure.markdown.value()));
    }
    if (structure.positionEncodings.has_value()) {
      LSPArray array;
      for (const PositionEncodingKind &elem : structure.positionEncodings.value()) {
        array.push_back(positionEncodingKindToAny(elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("positionEncodings", std::move(any));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToRelativePattern_baseUri(
    const LSPAny &any
  ) const -> RelativePattern_baseUri {
    RelativePattern_baseUri value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::OBJECT_TYPE: {
      try {
        value = anyToWorkspaceFolder(any);
      } catch (LspException &e) {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          "Failed to transform LSPAny to RelativePattern_baseUri"
        );
      }
      break;
    }
    case LSPAnyType::STRING_TYPE: {
      value = anyToString(any);
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) RelativePattern_baseUri: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::relativePattern_baseUriToAny(
    const RelativePattern_baseUri &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<RelativePattern_baseUriType>(variant.index())) {
    case RelativePattern_baseUriType::WORKSPACE_FOLDER: {
      return workspaceFolderToAny(
        *std::get<std::unique_ptr<WorkspaceFolder>>(variant)
      );
    }
    case RelativePattern_baseUriType::URI: {
      return uriToAny(
        std::get<URI>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported RelativePattern_baseUriType: " +
         RelativePattern_baseUriTypeNames.at(static_cast<RelativePattern_baseUriType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToRelativePattern(
    const LSPAny &any
  ) const -> std::unique_ptr<RelativePattern> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) RelativePattern must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<RelativePattern> value =
      std::make_unique<RelativePattern>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) RelativePattern: " + std::to_string(object.size())
      );
    }

    iter = object.find("baseUri");
    if (iter != object.end()) {
      value->baseUri = anyToRelativePattern_baseUri(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required RelativePattern attribute: baseUri"
      );
    }

    iter = object.find("pattern");
    if (iter != object.end()) {
      value->pattern = anyToPattern(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required RelativePattern attribute: pattern"
      );
    }

    return value;
  }

  auto LspTransformer::relativePatternToAny(
    const RelativePattern &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("baseUri", relativePattern_baseUriToAny(structure.baseUri));
    object.emplace("pattern", patternToAny(structure.pattern));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToWorkspaceEditClientCapabilities_changeAnnotationSupport(
    const LSPAny &any
  ) const -> std::unique_ptr<WorkspaceEditClientCapabilities_changeAnnotationSupport> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) WorkspaceEditClientCapabilities_changeAnnotationSupport must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<WorkspaceEditClientCapabilities_changeAnnotationSupport> value =
      std::make_unique<WorkspaceEditClientCapabilities_changeAnnotationSupport>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) WorkspaceEditClientCapabilities_changeAnnotationSupport: " + std::to_string(object.size())
      );
    }

    iter = object.find("groupsOnLabel");
    if (iter != object.end()) {
      value->groupsOnLabel = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::workspaceEditClientCapabilities_changeAnnotationSupportToAny(
    const WorkspaceEditClientCapabilities_changeAnnotationSupport &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.groupsOnLabel.has_value()) {
      object.emplace("groupsOnLabel", booleanToAny(structure.groupsOnLabel.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToWorkspaceEditClientCapabilities(
    const LSPAny &any
  ) const -> std::unique_ptr<WorkspaceEditClientCapabilities> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) WorkspaceEditClientCapabilities must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<WorkspaceEditClientCapabilities> value =
      std::make_unique<WorkspaceEditClientCapabilities>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 5) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) WorkspaceEditClientCapabilities: " + std::to_string(object.size())
      );
    }

    iter = object.find("documentChanges");
    if (iter != object.end()) {
      value->documentChanges = anyToBoolean(*iter->second);
    }

    iter = object.find("resourceOperations");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<ResourceOperationKind> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToResourceOperationKind(*elem));
      }
      value->resourceOperations = std::move(values);
    }

    iter = object.find("failureHandling");
    if (iter != object.end()) {
      value->failureHandling = anyToFailureHandlingKind(*iter->second);
    }

    iter = object.find("normalizesLineEndings");
    if (iter != object.end()) {
      value->normalizesLineEndings = anyToBoolean(*iter->second);
    }

    iter = object.find("changeAnnotationSupport");
    if (iter != object.end()) {
      value->changeAnnotationSupport = anyToWorkspaceEditClientCapabilities_changeAnnotationSupport(*iter->second);
    }

    return value;
  }

  auto LspTransformer::workspaceEditClientCapabilitiesToAny(
    const WorkspaceEditClientCapabilities &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.documentChanges.has_value()) {
      object.emplace("documentChanges", booleanToAny(structure.documentChanges.value()));
    }
    if (structure.resourceOperations.has_value()) {
      LSPArray array;
      for (const ResourceOperationKind &elem : structure.resourceOperations.value()) {
        array.push_back(resourceOperationKindToAny(elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("resourceOperations", std::move(any));
    }
    if (structure.failureHandling.has_value()) {
      object.emplace("failureHandling", failureHandlingKindToAny(structure.failureHandling.value()));
    }
    if (structure.normalizesLineEndings.has_value()) {
      object.emplace("normalizesLineEndings", booleanToAny(structure.normalizesLineEndings.value()));
    }
    if (structure.changeAnnotationSupport.has_value()) {
      object.emplace("changeAnnotationSupport", workspaceEditClientCapabilities_changeAnnotationSupportToAny(*structure.changeAnnotationSupport.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToDidChangeConfigurationClientCapabilities(
    const LSPAny &any
  ) const -> std::unique_ptr<DidChangeConfigurationClientCapabilities> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) DidChangeConfigurationClientCapabilities must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<DidChangeConfigurationClientCapabilities> value =
      std::make_unique<DidChangeConfigurationClientCapabilities>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) DidChangeConfigurationClientCapabilities: " + std::to_string(object.size())
      );
    }

    iter = object.find("dynamicRegistration");
    if (iter != object.end()) {
      value->dynamicRegistration = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::didChangeConfigurationClientCapabilitiesToAny(
    const DidChangeConfigurationClientCapabilities &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.dynamicRegistration.has_value()) {
      object.emplace("dynamicRegistration", booleanToAny(structure.dynamicRegistration.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToDidChangeWatchedFilesClientCapabilities(
    const LSPAny &any
  ) const -> std::unique_ptr<DidChangeWatchedFilesClientCapabilities> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) DidChangeWatchedFilesClientCapabilities must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<DidChangeWatchedFilesClientCapabilities> value =
      std::make_unique<DidChangeWatchedFilesClientCapabilities>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) DidChangeWatchedFilesClientCapabilities: " + std::to_string(object.size())
      );
    }

    iter = object.find("dynamicRegistration");
    if (iter != object.end()) {
      value->dynamicRegistration = anyToBoolean(*iter->second);
    }

    iter = object.find("relativePatternSupport");
    if (iter != object.end()) {
      value->relativePatternSupport = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::didChangeWatchedFilesClientCapabilitiesToAny(
    const DidChangeWatchedFilesClientCapabilities &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.dynamicRegistration.has_value()) {
      object.emplace("dynamicRegistration", booleanToAny(structure.dynamicRegistration.value()));
    }
    if (structure.relativePatternSupport.has_value()) {
      object.emplace("relativePatternSupport", booleanToAny(structure.relativePatternSupport.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToWorkspaceSymbolClientCapabilities_symbolKind(
    const LSPAny &any
  ) const -> std::unique_ptr<WorkspaceSymbolClientCapabilities_symbolKind> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) WorkspaceSymbolClientCapabilities_symbolKind must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<WorkspaceSymbolClientCapabilities_symbolKind> value =
      std::make_unique<WorkspaceSymbolClientCapabilities_symbolKind>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) WorkspaceSymbolClientCapabilities_symbolKind: " + std::to_string(object.size())
      );
    }

    iter = object.find("valueSet");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<SymbolKind> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToSymbolKind(*elem));
      }
      value->valueSet = std::move(values);
    }

    return value;
  }

  auto LspTransformer::workspaceSymbolClientCapabilities_symbolKindToAny(
    const WorkspaceSymbolClientCapabilities_symbolKind &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.valueSet.has_value()) {
      LSPArray array;
      for (const SymbolKind &elem : structure.valueSet.value()) {
        array.push_back(symbolKindToAny(elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("valueSet", std::move(any));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToWorkspaceSymbolClientCapabilities_tagSupport(
    const LSPAny &any
  ) const -> std::unique_ptr<WorkspaceSymbolClientCapabilities_tagSupport> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) WorkspaceSymbolClientCapabilities_tagSupport must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<WorkspaceSymbolClientCapabilities_tagSupport> value =
      std::make_unique<WorkspaceSymbolClientCapabilities_tagSupport>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) WorkspaceSymbolClientCapabilities_tagSupport: " + std::to_string(object.size())
      );
    }

    iter = object.find("valueSet");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<SymbolTag> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToSymbolTag(*elem));
      }
      value->valueSet = std::move(values);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required WorkspaceSymbolClientCapabilities_tagSupport attribute: valueSet"
      );
    }

    return value;
  }

  auto LspTransformer::workspaceSymbolClientCapabilities_tagSupportToAny(
    const WorkspaceSymbolClientCapabilities_tagSupport &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    {
      LSPArray array;
      for (const SymbolTag &elem : structure.valueSet) {
        array.push_back(symbolTagToAny(elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("valueSet", std::move(any));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToWorkspaceSymbolClientCapabilities_resolveSupport(
    const LSPAny &any
  ) const -> std::unique_ptr<WorkspaceSymbolClientCapabilities_resolveSupport> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) WorkspaceSymbolClientCapabilities_resolveSupport must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<WorkspaceSymbolClientCapabilities_resolveSupport> value =
      std::make_unique<WorkspaceSymbolClientCapabilities_resolveSupport>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) WorkspaceSymbolClientCapabilities_resolveSupport: " + std::to_string(object.size())
      );
    }

    iter = object.find("properties");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<string_t> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToString(*elem));
      }
      value->properties = std::move(values);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required WorkspaceSymbolClientCapabilities_resolveSupport attribute: properties"
      );
    }

    return value;
  }

  auto LspTransformer::workspaceSymbolClientCapabilities_resolveSupportToAny(
    const WorkspaceSymbolClientCapabilities_resolveSupport &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    {
      LSPArray array;
      for (const string_t &elem : structure.properties) {
        array.push_back(stringToAny(elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("properties", std::move(any));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToWorkspaceSymbolClientCapabilities(
    const LSPAny &any
  ) const -> std::unique_ptr<WorkspaceSymbolClientCapabilities> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) WorkspaceSymbolClientCapabilities must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<WorkspaceSymbolClientCapabilities> value =
      std::make_unique<WorkspaceSymbolClientCapabilities>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 4) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) WorkspaceSymbolClientCapabilities: " + std::to_string(object.size())
      );
    }

    iter = object.find("dynamicRegistration");
    if (iter != object.end()) {
      value->dynamicRegistration = anyToBoolean(*iter->second);
    }

    iter = object.find("symbolKind");
    if (iter != object.end()) {
      value->symbolKind = anyToWorkspaceSymbolClientCapabilities_symbolKind(*iter->second);
    }

    iter = object.find("tagSupport");
    if (iter != object.end()) {
      value->tagSupport = anyToWorkspaceSymbolClientCapabilities_tagSupport(*iter->second);
    }

    iter = object.find("resolveSupport");
    if (iter != object.end()) {
      value->resolveSupport = anyToWorkspaceSymbolClientCapabilities_resolveSupport(*iter->second);
    }

    return value;
  }

  auto LspTransformer::workspaceSymbolClientCapabilitiesToAny(
    const WorkspaceSymbolClientCapabilities &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.dynamicRegistration.has_value()) {
      object.emplace("dynamicRegistration", booleanToAny(structure.dynamicRegistration.value()));
    }
    if (structure.symbolKind.has_value()) {
      object.emplace("symbolKind", workspaceSymbolClientCapabilities_symbolKindToAny(*structure.symbolKind.value()));
    }
    if (structure.tagSupport.has_value()) {
      object.emplace("tagSupport", workspaceSymbolClientCapabilities_tagSupportToAny(*structure.tagSupport.value()));
    }
    if (structure.resolveSupport.has_value()) {
      object.emplace("resolveSupport", workspaceSymbolClientCapabilities_resolveSupportToAny(*structure.resolveSupport.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToExecuteCommandClientCapabilities(
    const LSPAny &any
  ) const -> std::unique_ptr<ExecuteCommandClientCapabilities> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) ExecuteCommandClientCapabilities must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<ExecuteCommandClientCapabilities> value =
      std::make_unique<ExecuteCommandClientCapabilities>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) ExecuteCommandClientCapabilities: " + std::to_string(object.size())
      );
    }

    iter = object.find("dynamicRegistration");
    if (iter != object.end()) {
      value->dynamicRegistration = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::executeCommandClientCapabilitiesToAny(
    const ExecuteCommandClientCapabilities &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.dynamicRegistration.has_value()) {
      object.emplace("dynamicRegistration", booleanToAny(structure.dynamicRegistration.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToSemanticTokensWorkspaceClientCapabilities(
    const LSPAny &any
  ) const -> std::unique_ptr<SemanticTokensWorkspaceClientCapabilities> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) SemanticTokensWorkspaceClientCapabilities must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<SemanticTokensWorkspaceClientCapabilities> value =
      std::make_unique<SemanticTokensWorkspaceClientCapabilities>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) SemanticTokensWorkspaceClientCapabilities: " + std::to_string(object.size())
      );
    }

    iter = object.find("refreshSupport");
    if (iter != object.end()) {
      value->refreshSupport = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::semanticTokensWorkspaceClientCapabilitiesToAny(
    const SemanticTokensWorkspaceClientCapabilities &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.refreshSupport.has_value()) {
      object.emplace("refreshSupport", booleanToAny(structure.refreshSupport.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToCodeLensWorkspaceClientCapabilities(
    const LSPAny &any
  ) const -> std::unique_ptr<CodeLensWorkspaceClientCapabilities> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) CodeLensWorkspaceClientCapabilities must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<CodeLensWorkspaceClientCapabilities> value =
      std::make_unique<CodeLensWorkspaceClientCapabilities>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) CodeLensWorkspaceClientCapabilities: " + std::to_string(object.size())
      );
    }

    iter = object.find("refreshSupport");
    if (iter != object.end()) {
      value->refreshSupport = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::codeLensWorkspaceClientCapabilitiesToAny(
    const CodeLensWorkspaceClientCapabilities &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.refreshSupport.has_value()) {
      object.emplace("refreshSupport", booleanToAny(structure.refreshSupport.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToFileOperationClientCapabilities(
    const LSPAny &any
  ) const -> std::unique_ptr<FileOperationClientCapabilities> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) FileOperationClientCapabilities must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<FileOperationClientCapabilities> value =
      std::make_unique<FileOperationClientCapabilities>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 7) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) FileOperationClientCapabilities: " + std::to_string(object.size())
      );
    }

    iter = object.find("dynamicRegistration");
    if (iter != object.end()) {
      value->dynamicRegistration = anyToBoolean(*iter->second);
    }

    iter = object.find("didCreate");
    if (iter != object.end()) {
      value->didCreate = anyToBoolean(*iter->second);
    }

    iter = object.find("willCreate");
    if (iter != object.end()) {
      value->willCreate = anyToBoolean(*iter->second);
    }

    iter = object.find("didRename");
    if (iter != object.end()) {
      value->didRename = anyToBoolean(*iter->second);
    }

    iter = object.find("willRename");
    if (iter != object.end()) {
      value->willRename = anyToBoolean(*iter->second);
    }

    iter = object.find("didDelete");
    if (iter != object.end()) {
      value->didDelete = anyToBoolean(*iter->second);
    }

    iter = object.find("willDelete");
    if (iter != object.end()) {
      value->willDelete = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::fileOperationClientCapabilitiesToAny(
    const FileOperationClientCapabilities &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.dynamicRegistration.has_value()) {
      object.emplace("dynamicRegistration", booleanToAny(structure.dynamicRegistration.value()));
    }
    if (structure.didCreate.has_value()) {
      object.emplace("didCreate", booleanToAny(structure.didCreate.value()));
    }
    if (structure.willCreate.has_value()) {
      object.emplace("willCreate", booleanToAny(structure.willCreate.value()));
    }
    if (structure.didRename.has_value()) {
      object.emplace("didRename", booleanToAny(structure.didRename.value()));
    }
    if (structure.willRename.has_value()) {
      object.emplace("willRename", booleanToAny(structure.willRename.value()));
    }
    if (structure.didDelete.has_value()) {
      object.emplace("didDelete", booleanToAny(structure.didDelete.value()));
    }
    if (structure.willDelete.has_value()) {
      object.emplace("willDelete", booleanToAny(structure.willDelete.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToInlineValueWorkspaceClientCapabilities(
    const LSPAny &any
  ) const -> std::unique_ptr<InlineValueWorkspaceClientCapabilities> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) InlineValueWorkspaceClientCapabilities must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<InlineValueWorkspaceClientCapabilities> value =
      std::make_unique<InlineValueWorkspaceClientCapabilities>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) InlineValueWorkspaceClientCapabilities: " + std::to_string(object.size())
      );
    }

    iter = object.find("refreshSupport");
    if (iter != object.end()) {
      value->refreshSupport = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::inlineValueWorkspaceClientCapabilitiesToAny(
    const InlineValueWorkspaceClientCapabilities &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.refreshSupport.has_value()) {
      object.emplace("refreshSupport", booleanToAny(structure.refreshSupport.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToInlayHintWorkspaceClientCapabilities(
    const LSPAny &any
  ) const -> std::unique_ptr<InlayHintWorkspaceClientCapabilities> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) InlayHintWorkspaceClientCapabilities must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<InlayHintWorkspaceClientCapabilities> value =
      std::make_unique<InlayHintWorkspaceClientCapabilities>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) InlayHintWorkspaceClientCapabilities: " + std::to_string(object.size())
      );
    }

    iter = object.find("refreshSupport");
    if (iter != object.end()) {
      value->refreshSupport = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::inlayHintWorkspaceClientCapabilitiesToAny(
    const InlayHintWorkspaceClientCapabilities &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.refreshSupport.has_value()) {
      object.emplace("refreshSupport", booleanToAny(structure.refreshSupport.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToDiagnosticWorkspaceClientCapabilities(
    const LSPAny &any
  ) const -> std::unique_ptr<DiagnosticWorkspaceClientCapabilities> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) DiagnosticWorkspaceClientCapabilities must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<DiagnosticWorkspaceClientCapabilities> value =
      std::make_unique<DiagnosticWorkspaceClientCapabilities>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) DiagnosticWorkspaceClientCapabilities: " + std::to_string(object.size())
      );
    }

    iter = object.find("refreshSupport");
    if (iter != object.end()) {
      value->refreshSupport = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::diagnosticWorkspaceClientCapabilitiesToAny(
    const DiagnosticWorkspaceClientCapabilities &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.refreshSupport.has_value()) {
      object.emplace("refreshSupport", booleanToAny(structure.refreshSupport.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToFoldingRangeWorkspaceClientCapabilities(
    const LSPAny &any
  ) const -> std::unique_ptr<FoldingRangeWorkspaceClientCapabilities> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) FoldingRangeWorkspaceClientCapabilities must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<FoldingRangeWorkspaceClientCapabilities> value =
      std::make_unique<FoldingRangeWorkspaceClientCapabilities>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) FoldingRangeWorkspaceClientCapabilities: " + std::to_string(object.size())
      );
    }

    iter = object.find("refreshSupport");
    if (iter != object.end()) {
      value->refreshSupport = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::foldingRangeWorkspaceClientCapabilitiesToAny(
    const FoldingRangeWorkspaceClientCapabilities &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.refreshSupport.has_value()) {
      object.emplace("refreshSupport", booleanToAny(structure.refreshSupport.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToTextDocumentSyncClientCapabilities(
    const LSPAny &any
  ) const -> std::unique_ptr<TextDocumentSyncClientCapabilities> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) TextDocumentSyncClientCapabilities must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<TextDocumentSyncClientCapabilities> value =
      std::make_unique<TextDocumentSyncClientCapabilities>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 4) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) TextDocumentSyncClientCapabilities: " + std::to_string(object.size())
      );
    }

    iter = object.find("dynamicRegistration");
    if (iter != object.end()) {
      value->dynamicRegistration = anyToBoolean(*iter->second);
    }

    iter = object.find("willSave");
    if (iter != object.end()) {
      value->willSave = anyToBoolean(*iter->second);
    }

    iter = object.find("willSaveWaitUntil");
    if (iter != object.end()) {
      value->willSaveWaitUntil = anyToBoolean(*iter->second);
    }

    iter = object.find("didSave");
    if (iter != object.end()) {
      value->didSave = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::textDocumentSyncClientCapabilitiesToAny(
    const TextDocumentSyncClientCapabilities &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.dynamicRegistration.has_value()) {
      object.emplace("dynamicRegistration", booleanToAny(structure.dynamicRegistration.value()));
    }
    if (structure.willSave.has_value()) {
      object.emplace("willSave", booleanToAny(structure.willSave.value()));
    }
    if (structure.willSaveWaitUntil.has_value()) {
      object.emplace("willSaveWaitUntil", booleanToAny(structure.willSaveWaitUntil.value()));
    }
    if (structure.didSave.has_value()) {
      object.emplace("didSave", booleanToAny(structure.didSave.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToCompletionClientCapabilities_completionItem_insertTextModeSupport(
    const LSPAny &any
  ) const -> std::unique_ptr<CompletionClientCapabilities_completionItem_insertTextModeSupport> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) CompletionClientCapabilities_completionItem_insertTextModeSupport must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<CompletionClientCapabilities_completionItem_insertTextModeSupport> value =
      std::make_unique<CompletionClientCapabilities_completionItem_insertTextModeSupport>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) CompletionClientCapabilities_completionItem_insertTextModeSupport: " + std::to_string(object.size())
      );
    }

    iter = object.find("valueSet");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<InsertTextMode> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToInsertTextMode(*elem));
      }
      value->valueSet = std::move(values);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required CompletionClientCapabilities_completionItem_insertTextModeSupport attribute: valueSet"
      );
    }

    return value;
  }

  auto LspTransformer::completionClientCapabilities_completionItem_insertTextModeSupportToAny(
    const CompletionClientCapabilities_completionItem_insertTextModeSupport &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    {
      LSPArray array;
      for (const InsertTextMode &elem : structure.valueSet) {
        array.push_back(insertTextModeToAny(elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("valueSet", std::move(any));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToCompletionClientCapabilities_completionItem_resolveSupport(
    const LSPAny &any
  ) const -> std::unique_ptr<CompletionClientCapabilities_completionItem_resolveSupport> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) CompletionClientCapabilities_completionItem_resolveSupport must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<CompletionClientCapabilities_completionItem_resolveSupport> value =
      std::make_unique<CompletionClientCapabilities_completionItem_resolveSupport>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) CompletionClientCapabilities_completionItem_resolveSupport: " + std::to_string(object.size())
      );
    }

    iter = object.find("properties");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<string_t> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToString(*elem));
      }
      value->properties = std::move(values);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required CompletionClientCapabilities_completionItem_resolveSupport attribute: properties"
      );
    }

    return value;
  }

  auto LspTransformer::completionClientCapabilities_completionItem_resolveSupportToAny(
    const CompletionClientCapabilities_completionItem_resolveSupport &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    {
      LSPArray array;
      for (const string_t &elem : structure.properties) {
        array.push_back(stringToAny(elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("properties", std::move(any));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToCompletionClientCapabilities_completionItem_tagSupport(
    const LSPAny &any
  ) const -> std::unique_ptr<CompletionClientCapabilities_completionItem_tagSupport> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) CompletionClientCapabilities_completionItem_tagSupport must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<CompletionClientCapabilities_completionItem_tagSupport> value =
      std::make_unique<CompletionClientCapabilities_completionItem_tagSupport>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) CompletionClientCapabilities_completionItem_tagSupport: " + std::to_string(object.size())
      );
    }

    iter = object.find("valueSet");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<CompletionItemTag> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToCompletionItemTag(*elem));
      }
      value->valueSet = std::move(values);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required CompletionClientCapabilities_completionItem_tagSupport attribute: valueSet"
      );
    }

    return value;
  }

  auto LspTransformer::completionClientCapabilities_completionItem_tagSupportToAny(
    const CompletionClientCapabilities_completionItem_tagSupport &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    {
      LSPArray array;
      for (const CompletionItemTag &elem : structure.valueSet) {
        array.push_back(completionItemTagToAny(elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("valueSet", std::move(any));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToCompletionClientCapabilities_completionItem(
    const LSPAny &any
  ) const -> std::unique_ptr<CompletionClientCapabilities_completionItem> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) CompletionClientCapabilities_completionItem must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<CompletionClientCapabilities_completionItem> value =
      std::make_unique<CompletionClientCapabilities_completionItem>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 10) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) CompletionClientCapabilities_completionItem: " + std::to_string(object.size())
      );
    }

    iter = object.find("snippetSupport");
    if (iter != object.end()) {
      value->snippetSupport = anyToBoolean(*iter->second);
    }

    iter = object.find("commitCharactersSupport");
    if (iter != object.end()) {
      value->commitCharactersSupport = anyToBoolean(*iter->second);
    }

    iter = object.find("documentationFormat");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<MarkupKind> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToMarkupKind(*elem));
      }
      value->documentationFormat = std::move(values);
    }

    iter = object.find("deprecatedSupport");
    if (iter != object.end()) {
      value->deprecatedSupport = anyToBoolean(*iter->second);
    }

    iter = object.find("preselectSupport");
    if (iter != object.end()) {
      value->preselectSupport = anyToBoolean(*iter->second);
    }

    iter = object.find("tagSupport");
    if (iter != object.end()) {
      value->tagSupport = anyToCompletionClientCapabilities_completionItem_tagSupport(*iter->second);
    }

    iter = object.find("insertReplaceSupport");
    if (iter != object.end()) {
      value->insertReplaceSupport = anyToBoolean(*iter->second);
    }

    iter = object.find("resolveSupport");
    if (iter != object.end()) {
      value->resolveSupport = anyToCompletionClientCapabilities_completionItem_resolveSupport(*iter->second);
    }

    iter = object.find("insertTextModeSupport");
    if (iter != object.end()) {
      value->insertTextModeSupport = anyToCompletionClientCapabilities_completionItem_insertTextModeSupport(*iter->second);
    }

    iter = object.find("labelDetailsSupport");
    if (iter != object.end()) {
      value->labelDetailsSupport = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::completionClientCapabilities_completionItemToAny(
    const CompletionClientCapabilities_completionItem &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.snippetSupport.has_value()) {
      object.emplace("snippetSupport", booleanToAny(structure.snippetSupport.value()));
    }
    if (structure.commitCharactersSupport.has_value()) {
      object.emplace("commitCharactersSupport", booleanToAny(structure.commitCharactersSupport.value()));
    }
    if (structure.documentationFormat.has_value()) {
      LSPArray array;
      for (const MarkupKind &elem : structure.documentationFormat.value()) {
        array.push_back(markupKindToAny(elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("documentationFormat", std::move(any));
    }
    if (structure.deprecatedSupport.has_value()) {
      object.emplace("deprecatedSupport", booleanToAny(structure.deprecatedSupport.value()));
    }
    if (structure.preselectSupport.has_value()) {
      object.emplace("preselectSupport", booleanToAny(structure.preselectSupport.value()));
    }
    if (structure.tagSupport.has_value()) {
      object.emplace("tagSupport", completionClientCapabilities_completionItem_tagSupportToAny(*structure.tagSupport.value()));
    }
    if (structure.insertReplaceSupport.has_value()) {
      object.emplace("insertReplaceSupport", booleanToAny(structure.insertReplaceSupport.value()));
    }
    if (structure.resolveSupport.has_value()) {
      object.emplace("resolveSupport", completionClientCapabilities_completionItem_resolveSupportToAny(*structure.resolveSupport.value()));
    }
    if (structure.insertTextModeSupport.has_value()) {
      object.emplace("insertTextModeSupport", completionClientCapabilities_completionItem_insertTextModeSupportToAny(*structure.insertTextModeSupport.value()));
    }
    if (structure.labelDetailsSupport.has_value()) {
      object.emplace("labelDetailsSupport", booleanToAny(structure.labelDetailsSupport.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToCompletionClientCapabilities_completionItemKind(
    const LSPAny &any
  ) const -> std::unique_ptr<CompletionClientCapabilities_completionItemKind> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) CompletionClientCapabilities_completionItemKind must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<CompletionClientCapabilities_completionItemKind> value =
      std::make_unique<CompletionClientCapabilities_completionItemKind>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) CompletionClientCapabilities_completionItemKind: " + std::to_string(object.size())
      );
    }

    iter = object.find("valueSet");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<CompletionItemKind> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToCompletionItemKind(*elem));
      }
      value->valueSet = std::move(values);
    }

    return value;
  }

  auto LspTransformer::completionClientCapabilities_completionItemKindToAny(
    const CompletionClientCapabilities_completionItemKind &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.valueSet.has_value()) {
      LSPArray array;
      for (const CompletionItemKind &elem : structure.valueSet.value()) {
        array.push_back(completionItemKindToAny(elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("valueSet", std::move(any));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToCompletionClientCapabilities_completionList(
    const LSPAny &any
  ) const -> std::unique_ptr<CompletionClientCapabilities_completionList> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) CompletionClientCapabilities_completionList must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<CompletionClientCapabilities_completionList> value =
      std::make_unique<CompletionClientCapabilities_completionList>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) CompletionClientCapabilities_completionList: " + std::to_string(object.size())
      );
    }

    iter = object.find("itemDefaults");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<string_t> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToString(*elem));
      }
      value->itemDefaults = std::move(values);
    }

    return value;
  }

  auto LspTransformer::completionClientCapabilities_completionListToAny(
    const CompletionClientCapabilities_completionList &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.itemDefaults.has_value()) {
      LSPArray array;
      for (const string_t &elem : structure.itemDefaults.value()) {
        array.push_back(stringToAny(elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("itemDefaults", std::move(any));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToCompletionClientCapabilities(
    const LSPAny &any
  ) const -> std::unique_ptr<CompletionClientCapabilities> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) CompletionClientCapabilities must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<CompletionClientCapabilities> value =
      std::make_unique<CompletionClientCapabilities>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 6) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) CompletionClientCapabilities: " + std::to_string(object.size())
      );
    }

    iter = object.find("dynamicRegistration");
    if (iter != object.end()) {
      value->dynamicRegistration = anyToBoolean(*iter->second);
    }

    iter = object.find("completionItem");
    if (iter != object.end()) {
      value->completionItem = anyToCompletionClientCapabilities_completionItem(*iter->second);
    }

    iter = object.find("completionItemKind");
    if (iter != object.end()) {
      value->completionItemKind = anyToCompletionClientCapabilities_completionItemKind(*iter->second);
    }

    iter = object.find("insertTextMode");
    if (iter != object.end()) {
      value->insertTextMode = anyToInsertTextMode(*iter->second);
    }

    iter = object.find("contextSupport");
    if (iter != object.end()) {
      value->contextSupport = anyToBoolean(*iter->second);
    }

    iter = object.find("completionList");
    if (iter != object.end()) {
      value->completionList = anyToCompletionClientCapabilities_completionList(*iter->second);
    }

    return value;
  }

  auto LspTransformer::completionClientCapabilitiesToAny(
    const CompletionClientCapabilities &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.dynamicRegistration.has_value()) {
      object.emplace("dynamicRegistration", booleanToAny(structure.dynamicRegistration.value()));
    }
    if (structure.completionItem.has_value()) {
      object.emplace("completionItem", completionClientCapabilities_completionItemToAny(*structure.completionItem.value()));
    }
    if (structure.completionItemKind.has_value()) {
      object.emplace("completionItemKind", completionClientCapabilities_completionItemKindToAny(*structure.completionItemKind.value()));
    }
    if (structure.insertTextMode.has_value()) {
      object.emplace("insertTextMode", insertTextModeToAny(structure.insertTextMode.value()));
    }
    if (structure.contextSupport.has_value()) {
      object.emplace("contextSupport", booleanToAny(structure.contextSupport.value()));
    }
    if (structure.completionList.has_value()) {
      object.emplace("completionList", completionClientCapabilities_completionListToAny(*structure.completionList.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToHoverClientCapabilities(
    const LSPAny &any
  ) const -> std::unique_ptr<HoverClientCapabilities> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) HoverClientCapabilities must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<HoverClientCapabilities> value =
      std::make_unique<HoverClientCapabilities>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) HoverClientCapabilities: " + std::to_string(object.size())
      );
    }

    iter = object.find("dynamicRegistration");
    if (iter != object.end()) {
      value->dynamicRegistration = anyToBoolean(*iter->second);
    }

    iter = object.find("contentFormat");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<MarkupKind> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToMarkupKind(*elem));
      }
      value->contentFormat = std::move(values);
    }

    return value;
  }

  auto LspTransformer::hoverClientCapabilitiesToAny(
    const HoverClientCapabilities &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.dynamicRegistration.has_value()) {
      object.emplace("dynamicRegistration", booleanToAny(structure.dynamicRegistration.value()));
    }
    if (structure.contentFormat.has_value()) {
      LSPArray array;
      for (const MarkupKind &elem : structure.contentFormat.value()) {
        array.push_back(markupKindToAny(elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("contentFormat", std::move(any));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToSignatureHelpClientCapabilities_signatureInformation_parameterInformation(
    const LSPAny &any
  ) const -> std::unique_ptr<SignatureHelpClientCapabilities_signatureInformation_parameterInformation> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) SignatureHelpClientCapabilities_signatureInformation_parameterInformation must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<SignatureHelpClientCapabilities_signatureInformation_parameterInformation> value =
      std::make_unique<SignatureHelpClientCapabilities_signatureInformation_parameterInformation>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) SignatureHelpClientCapabilities_signatureInformation_parameterInformation: " + std::to_string(object.size())
      );
    }

    iter = object.find("labelOffsetSupport");
    if (iter != object.end()) {
      value->labelOffsetSupport = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::signatureHelpClientCapabilities_signatureInformation_parameterInformationToAny(
    const SignatureHelpClientCapabilities_signatureInformation_parameterInformation &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.labelOffsetSupport.has_value()) {
      object.emplace("labelOffsetSupport", booleanToAny(structure.labelOffsetSupport.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToSignatureHelpClientCapabilities_signatureInformation(
    const LSPAny &any
  ) const -> std::unique_ptr<SignatureHelpClientCapabilities_signatureInformation> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) SignatureHelpClientCapabilities_signatureInformation must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<SignatureHelpClientCapabilities_signatureInformation> value =
      std::make_unique<SignatureHelpClientCapabilities_signatureInformation>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) SignatureHelpClientCapabilities_signatureInformation: " + std::to_string(object.size())
      );
    }

    iter = object.find("documentationFormat");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<MarkupKind> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToMarkupKind(*elem));
      }
      value->documentationFormat = std::move(values);
    }

    iter = object.find("parameterInformation");
    if (iter != object.end()) {
      value->parameterInformation = anyToSignatureHelpClientCapabilities_signatureInformation_parameterInformation(*iter->second);
    }

    iter = object.find("activeParameterSupport");
    if (iter != object.end()) {
      value->activeParameterSupport = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::signatureHelpClientCapabilities_signatureInformationToAny(
    const SignatureHelpClientCapabilities_signatureInformation &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.documentationFormat.has_value()) {
      LSPArray array;
      for (const MarkupKind &elem : structure.documentationFormat.value()) {
        array.push_back(markupKindToAny(elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("documentationFormat", std::move(any));
    }
    if (structure.parameterInformation.has_value()) {
      object.emplace("parameterInformation", signatureHelpClientCapabilities_signatureInformation_parameterInformationToAny(*structure.parameterInformation.value()));
    }
    if (structure.activeParameterSupport.has_value()) {
      object.emplace("activeParameterSupport", booleanToAny(structure.activeParameterSupport.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToSignatureHelpClientCapabilities(
    const LSPAny &any
  ) const -> std::unique_ptr<SignatureHelpClientCapabilities> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) SignatureHelpClientCapabilities must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<SignatureHelpClientCapabilities> value =
      std::make_unique<SignatureHelpClientCapabilities>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) SignatureHelpClientCapabilities: " + std::to_string(object.size())
      );
    }

    iter = object.find("dynamicRegistration");
    if (iter != object.end()) {
      value->dynamicRegistration = anyToBoolean(*iter->second);
    }

    iter = object.find("signatureInformation");
    if (iter != object.end()) {
      value->signatureInformation = anyToSignatureHelpClientCapabilities_signatureInformation(*iter->second);
    }

    iter = object.find("contextSupport");
    if (iter != object.end()) {
      value->contextSupport = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::signatureHelpClientCapabilitiesToAny(
    const SignatureHelpClientCapabilities &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.dynamicRegistration.has_value()) {
      object.emplace("dynamicRegistration", booleanToAny(structure.dynamicRegistration.value()));
    }
    if (structure.signatureInformation.has_value()) {
      object.emplace("signatureInformation", signatureHelpClientCapabilities_signatureInformationToAny(*structure.signatureInformation.value()));
    }
    if (structure.contextSupport.has_value()) {
      object.emplace("contextSupport", booleanToAny(structure.contextSupport.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToDeclarationClientCapabilities(
    const LSPAny &any
  ) const -> std::unique_ptr<DeclarationClientCapabilities> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) DeclarationClientCapabilities must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<DeclarationClientCapabilities> value =
      std::make_unique<DeclarationClientCapabilities>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) DeclarationClientCapabilities: " + std::to_string(object.size())
      );
    }

    iter = object.find("dynamicRegistration");
    if (iter != object.end()) {
      value->dynamicRegistration = anyToBoolean(*iter->second);
    }

    iter = object.find("linkSupport");
    if (iter != object.end()) {
      value->linkSupport = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::declarationClientCapabilitiesToAny(
    const DeclarationClientCapabilities &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.dynamicRegistration.has_value()) {
      object.emplace("dynamicRegistration", booleanToAny(structure.dynamicRegistration.value()));
    }
    if (structure.linkSupport.has_value()) {
      object.emplace("linkSupport", booleanToAny(structure.linkSupport.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToDefinitionClientCapabilities(
    const LSPAny &any
  ) const -> std::unique_ptr<DefinitionClientCapabilities> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) DefinitionClientCapabilities must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<DefinitionClientCapabilities> value =
      std::make_unique<DefinitionClientCapabilities>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) DefinitionClientCapabilities: " + std::to_string(object.size())
      );
    }

    iter = object.find("dynamicRegistration");
    if (iter != object.end()) {
      value->dynamicRegistration = anyToBoolean(*iter->second);
    }

    iter = object.find("linkSupport");
    if (iter != object.end()) {
      value->linkSupport = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::definitionClientCapabilitiesToAny(
    const DefinitionClientCapabilities &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.dynamicRegistration.has_value()) {
      object.emplace("dynamicRegistration", booleanToAny(structure.dynamicRegistration.value()));
    }
    if (structure.linkSupport.has_value()) {
      object.emplace("linkSupport", booleanToAny(structure.linkSupport.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToTypeDefinitionClientCapabilities(
    const LSPAny &any
  ) const -> std::unique_ptr<TypeDefinitionClientCapabilities> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) TypeDefinitionClientCapabilities must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<TypeDefinitionClientCapabilities> value =
      std::make_unique<TypeDefinitionClientCapabilities>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) TypeDefinitionClientCapabilities: " + std::to_string(object.size())
      );
    }

    iter = object.find("dynamicRegistration");
    if (iter != object.end()) {
      value->dynamicRegistration = anyToBoolean(*iter->second);
    }

    iter = object.find("linkSupport");
    if (iter != object.end()) {
      value->linkSupport = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::typeDefinitionClientCapabilitiesToAny(
    const TypeDefinitionClientCapabilities &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.dynamicRegistration.has_value()) {
      object.emplace("dynamicRegistration", booleanToAny(structure.dynamicRegistration.value()));
    }
    if (structure.linkSupport.has_value()) {
      object.emplace("linkSupport", booleanToAny(structure.linkSupport.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToImplementationClientCapabilities(
    const LSPAny &any
  ) const -> std::unique_ptr<ImplementationClientCapabilities> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) ImplementationClientCapabilities must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<ImplementationClientCapabilities> value =
      std::make_unique<ImplementationClientCapabilities>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) ImplementationClientCapabilities: " + std::to_string(object.size())
      );
    }

    iter = object.find("dynamicRegistration");
    if (iter != object.end()) {
      value->dynamicRegistration = anyToBoolean(*iter->second);
    }

    iter = object.find("linkSupport");
    if (iter != object.end()) {
      value->linkSupport = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::implementationClientCapabilitiesToAny(
    const ImplementationClientCapabilities &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.dynamicRegistration.has_value()) {
      object.emplace("dynamicRegistration", booleanToAny(structure.dynamicRegistration.value()));
    }
    if (structure.linkSupport.has_value()) {
      object.emplace("linkSupport", booleanToAny(structure.linkSupport.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToReferenceClientCapabilities(
    const LSPAny &any
  ) const -> std::unique_ptr<ReferenceClientCapabilities> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) ReferenceClientCapabilities must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<ReferenceClientCapabilities> value =
      std::make_unique<ReferenceClientCapabilities>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) ReferenceClientCapabilities: " + std::to_string(object.size())
      );
    }

    iter = object.find("dynamicRegistration");
    if (iter != object.end()) {
      value->dynamicRegistration = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::referenceClientCapabilitiesToAny(
    const ReferenceClientCapabilities &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.dynamicRegistration.has_value()) {
      object.emplace("dynamicRegistration", booleanToAny(structure.dynamicRegistration.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToDocumentHighlightClientCapabilities(
    const LSPAny &any
  ) const -> std::unique_ptr<DocumentHighlightClientCapabilities> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) DocumentHighlightClientCapabilities must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<DocumentHighlightClientCapabilities> value =
      std::make_unique<DocumentHighlightClientCapabilities>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) DocumentHighlightClientCapabilities: " + std::to_string(object.size())
      );
    }

    iter = object.find("dynamicRegistration");
    if (iter != object.end()) {
      value->dynamicRegistration = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::documentHighlightClientCapabilitiesToAny(
    const DocumentHighlightClientCapabilities &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.dynamicRegistration.has_value()) {
      object.emplace("dynamicRegistration", booleanToAny(structure.dynamicRegistration.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToDocumentSymbolClientCapabilities_symbolKind(
    const LSPAny &any
  ) const -> std::unique_ptr<DocumentSymbolClientCapabilities_symbolKind> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) DocumentSymbolClientCapabilities_symbolKind must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<DocumentSymbolClientCapabilities_symbolKind> value =
      std::make_unique<DocumentSymbolClientCapabilities_symbolKind>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) DocumentSymbolClientCapabilities_symbolKind: " + std::to_string(object.size())
      );
    }

    iter = object.find("valueSet");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<SymbolKind> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToSymbolKind(*elem));
      }
      value->valueSet = std::move(values);
    }

    return value;
  }

  auto LspTransformer::documentSymbolClientCapabilities_symbolKindToAny(
    const DocumentSymbolClientCapabilities_symbolKind &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.valueSet.has_value()) {
      LSPArray array;
      for (const SymbolKind &elem : structure.valueSet.value()) {
        array.push_back(symbolKindToAny(elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("valueSet", std::move(any));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToDocumentSymbolClientCapabilities_tagSupport(
    const LSPAny &any
  ) const -> std::unique_ptr<DocumentSymbolClientCapabilities_tagSupport> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) DocumentSymbolClientCapabilities_tagSupport must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<DocumentSymbolClientCapabilities_tagSupport> value =
      std::make_unique<DocumentSymbolClientCapabilities_tagSupport>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) DocumentSymbolClientCapabilities_tagSupport: " + std::to_string(object.size())
      );
    }

    iter = object.find("valueSet");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<SymbolTag> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToSymbolTag(*elem));
      }
      value->valueSet = std::move(values);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DocumentSymbolClientCapabilities_tagSupport attribute: valueSet"
      );
    }

    return value;
  }

  auto LspTransformer::documentSymbolClientCapabilities_tagSupportToAny(
    const DocumentSymbolClientCapabilities_tagSupport &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    {
      LSPArray array;
      for (const SymbolTag &elem : structure.valueSet) {
        array.push_back(symbolTagToAny(elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("valueSet", std::move(any));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToDocumentSymbolClientCapabilities(
    const LSPAny &any
  ) const -> std::unique_ptr<DocumentSymbolClientCapabilities> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) DocumentSymbolClientCapabilities must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<DocumentSymbolClientCapabilities> value =
      std::make_unique<DocumentSymbolClientCapabilities>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 5) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) DocumentSymbolClientCapabilities: " + std::to_string(object.size())
      );
    }

    iter = object.find("dynamicRegistration");
    if (iter != object.end()) {
      value->dynamicRegistration = anyToBoolean(*iter->second);
    }

    iter = object.find("symbolKind");
    if (iter != object.end()) {
      value->symbolKind = anyToDocumentSymbolClientCapabilities_symbolKind(*iter->second);
    }

    iter = object.find("hierarchicalDocumentSymbolSupport");
    if (iter != object.end()) {
      value->hierarchicalDocumentSymbolSupport = anyToBoolean(*iter->second);
    }

    iter = object.find("tagSupport");
    if (iter != object.end()) {
      value->tagSupport = anyToDocumentSymbolClientCapabilities_tagSupport(*iter->second);
    }

    iter = object.find("labelSupport");
    if (iter != object.end()) {
      value->labelSupport = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::documentSymbolClientCapabilitiesToAny(
    const DocumentSymbolClientCapabilities &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.dynamicRegistration.has_value()) {
      object.emplace("dynamicRegistration", booleanToAny(structure.dynamicRegistration.value()));
    }
    if (structure.symbolKind.has_value()) {
      object.emplace("symbolKind", documentSymbolClientCapabilities_symbolKindToAny(*structure.symbolKind.value()));
    }
    if (structure.hierarchicalDocumentSymbolSupport.has_value()) {
      object.emplace("hierarchicalDocumentSymbolSupport", booleanToAny(structure.hierarchicalDocumentSymbolSupport.value()));
    }
    if (structure.tagSupport.has_value()) {
      object.emplace("tagSupport", documentSymbolClientCapabilities_tagSupportToAny(*structure.tagSupport.value()));
    }
    if (structure.labelSupport.has_value()) {
      object.emplace("labelSupport", booleanToAny(structure.labelSupport.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToCodeActionClientCapabilities_codeActionLiteralSupport_codeActionKind(
    const LSPAny &any
  ) const -> std::unique_ptr<CodeActionClientCapabilities_codeActionLiteralSupport_codeActionKind> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) CodeActionClientCapabilities_codeActionLiteralSupport_codeActionKind must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<CodeActionClientCapabilities_codeActionLiteralSupport_codeActionKind> value =
      std::make_unique<CodeActionClientCapabilities_codeActionLiteralSupport_codeActionKind>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) CodeActionClientCapabilities_codeActionLiteralSupport_codeActionKind: " + std::to_string(object.size())
      );
    }

    iter = object.find("valueSet");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<CodeActionKind> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToCodeActionKind(*elem));
      }
      value->valueSet = std::move(values);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required CodeActionClientCapabilities_codeActionLiteralSupport_codeActionKind attribute: valueSet"
      );
    }

    return value;
  }

  auto LspTransformer::codeActionClientCapabilities_codeActionLiteralSupport_codeActionKindToAny(
    const CodeActionClientCapabilities_codeActionLiteralSupport_codeActionKind &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    {
      LSPArray array;
      for (const CodeActionKind &elem : structure.valueSet) {
        array.push_back(codeActionKindToAny(elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("valueSet", std::move(any));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToCodeActionClientCapabilities_codeActionLiteralSupport(
    const LSPAny &any
  ) const -> std::unique_ptr<CodeActionClientCapabilities_codeActionLiteralSupport> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) CodeActionClientCapabilities_codeActionLiteralSupport must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<CodeActionClientCapabilities_codeActionLiteralSupport> value =
      std::make_unique<CodeActionClientCapabilities_codeActionLiteralSupport>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) CodeActionClientCapabilities_codeActionLiteralSupport: " + std::to_string(object.size())
      );
    }

    iter = object.find("codeActionKind");
    if (iter != object.end()) {
      value->codeActionKind = anyToCodeActionClientCapabilities_codeActionLiteralSupport_codeActionKind(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required CodeActionClientCapabilities_codeActionLiteralSupport attribute: codeActionKind"
      );
    }

    return value;
  }

  auto LspTransformer::codeActionClientCapabilities_codeActionLiteralSupportToAny(
    const CodeActionClientCapabilities_codeActionLiteralSupport &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("codeActionKind", codeActionClientCapabilities_codeActionLiteralSupport_codeActionKindToAny(*structure.codeActionKind));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToCodeActionClientCapabilities_resolveSupport(
    const LSPAny &any
  ) const -> std::unique_ptr<CodeActionClientCapabilities_resolveSupport> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) CodeActionClientCapabilities_resolveSupport must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<CodeActionClientCapabilities_resolveSupport> value =
      std::make_unique<CodeActionClientCapabilities_resolveSupport>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) CodeActionClientCapabilities_resolveSupport: " + std::to_string(object.size())
      );
    }

    iter = object.find("properties");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<string_t> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToString(*elem));
      }
      value->properties = std::move(values);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required CodeActionClientCapabilities_resolveSupport attribute: properties"
      );
    }

    return value;
  }

  auto LspTransformer::codeActionClientCapabilities_resolveSupportToAny(
    const CodeActionClientCapabilities_resolveSupport &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    {
      LSPArray array;
      for (const string_t &elem : structure.properties) {
        array.push_back(stringToAny(elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("properties", std::move(any));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToCodeActionClientCapabilities(
    const LSPAny &any
  ) const -> std::unique_ptr<CodeActionClientCapabilities> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) CodeActionClientCapabilities must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<CodeActionClientCapabilities> value =
      std::make_unique<CodeActionClientCapabilities>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 7) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) CodeActionClientCapabilities: " + std::to_string(object.size())
      );
    }

    iter = object.find("dynamicRegistration");
    if (iter != object.end()) {
      value->dynamicRegistration = anyToBoolean(*iter->second);
    }

    iter = object.find("codeActionLiteralSupport");
    if (iter != object.end()) {
      value->codeActionLiteralSupport = anyToCodeActionClientCapabilities_codeActionLiteralSupport(*iter->second);
    }

    iter = object.find("isPreferredSupport");
    if (iter != object.end()) {
      value->isPreferredSupport = anyToBoolean(*iter->second);
    }

    iter = object.find("disabledSupport");
    if (iter != object.end()) {
      value->disabledSupport = anyToBoolean(*iter->second);
    }

    iter = object.find("dataSupport");
    if (iter != object.end()) {
      value->dataSupport = anyToBoolean(*iter->second);
    }

    iter = object.find("resolveSupport");
    if (iter != object.end()) {
      value->resolveSupport = anyToCodeActionClientCapabilities_resolveSupport(*iter->second);
    }

    iter = object.find("honorsChangeAnnotations");
    if (iter != object.end()) {
      value->honorsChangeAnnotations = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::codeActionClientCapabilitiesToAny(
    const CodeActionClientCapabilities &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.dynamicRegistration.has_value()) {
      object.emplace("dynamicRegistration", booleanToAny(structure.dynamicRegistration.value()));
    }
    if (structure.codeActionLiteralSupport.has_value()) {
      object.emplace("codeActionLiteralSupport", codeActionClientCapabilities_codeActionLiteralSupportToAny(*structure.codeActionLiteralSupport.value()));
    }
    if (structure.isPreferredSupport.has_value()) {
      object.emplace("isPreferredSupport", booleanToAny(structure.isPreferredSupport.value()));
    }
    if (structure.disabledSupport.has_value()) {
      object.emplace("disabledSupport", booleanToAny(structure.disabledSupport.value()));
    }
    if (structure.dataSupport.has_value()) {
      object.emplace("dataSupport", booleanToAny(structure.dataSupport.value()));
    }
    if (structure.resolveSupport.has_value()) {
      object.emplace("resolveSupport", codeActionClientCapabilities_resolveSupportToAny(*structure.resolveSupport.value()));
    }
    if (structure.honorsChangeAnnotations.has_value()) {
      object.emplace("honorsChangeAnnotations", booleanToAny(structure.honorsChangeAnnotations.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToCodeLensClientCapabilities(
    const LSPAny &any
  ) const -> std::unique_ptr<CodeLensClientCapabilities> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) CodeLensClientCapabilities must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<CodeLensClientCapabilities> value =
      std::make_unique<CodeLensClientCapabilities>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) CodeLensClientCapabilities: " + std::to_string(object.size())
      );
    }

    iter = object.find("dynamicRegistration");
    if (iter != object.end()) {
      value->dynamicRegistration = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::codeLensClientCapabilitiesToAny(
    const CodeLensClientCapabilities &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.dynamicRegistration.has_value()) {
      object.emplace("dynamicRegistration", booleanToAny(structure.dynamicRegistration.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToDocumentLinkClientCapabilities(
    const LSPAny &any
  ) const -> std::unique_ptr<DocumentLinkClientCapabilities> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) DocumentLinkClientCapabilities must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<DocumentLinkClientCapabilities> value =
      std::make_unique<DocumentLinkClientCapabilities>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) DocumentLinkClientCapabilities: " + std::to_string(object.size())
      );
    }

    iter = object.find("dynamicRegistration");
    if (iter != object.end()) {
      value->dynamicRegistration = anyToBoolean(*iter->second);
    }

    iter = object.find("tooltipSupport");
    if (iter != object.end()) {
      value->tooltipSupport = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::documentLinkClientCapabilitiesToAny(
    const DocumentLinkClientCapabilities &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.dynamicRegistration.has_value()) {
      object.emplace("dynamicRegistration", booleanToAny(structure.dynamicRegistration.value()));
    }
    if (structure.tooltipSupport.has_value()) {
      object.emplace("tooltipSupport", booleanToAny(structure.tooltipSupport.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToDocumentColorClientCapabilities(
    const LSPAny &any
  ) const -> std::unique_ptr<DocumentColorClientCapabilities> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) DocumentColorClientCapabilities must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<DocumentColorClientCapabilities> value =
      std::make_unique<DocumentColorClientCapabilities>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) DocumentColorClientCapabilities: " + std::to_string(object.size())
      );
    }

    iter = object.find("dynamicRegistration");
    if (iter != object.end()) {
      value->dynamicRegistration = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::documentColorClientCapabilitiesToAny(
    const DocumentColorClientCapabilities &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.dynamicRegistration.has_value()) {
      object.emplace("dynamicRegistration", booleanToAny(structure.dynamicRegistration.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToDocumentFormattingClientCapabilities(
    const LSPAny &any
  ) const -> std::unique_ptr<DocumentFormattingClientCapabilities> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) DocumentFormattingClientCapabilities must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<DocumentFormattingClientCapabilities> value =
      std::make_unique<DocumentFormattingClientCapabilities>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) DocumentFormattingClientCapabilities: " + std::to_string(object.size())
      );
    }

    iter = object.find("dynamicRegistration");
    if (iter != object.end()) {
      value->dynamicRegistration = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::documentFormattingClientCapabilitiesToAny(
    const DocumentFormattingClientCapabilities &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.dynamicRegistration.has_value()) {
      object.emplace("dynamicRegistration", booleanToAny(structure.dynamicRegistration.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToDocumentRangeFormattingClientCapabilities(
    const LSPAny &any
  ) const -> std::unique_ptr<DocumentRangeFormattingClientCapabilities> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) DocumentRangeFormattingClientCapabilities must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<DocumentRangeFormattingClientCapabilities> value =
      std::make_unique<DocumentRangeFormattingClientCapabilities>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) DocumentRangeFormattingClientCapabilities: " + std::to_string(object.size())
      );
    }

    iter = object.find("dynamicRegistration");
    if (iter != object.end()) {
      value->dynamicRegistration = anyToBoolean(*iter->second);
    }

    iter = object.find("rangesSupport");
    if (iter != object.end()) {
      value->rangesSupport = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::documentRangeFormattingClientCapabilitiesToAny(
    const DocumentRangeFormattingClientCapabilities &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.dynamicRegistration.has_value()) {
      object.emplace("dynamicRegistration", booleanToAny(structure.dynamicRegistration.value()));
    }
    if (structure.rangesSupport.has_value()) {
      object.emplace("rangesSupport", booleanToAny(structure.rangesSupport.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToDocumentOnTypeFormattingClientCapabilities(
    const LSPAny &any
  ) const -> std::unique_ptr<DocumentOnTypeFormattingClientCapabilities> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) DocumentOnTypeFormattingClientCapabilities must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<DocumentOnTypeFormattingClientCapabilities> value =
      std::make_unique<DocumentOnTypeFormattingClientCapabilities>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) DocumentOnTypeFormattingClientCapabilities: " + std::to_string(object.size())
      );
    }

    iter = object.find("dynamicRegistration");
    if (iter != object.end()) {
      value->dynamicRegistration = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::documentOnTypeFormattingClientCapabilitiesToAny(
    const DocumentOnTypeFormattingClientCapabilities &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.dynamicRegistration.has_value()) {
      object.emplace("dynamicRegistration", booleanToAny(structure.dynamicRegistration.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToRenameClientCapabilities(
    const LSPAny &any
  ) const -> std::unique_ptr<RenameClientCapabilities> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) RenameClientCapabilities must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<RenameClientCapabilities> value =
      std::make_unique<RenameClientCapabilities>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 4) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) RenameClientCapabilities: " + std::to_string(object.size())
      );
    }

    iter = object.find("dynamicRegistration");
    if (iter != object.end()) {
      value->dynamicRegistration = anyToBoolean(*iter->second);
    }

    iter = object.find("prepareSupport");
    if (iter != object.end()) {
      value->prepareSupport = anyToBoolean(*iter->second);
    }

    iter = object.find("prepareSupportDefaultBehavior");
    if (iter != object.end()) {
      value->prepareSupportDefaultBehavior = anyToPrepareSupportDefaultBehavior(*iter->second);
    }

    iter = object.find("honorsChangeAnnotations");
    if (iter != object.end()) {
      value->honorsChangeAnnotations = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::renameClientCapabilitiesToAny(
    const RenameClientCapabilities &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.dynamicRegistration.has_value()) {
      object.emplace("dynamicRegistration", booleanToAny(structure.dynamicRegistration.value()));
    }
    if (structure.prepareSupport.has_value()) {
      object.emplace("prepareSupport", booleanToAny(structure.prepareSupport.value()));
    }
    if (structure.prepareSupportDefaultBehavior.has_value()) {
      object.emplace("prepareSupportDefaultBehavior", prepareSupportDefaultBehaviorToAny(structure.prepareSupportDefaultBehavior.value()));
    }
    if (structure.honorsChangeAnnotations.has_value()) {
      object.emplace("honorsChangeAnnotations", booleanToAny(structure.honorsChangeAnnotations.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToFoldingRangeClientCapabilities_foldingRangeKind(
    const LSPAny &any
  ) const -> std::unique_ptr<FoldingRangeClientCapabilities_foldingRangeKind> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) FoldingRangeClientCapabilities_foldingRangeKind must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<FoldingRangeClientCapabilities_foldingRangeKind> value =
      std::make_unique<FoldingRangeClientCapabilities_foldingRangeKind>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) FoldingRangeClientCapabilities_foldingRangeKind: " + std::to_string(object.size())
      );
    }

    iter = object.find("valueSet");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<FoldingRangeKind> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToFoldingRangeKind(*elem));
      }
      value->valueSet = std::move(values);
    }

    return value;
  }

  auto LspTransformer::foldingRangeClientCapabilities_foldingRangeKindToAny(
    const FoldingRangeClientCapabilities_foldingRangeKind &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.valueSet.has_value()) {
      LSPArray array;
      for (const FoldingRangeKind &elem : structure.valueSet.value()) {
        array.push_back(foldingRangeKindToAny(elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("valueSet", std::move(any));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToFoldingRangeClientCapabilities_foldingRange(
    const LSPAny &any
  ) const -> std::unique_ptr<FoldingRangeClientCapabilities_foldingRange> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) FoldingRangeClientCapabilities_foldingRange must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<FoldingRangeClientCapabilities_foldingRange> value =
      std::make_unique<FoldingRangeClientCapabilities_foldingRange>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) FoldingRangeClientCapabilities_foldingRange: " + std::to_string(object.size())
      );
    }

    iter = object.find("collapsedText");
    if (iter != object.end()) {
      value->collapsedText = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::foldingRangeClientCapabilities_foldingRangeToAny(
    const FoldingRangeClientCapabilities_foldingRange &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.collapsedText.has_value()) {
      object.emplace("collapsedText", booleanToAny(structure.collapsedText.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToFoldingRangeClientCapabilities(
    const LSPAny &any
  ) const -> std::unique_ptr<FoldingRangeClientCapabilities> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) FoldingRangeClientCapabilities must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<FoldingRangeClientCapabilities> value =
      std::make_unique<FoldingRangeClientCapabilities>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 5) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) FoldingRangeClientCapabilities: " + std::to_string(object.size())
      );
    }

    iter = object.find("dynamicRegistration");
    if (iter != object.end()) {
      value->dynamicRegistration = anyToBoolean(*iter->second);
    }

    iter = object.find("rangeLimit");
    if (iter != object.end()) {
      value->rangeLimit = anyToUInteger(*iter->second);
    }

    iter = object.find("lineFoldingOnly");
    if (iter != object.end()) {
      value->lineFoldingOnly = anyToBoolean(*iter->second);
    }

    iter = object.find("foldingRangeKind");
    if (iter != object.end()) {
      value->foldingRangeKind = anyToFoldingRangeClientCapabilities_foldingRangeKind(*iter->second);
    }

    iter = object.find("foldingRange");
    if (iter != object.end()) {
      value->foldingRange = anyToFoldingRangeClientCapabilities_foldingRange(*iter->second);
    }

    return value;
  }

  auto LspTransformer::foldingRangeClientCapabilitiesToAny(
    const FoldingRangeClientCapabilities &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.dynamicRegistration.has_value()) {
      object.emplace("dynamicRegistration", booleanToAny(structure.dynamicRegistration.value()));
    }
    if (structure.rangeLimit.has_value()) {
      object.emplace("rangeLimit", uintegerToAny(structure.rangeLimit.value()));
    }
    if (structure.lineFoldingOnly.has_value()) {
      object.emplace("lineFoldingOnly", booleanToAny(structure.lineFoldingOnly.value()));
    }
    if (structure.foldingRangeKind.has_value()) {
      object.emplace("foldingRangeKind", foldingRangeClientCapabilities_foldingRangeKindToAny(*structure.foldingRangeKind.value()));
    }
    if (structure.foldingRange.has_value()) {
      object.emplace("foldingRange", foldingRangeClientCapabilities_foldingRangeToAny(*structure.foldingRange.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToSelectionRangeClientCapabilities(
    const LSPAny &any
  ) const -> std::unique_ptr<SelectionRangeClientCapabilities> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) SelectionRangeClientCapabilities must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<SelectionRangeClientCapabilities> value =
      std::make_unique<SelectionRangeClientCapabilities>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) SelectionRangeClientCapabilities: " + std::to_string(object.size())
      );
    }

    iter = object.find("dynamicRegistration");
    if (iter != object.end()) {
      value->dynamicRegistration = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::selectionRangeClientCapabilitiesToAny(
    const SelectionRangeClientCapabilities &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.dynamicRegistration.has_value()) {
      object.emplace("dynamicRegistration", booleanToAny(structure.dynamicRegistration.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToPublishDiagnosticsClientCapabilities_tagSupport(
    const LSPAny &any
  ) const -> std::unique_ptr<PublishDiagnosticsClientCapabilities_tagSupport> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) PublishDiagnosticsClientCapabilities_tagSupport must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<PublishDiagnosticsClientCapabilities_tagSupport> value =
      std::make_unique<PublishDiagnosticsClientCapabilities_tagSupport>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) PublishDiagnosticsClientCapabilities_tagSupport: " + std::to_string(object.size())
      );
    }

    iter = object.find("valueSet");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<DiagnosticTag> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToDiagnosticTag(*elem));
      }
      value->valueSet = std::move(values);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required PublishDiagnosticsClientCapabilities_tagSupport attribute: valueSet"
      );
    }

    return value;
  }

  auto LspTransformer::publishDiagnosticsClientCapabilities_tagSupportToAny(
    const PublishDiagnosticsClientCapabilities_tagSupport &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    {
      LSPArray array;
      for (const DiagnosticTag &elem : structure.valueSet) {
        array.push_back(diagnosticTagToAny(elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("valueSet", std::move(any));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToPublishDiagnosticsClientCapabilities(
    const LSPAny &any
  ) const -> std::unique_ptr<PublishDiagnosticsClientCapabilities> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) PublishDiagnosticsClientCapabilities must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<PublishDiagnosticsClientCapabilities> value =
      std::make_unique<PublishDiagnosticsClientCapabilities>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 5) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) PublishDiagnosticsClientCapabilities: " + std::to_string(object.size())
      );
    }

    iter = object.find("relatedInformation");
    if (iter != object.end()) {
      value->relatedInformation = anyToBoolean(*iter->second);
    }

    iter = object.find("tagSupport");
    if (iter != object.end()) {
      value->tagSupport = anyToPublishDiagnosticsClientCapabilities_tagSupport(*iter->second);
    }

    iter = object.find("versionSupport");
    if (iter != object.end()) {
      value->versionSupport = anyToBoolean(*iter->second);
    }

    iter = object.find("codeDescriptionSupport");
    if (iter != object.end()) {
      value->codeDescriptionSupport = anyToBoolean(*iter->second);
    }

    iter = object.find("dataSupport");
    if (iter != object.end()) {
      value->dataSupport = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::publishDiagnosticsClientCapabilitiesToAny(
    const PublishDiagnosticsClientCapabilities &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.relatedInformation.has_value()) {
      object.emplace("relatedInformation", booleanToAny(structure.relatedInformation.value()));
    }
    if (structure.tagSupport.has_value()) {
      object.emplace("tagSupport", publishDiagnosticsClientCapabilities_tagSupportToAny(*structure.tagSupport.value()));
    }
    if (structure.versionSupport.has_value()) {
      object.emplace("versionSupport", booleanToAny(structure.versionSupport.value()));
    }
    if (structure.codeDescriptionSupport.has_value()) {
      object.emplace("codeDescriptionSupport", booleanToAny(structure.codeDescriptionSupport.value()));
    }
    if (structure.dataSupport.has_value()) {
      object.emplace("dataSupport", booleanToAny(structure.dataSupport.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToCallHierarchyClientCapabilities(
    const LSPAny &any
  ) const -> std::unique_ptr<CallHierarchyClientCapabilities> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) CallHierarchyClientCapabilities must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<CallHierarchyClientCapabilities> value =
      std::make_unique<CallHierarchyClientCapabilities>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) CallHierarchyClientCapabilities: " + std::to_string(object.size())
      );
    }

    iter = object.find("dynamicRegistration");
    if (iter != object.end()) {
      value->dynamicRegistration = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::callHierarchyClientCapabilitiesToAny(
    const CallHierarchyClientCapabilities &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.dynamicRegistration.has_value()) {
      object.emplace("dynamicRegistration", booleanToAny(structure.dynamicRegistration.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToSemanticTokensClientCapabilities_requests_full_1(
    const LSPAny &any
  ) const -> std::unique_ptr<SemanticTokensClientCapabilities_requests_full_1> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) SemanticTokensClientCapabilities_requests_full_1 must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<SemanticTokensClientCapabilities_requests_full_1> value =
      std::make_unique<SemanticTokensClientCapabilities_requests_full_1>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) SemanticTokensClientCapabilities_requests_full_1: " + std::to_string(object.size())
      );
    }

    iter = object.find("delta");
    if (iter != object.end()) {
      value->delta = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::semanticTokensClientCapabilities_requests_full_1ToAny(
    const SemanticTokensClientCapabilities_requests_full_1 &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.delta.has_value()) {
      object.emplace("delta", booleanToAny(structure.delta.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToSemanticTokensClientCapabilities_requests_full(
    const LSPAny &any
  ) const -> SemanticTokensClientCapabilities_requests_full {
    SemanticTokensClientCapabilities_requests_full value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::OBJECT_TYPE: {
      try {
        value = anyToSemanticTokensClientCapabilities_requests_full_1(any);
      } catch (LspException &e) {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          "Failed to transform LSPAny to SemanticTokensClientCapabilities_requests_full"
        );
      }
      break;
    }
    case LSPAnyType::BOOLEAN_TYPE: {
      value = anyToBoolean(any);
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) SemanticTokensClientCapabilities_requests_full: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::semanticTokensClientCapabilities_requests_fullToAny(
    const SemanticTokensClientCapabilities_requests_full &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<SemanticTokensClientCapabilities_requests_fullType>(variant.index())) {
    case SemanticTokensClientCapabilities_requests_fullType::BOOLEAN_TYPE: {
      return booleanToAny(
        std::get<boolean_t>(variant)
      );
    }
    case SemanticTokensClientCapabilities_requests_fullType::SEMANTIC_TOKENS_CLIENT_CAPABILITIES_REQUESTS_FULL_1: {
      return semanticTokensClientCapabilities_requests_full_1ToAny(
        *std::get<std::unique_ptr<SemanticTokensClientCapabilities_requests_full_1>>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported SemanticTokensClientCapabilities_requests_fullType: " +
         SemanticTokensClientCapabilities_requests_fullTypeNames.at(static_cast<SemanticTokensClientCapabilities_requests_fullType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToSemanticTokensClientCapabilities_requests_range_1(
    const LSPAny &any
  ) const -> std::unique_ptr<SemanticTokensClientCapabilities_requests_range_1> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) SemanticTokensClientCapabilities_requests_range_1 must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<SemanticTokensClientCapabilities_requests_range_1> value =
      std::make_unique<SemanticTokensClientCapabilities_requests_range_1>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 0) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) SemanticTokensClientCapabilities_requests_range_1: " + std::to_string(object.size())
      );
    }

    return value;
  }

  auto LspTransformer::semanticTokensClientCapabilities_requests_range_1ToAny(
    const SemanticTokensClientCapabilities_requests_range_1 &/*structure*/
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    // empty

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToSemanticTokensClientCapabilities_requests_range(
    const LSPAny &any
  ) const -> SemanticTokensClientCapabilities_requests_range {
    SemanticTokensClientCapabilities_requests_range value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::OBJECT_TYPE: {
      try {
        value = anyToSemanticTokensClientCapabilities_requests_range_1(any);
      } catch (LspException &e) {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          "Failed to transform LSPAny to SemanticTokensClientCapabilities_requests_range"
        );
      }
      break;
    }
    case LSPAnyType::BOOLEAN_TYPE: {
      value = anyToBoolean(any);
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) SemanticTokensClientCapabilities_requests_range: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::semanticTokensClientCapabilities_requests_rangeToAny(
    const SemanticTokensClientCapabilities_requests_range &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<SemanticTokensClientCapabilities_requests_rangeType>(variant.index())) {
    case SemanticTokensClientCapabilities_requests_rangeType::BOOLEAN_TYPE: {
      return booleanToAny(
        std::get<boolean_t>(variant)
      );
    }
    case SemanticTokensClientCapabilities_requests_rangeType::SEMANTIC_TOKENS_CLIENT_CAPABILITIES_REQUESTS_RANGE_1: {
      return semanticTokensClientCapabilities_requests_range_1ToAny(
        *std::get<std::unique_ptr<SemanticTokensClientCapabilities_requests_range_1>>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported SemanticTokensClientCapabilities_requests_rangeType: " +
         SemanticTokensClientCapabilities_requests_rangeTypeNames.at(static_cast<SemanticTokensClientCapabilities_requests_rangeType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToSemanticTokensClientCapabilities_requests(
    const LSPAny &any
  ) const -> std::unique_ptr<SemanticTokensClientCapabilities_requests> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) SemanticTokensClientCapabilities_requests must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<SemanticTokensClientCapabilities_requests> value =
      std::make_unique<SemanticTokensClientCapabilities_requests>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) SemanticTokensClientCapabilities_requests: " + std::to_string(object.size())
      );
    }

    iter = object.find("range");
    if (iter != object.end()) {
      value->range = anyToSemanticTokensClientCapabilities_requests_range(*iter->second);
    }

    iter = object.find("full");
    if (iter != object.end()) {
      value->full = anyToSemanticTokensClientCapabilities_requests_full(*iter->second);
    }

    return value;
  }

  auto LspTransformer::semanticTokensClientCapabilities_requestsToAny(
    const SemanticTokensClientCapabilities_requests &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.range.has_value()) {
      object.emplace("range", semanticTokensClientCapabilities_requests_rangeToAny(structure.range.value()));
    }
    if (structure.full.has_value()) {
      object.emplace("full", semanticTokensClientCapabilities_requests_fullToAny(structure.full.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToSemanticTokensClientCapabilities(
    const LSPAny &any
  ) const -> std::unique_ptr<SemanticTokensClientCapabilities> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) SemanticTokensClientCapabilities must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<SemanticTokensClientCapabilities> value =
      std::make_unique<SemanticTokensClientCapabilities>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 9) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) SemanticTokensClientCapabilities: " + std::to_string(object.size())
      );
    }

    iter = object.find("dynamicRegistration");
    if (iter != object.end()) {
      value->dynamicRegistration = anyToBoolean(*iter->second);
    }

    iter = object.find("requests");
    if (iter != object.end()) {
      value->requests = anyToSemanticTokensClientCapabilities_requests(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required SemanticTokensClientCapabilities attribute: requests"
      );
    }

    iter = object.find("tokenTypes");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<string_t> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToString(*elem));
      }
      value->tokenTypes = std::move(values);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required SemanticTokensClientCapabilities attribute: tokenTypes"
      );
    }

    iter = object.find("tokenModifiers");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<string_t> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToString(*elem));
      }
      value->tokenModifiers = std::move(values);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required SemanticTokensClientCapabilities attribute: tokenModifiers"
      );
    }

    iter = object.find("formats");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<TokenFormat> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToTokenFormat(*elem));
      }
      value->formats = std::move(values);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required SemanticTokensClientCapabilities attribute: formats"
      );
    }

    iter = object.find("overlappingTokenSupport");
    if (iter != object.end()) {
      value->overlappingTokenSupport = anyToBoolean(*iter->second);
    }

    iter = object.find("multilineTokenSupport");
    if (iter != object.end()) {
      value->multilineTokenSupport = anyToBoolean(*iter->second);
    }

    iter = object.find("serverCancelSupport");
    if (iter != object.end()) {
      value->serverCancelSupport = anyToBoolean(*iter->second);
    }

    iter = object.find("augmentsSyntaxTokens");
    if (iter != object.end()) {
      value->augmentsSyntaxTokens = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::semanticTokensClientCapabilitiesToAny(
    const SemanticTokensClientCapabilities &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.dynamicRegistration.has_value()) {
      object.emplace("dynamicRegistration", booleanToAny(structure.dynamicRegistration.value()));
    }
    object.emplace("requests", semanticTokensClientCapabilities_requestsToAny(*structure.requests));
    {
      LSPArray array;
      for (const string_t &elem : structure.tokenTypes) {
        array.push_back(stringToAny(elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("tokenTypes", std::move(any));
    }
    {
      LSPArray array;
      for (const string_t &elem : structure.tokenModifiers) {
        array.push_back(stringToAny(elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("tokenModifiers", std::move(any));
    }
    {
      LSPArray array;
      for (const TokenFormat &elem : structure.formats) {
        array.push_back(tokenFormatToAny(elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("formats", std::move(any));
    }
    if (structure.overlappingTokenSupport.has_value()) {
      object.emplace("overlappingTokenSupport", booleanToAny(structure.overlappingTokenSupport.value()));
    }
    if (structure.multilineTokenSupport.has_value()) {
      object.emplace("multilineTokenSupport", booleanToAny(structure.multilineTokenSupport.value()));
    }
    if (structure.serverCancelSupport.has_value()) {
      object.emplace("serverCancelSupport", booleanToAny(structure.serverCancelSupport.value()));
    }
    if (structure.augmentsSyntaxTokens.has_value()) {
      object.emplace("augmentsSyntaxTokens", booleanToAny(structure.augmentsSyntaxTokens.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToLinkedEditingRangeClientCapabilities(
    const LSPAny &any
  ) const -> std::unique_ptr<LinkedEditingRangeClientCapabilities> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) LinkedEditingRangeClientCapabilities must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<LinkedEditingRangeClientCapabilities> value =
      std::make_unique<LinkedEditingRangeClientCapabilities>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) LinkedEditingRangeClientCapabilities: " + std::to_string(object.size())
      );
    }

    iter = object.find("dynamicRegistration");
    if (iter != object.end()) {
      value->dynamicRegistration = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::linkedEditingRangeClientCapabilitiesToAny(
    const LinkedEditingRangeClientCapabilities &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.dynamicRegistration.has_value()) {
      object.emplace("dynamicRegistration", booleanToAny(structure.dynamicRegistration.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToMonikerClientCapabilities(
    const LSPAny &any
  ) const -> std::unique_ptr<MonikerClientCapabilities> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) MonikerClientCapabilities must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<MonikerClientCapabilities> value =
      std::make_unique<MonikerClientCapabilities>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) MonikerClientCapabilities: " + std::to_string(object.size())
      );
    }

    iter = object.find("dynamicRegistration");
    if (iter != object.end()) {
      value->dynamicRegistration = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::monikerClientCapabilitiesToAny(
    const MonikerClientCapabilities &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.dynamicRegistration.has_value()) {
      object.emplace("dynamicRegistration", booleanToAny(structure.dynamicRegistration.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToTypeHierarchyClientCapabilities(
    const LSPAny &any
  ) const -> std::unique_ptr<TypeHierarchyClientCapabilities> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) TypeHierarchyClientCapabilities must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<TypeHierarchyClientCapabilities> value =
      std::make_unique<TypeHierarchyClientCapabilities>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) TypeHierarchyClientCapabilities: " + std::to_string(object.size())
      );
    }

    iter = object.find("dynamicRegistration");
    if (iter != object.end()) {
      value->dynamicRegistration = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::typeHierarchyClientCapabilitiesToAny(
    const TypeHierarchyClientCapabilities &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.dynamicRegistration.has_value()) {
      object.emplace("dynamicRegistration", booleanToAny(structure.dynamicRegistration.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToInlineValueClientCapabilities(
    const LSPAny &any
  ) const -> std::unique_ptr<InlineValueClientCapabilities> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) InlineValueClientCapabilities must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<InlineValueClientCapabilities> value =
      std::make_unique<InlineValueClientCapabilities>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) InlineValueClientCapabilities: " + std::to_string(object.size())
      );
    }

    iter = object.find("dynamicRegistration");
    if (iter != object.end()) {
      value->dynamicRegistration = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::inlineValueClientCapabilitiesToAny(
    const InlineValueClientCapabilities &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.dynamicRegistration.has_value()) {
      object.emplace("dynamicRegistration", booleanToAny(structure.dynamicRegistration.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToInlayHintClientCapabilities_resolveSupport(
    const LSPAny &any
  ) const -> std::unique_ptr<InlayHintClientCapabilities_resolveSupport> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) InlayHintClientCapabilities_resolveSupport must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<InlayHintClientCapabilities_resolveSupport> value =
      std::make_unique<InlayHintClientCapabilities_resolveSupport>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) InlayHintClientCapabilities_resolveSupport: " + std::to_string(object.size())
      );
    }

    iter = object.find("properties");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<string_t> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToString(*elem));
      }
      value->properties = std::move(values);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required InlayHintClientCapabilities_resolveSupport attribute: properties"
      );
    }

    return value;
  }

  auto LspTransformer::inlayHintClientCapabilities_resolveSupportToAny(
    const InlayHintClientCapabilities_resolveSupport &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    {
      LSPArray array;
      for (const string_t &elem : structure.properties) {
        array.push_back(stringToAny(elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("properties", std::move(any));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToInlayHintClientCapabilities(
    const LSPAny &any
  ) const -> std::unique_ptr<InlayHintClientCapabilities> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) InlayHintClientCapabilities must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<InlayHintClientCapabilities> value =
      std::make_unique<InlayHintClientCapabilities>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) InlayHintClientCapabilities: " + std::to_string(object.size())
      );
    }

    iter = object.find("dynamicRegistration");
    if (iter != object.end()) {
      value->dynamicRegistration = anyToBoolean(*iter->second);
    }

    iter = object.find("resolveSupport");
    if (iter != object.end()) {
      value->resolveSupport = anyToInlayHintClientCapabilities_resolveSupport(*iter->second);
    }

    return value;
  }

  auto LspTransformer::inlayHintClientCapabilitiesToAny(
    const InlayHintClientCapabilities &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.dynamicRegistration.has_value()) {
      object.emplace("dynamicRegistration", booleanToAny(structure.dynamicRegistration.value()));
    }
    if (structure.resolveSupport.has_value()) {
      object.emplace("resolveSupport", inlayHintClientCapabilities_resolveSupportToAny(*structure.resolveSupport.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToDiagnosticClientCapabilities(
    const LSPAny &any
  ) const -> std::unique_ptr<DiagnosticClientCapabilities> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) DiagnosticClientCapabilities must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<DiagnosticClientCapabilities> value =
      std::make_unique<DiagnosticClientCapabilities>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) DiagnosticClientCapabilities: " + std::to_string(object.size())
      );
    }

    iter = object.find("dynamicRegistration");
    if (iter != object.end()) {
      value->dynamicRegistration = anyToBoolean(*iter->second);
    }

    iter = object.find("relatedDocumentSupport");
    if (iter != object.end()) {
      value->relatedDocumentSupport = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::diagnosticClientCapabilitiesToAny(
    const DiagnosticClientCapabilities &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.dynamicRegistration.has_value()) {
      object.emplace("dynamicRegistration", booleanToAny(structure.dynamicRegistration.value()));
    }
    if (structure.relatedDocumentSupport.has_value()) {
      object.emplace("relatedDocumentSupport", booleanToAny(structure.relatedDocumentSupport.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToInlineCompletionClientCapabilities(
    const LSPAny &any
  ) const -> std::unique_ptr<InlineCompletionClientCapabilities> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) InlineCompletionClientCapabilities must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<InlineCompletionClientCapabilities> value =
      std::make_unique<InlineCompletionClientCapabilities>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) InlineCompletionClientCapabilities: " + std::to_string(object.size())
      );
    }

    iter = object.find("dynamicRegistration");
    if (iter != object.end()) {
      value->dynamicRegistration = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::inlineCompletionClientCapabilitiesToAny(
    const InlineCompletionClientCapabilities &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.dynamicRegistration.has_value()) {
      object.emplace("dynamicRegistration", booleanToAny(structure.dynamicRegistration.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToNotebookDocumentSyncClientCapabilities(
    const LSPAny &any
  ) const -> std::unique_ptr<NotebookDocumentSyncClientCapabilities> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) NotebookDocumentSyncClientCapabilities must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<NotebookDocumentSyncClientCapabilities> value =
      std::make_unique<NotebookDocumentSyncClientCapabilities>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) NotebookDocumentSyncClientCapabilities: " + std::to_string(object.size())
      );
    }

    iter = object.find("dynamicRegistration");
    if (iter != object.end()) {
      value->dynamicRegistration = anyToBoolean(*iter->second);
    }

    iter = object.find("executionSummarySupport");
    if (iter != object.end()) {
      value->executionSummarySupport = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::notebookDocumentSyncClientCapabilitiesToAny(
    const NotebookDocumentSyncClientCapabilities &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.dynamicRegistration.has_value()) {
      object.emplace("dynamicRegistration", booleanToAny(structure.dynamicRegistration.value()));
    }
    if (structure.executionSummarySupport.has_value()) {
      object.emplace("executionSummarySupport", booleanToAny(structure.executionSummarySupport.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToShowMessageRequestClientCapabilities_messageActionItem(
    const LSPAny &any
  ) const -> std::unique_ptr<ShowMessageRequestClientCapabilities_messageActionItem> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) ShowMessageRequestClientCapabilities_messageActionItem must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<ShowMessageRequestClientCapabilities_messageActionItem> value =
      std::make_unique<ShowMessageRequestClientCapabilities_messageActionItem>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) ShowMessageRequestClientCapabilities_messageActionItem: " + std::to_string(object.size())
      );
    }

    iter = object.find("additionalPropertiesSupport");
    if (iter != object.end()) {
      value->additionalPropertiesSupport = anyToBoolean(*iter->second);
    }

    return value;
  }

  auto LspTransformer::showMessageRequestClientCapabilities_messageActionItemToAny(
    const ShowMessageRequestClientCapabilities_messageActionItem &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.additionalPropertiesSupport.has_value()) {
      object.emplace("additionalPropertiesSupport", booleanToAny(structure.additionalPropertiesSupport.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToShowMessageRequestClientCapabilities(
    const LSPAny &any
  ) const -> std::unique_ptr<ShowMessageRequestClientCapabilities> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) ShowMessageRequestClientCapabilities must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<ShowMessageRequestClientCapabilities> value =
      std::make_unique<ShowMessageRequestClientCapabilities>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) ShowMessageRequestClientCapabilities: " + std::to_string(object.size())
      );
    }

    iter = object.find("messageActionItem");
    if (iter != object.end()) {
      value->messageActionItem = anyToShowMessageRequestClientCapabilities_messageActionItem(*iter->second);
    }

    return value;
  }

  auto LspTransformer::showMessageRequestClientCapabilitiesToAny(
    const ShowMessageRequestClientCapabilities &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.messageActionItem.has_value()) {
      object.emplace("messageActionItem", showMessageRequestClientCapabilities_messageActionItemToAny(*structure.messageActionItem.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToShowDocumentClientCapabilities(
    const LSPAny &any
  ) const -> std::unique_ptr<ShowDocumentClientCapabilities> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) ShowDocumentClientCapabilities must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<ShowDocumentClientCapabilities> value =
      std::make_unique<ShowDocumentClientCapabilities>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) ShowDocumentClientCapabilities: " + std::to_string(object.size())
      );
    }

    iter = object.find("support");
    if (iter != object.end()) {
      value->support = anyToBoolean(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required ShowDocumentClientCapabilities attribute: support"
      );
    }

    return value;
  }

  auto LspTransformer::showDocumentClientCapabilitiesToAny(
    const ShowDocumentClientCapabilities &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("support", booleanToAny(structure.support));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToRegularExpressionsClientCapabilities(
    const LSPAny &any
  ) const -> std::unique_ptr<RegularExpressionsClientCapabilities> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) RegularExpressionsClientCapabilities must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<RegularExpressionsClientCapabilities> value =
      std::make_unique<RegularExpressionsClientCapabilities>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) RegularExpressionsClientCapabilities: " + std::to_string(object.size())
      );
    }

    iter = object.find("engine");
    if (iter != object.end()) {
      value->engine = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required RegularExpressionsClientCapabilities attribute: engine"
      );
    }

    iter = object.find("version");
    if (iter != object.end()) {
      value->version = anyToString(*iter->second);
    }

    return value;
  }

  auto LspTransformer::regularExpressionsClientCapabilitiesToAny(
    const RegularExpressionsClientCapabilities &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("engine", stringToAny(structure.engine));
    if (structure.version.has_value()) {
      object.emplace("version", stringToAny(structure.version.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToMarkdownClientCapabilities(
    const LSPAny &any
  ) const -> std::unique_ptr<MarkdownClientCapabilities> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) MarkdownClientCapabilities must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<MarkdownClientCapabilities> value =
      std::make_unique<MarkdownClientCapabilities>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) MarkdownClientCapabilities: " + std::to_string(object.size())
      );
    }

    iter = object.find("parser");
    if (iter != object.end()) {
      value->parser = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required MarkdownClientCapabilities attribute: parser"
      );
    }

    iter = object.find("version");
    if (iter != object.end()) {
      value->version = anyToString(*iter->second);
    }

    iter = object.find("allowedTags");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<string_t> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToString(*elem));
      }
      value->allowedTags = std::move(values);
    }

    return value;
  }

  auto LspTransformer::markdownClientCapabilitiesToAny(
    const MarkdownClientCapabilities &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("parser", stringToAny(structure.parser));
    if (structure.version.has_value()) {
      object.emplace("version", stringToAny(structure.version.value()));
    }
    if (structure.allowedTags.has_value()) {
      LSPArray array;
      for (const string_t &elem : structure.allowedTags.value()) {
        array.push_back(stringToAny(elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("allowedTags", std::move(any));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  // ==================================== //
  // LSPAny <-> LSP Type Alias Transforms //
  // ==================================== //

  auto LspTransformer::anyToInteger(
    const LSPAny &any
  ) const -> int {
    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::INTEGER_TYPE: {
      return std::get<integer_t>(any);
    }
    case LSPAnyType::UINTEGER_TYPE: {
      uinteger_t value = std::get<uinteger_t>(any);
      return static_cast<integer_t>(value);
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Cannot transform LSPAny of type LSPAnyType::" +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())) +
         " to type integer_t")
      );
    }
    }
  }

  auto LspTransformer::integerToAny(
    const integer_t &alias
  ) const -> std::unique_ptr<LSPAny> {
    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = alias;
    return any;
  }

  auto LspTransformer::anyToUInteger(
    const LSPAny &any
  ) const -> unsigned int {
    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::UINTEGER_TYPE: {
      return std::get<uinteger_t>(any);
    }
    case LSPAnyType::INTEGER_TYPE: {
      integer_t value = std::get<integer_t>(any);
      return static_cast<uinteger_t>(value);
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Cannot transform LSPAny of type LSPAnyType::" +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())) +
         " to type uinteger_t")
      );
    }
    }
  }

  auto LspTransformer::uintegerToAny(
    const uinteger_t &alias
  ) const -> std::unique_ptr<LSPAny> {
    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = alias;
    return any;
  }

  auto LspTransformer::anyToDecimal(
    const LSPAny &any
  ) const -> double {
    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::DECIMAL_TYPE: {
      return std::get<decimal_t>(any);
    }
    case LSPAnyType::INTEGER_TYPE: {
      integer_t value = std::get<integer_t>(any);
      return static_cast<decimal_t>(value);
    }
    case LSPAnyType::UINTEGER_TYPE: {
      uinteger_t value = std::get<uinteger_t>(any);
      return static_cast<decimal_t>(value);
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Cannot transform LSPAny of type LSPAnyType::" +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())) +
         " to type decimal_t")
      );
    }
    }
  }

  auto LspTransformer::decimalToAny(
    const decimal_t &alias
  ) const -> std::unique_ptr<LSPAny> {
    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = alias;
    return any;
  }

  auto LspTransformer::anyToBoolean(
    const LSPAny &any
  ) const -> bool {
    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::BOOLEAN_TYPE: {
      return std::get<boolean_t>(any);
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Cannot transform LSPAny of type LSPAnyType::" +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())) +
         " to type boolean_t")
      );
    }
    }
  }

  auto LspTransformer::booleanToAny(
    const boolean_t &alias
  ) const -> std::unique_ptr<LSPAny> {
    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = alias;
    return any;
  }

  auto LspTransformer::anyToNull(
    const LSPAny &any
  ) const -> std::nullptr_t {
    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::NULL_TYPE: {
      return std::get<null_t>(any);
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Cannot transform LSPAny of type LSPAnyType::" +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())) +
         " to type null_t")
      );
    }
    }
  }

  auto LspTransformer::nullToAny(
    const null_t &alias
  ) const -> std::unique_ptr<LSPAny> {
    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = alias;
    return any;
  }

  auto LspTransformer::anyToString(
    const LSPAny &any
  ) const -> std::string {
    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::STRING_TYPE: {
      return std::get<string_t>(any);
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Cannot transform LSPAny of type LSPAnyType::" +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())) +
         " to type string_t")
      );
    }
    }
  }

  auto LspTransformer::stringToAny(
    const string_t &alias
  ) const -> std::unique_ptr<LSPAny> {
    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = alias;
    return any;
  }

  auto LspTransformer::anyToURI(
    const LSPAny &any
  ) const -> string_t {
    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::STRING_TYPE: {
      return std::get<URI>(any);
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Cannot transform LSPAny of type LSPAnyType::" +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())) +
         " to type URI")
      );
    }
    }
  }

  auto LspTransformer::uriToAny(
    const URI &alias
  ) const -> std::unique_ptr<LSPAny> {
    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = alias;
    return any;
  }

  auto LspTransformer::anyToDocumentUri(
    const LSPAny &any
  ) const -> string_t {
    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::STRING_TYPE: {
      return std::get<DocumentUri>(any);
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Cannot transform LSPAny of type LSPAnyType::" +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())) +
         " to type DocumentUri")
      );
    }
    }
  }

  auto LspTransformer::documentUriToAny(
    const DocumentUri &alias
  ) const -> std::unique_ptr<LSPAny> {
    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = alias;
    return any;
  }

  auto LspTransformer::anyToRegExp(
    const LSPAny &any
  ) const -> string_t {
    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::STRING_TYPE: {
      return std::get<RegExp>(any);
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Cannot transform LSPAny of type LSPAnyType::" +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())) +
         " to type RegExp")
      );
    }
    }
  }

  auto LspTransformer::regExpToAny(
    const RegExp &alias
  ) const -> std::unique_ptr<LSPAny> {
    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = alias;
    return any;
  }

  auto LspTransformer::anyToRequestId(
    const LSPAny &any
  ) const -> RequestId {
    RequestId value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::STRING_TYPE: {
      value = anyToString(any);
      break;
    }
    case LSPAnyType::INTEGER_TYPE: {
      value = anyToInteger(any);
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) RequestId: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::requestIdToAny(
    const RequestId &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<RequestIdType>(variant.index())) {
    case RequestIdType::INTEGER_TYPE: {
      return integerToAny(
        std::get<integer_t>(variant)
      );
    }
    case RequestIdType::STRING_TYPE: {
      return stringToAny(
        std::get<string_t>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported RequestIdType: " +
         RequestIdTypeNames.at(static_cast<RequestIdType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToMessageParams(
    const LSPAny &any
  ) const -> MessageParams {
    MessageParams value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::OBJECT_TYPE: {
      try {
        const LSPObject &object = std::get<LSPObject>(any);
        value = copy(object);
      } catch (LspException &e) {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          "Failed to transform LSPAny to MessageParams"
        );
      }
      break;
    }
    case LSPAnyType::ARRAY_TYPE: {
      try {
        const LSPArray &array = std::get<LSPArray>(any);
        value = copy(array);
      } catch (LspException &e) {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          "Failed to transform LSPAny to array"
        );
      }
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) MessageParams: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::messageParamsToAny(
    const MessageParams &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<MessageParamsType>(variant.index())) {
    case MessageParamsType::ARRAY_TYPE: {
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = copy(std::get<LSPArray>(variant));
      return any;
    }
    case MessageParamsType::OBJECT_TYPE: {
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = copy(std::get<LSPObject>(variant));
      return any;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported MessageParamsType: " +
         MessageParamsTypeNames.at(static_cast<MessageParamsType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToResponseId(
    const LSPAny &any
  ) const -> ResponseId {
    ResponseId value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::STRING_TYPE: {
      value = anyToString(any);
      break;
    }
    case LSPAnyType::INTEGER_TYPE: {
      value = anyToInteger(any);
      break;
    }
    case LSPAnyType::NULL_TYPE: {
      value = anyToNull(any);
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) ResponseId: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::responseIdToAny(
    const ResponseId &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<ResponseIdType>(variant.index())) {
    case ResponseIdType::INTEGER_TYPE: {
      return integerToAny(
        std::get<integer_t>(variant)
      );
    }
    case ResponseIdType::STRING_TYPE: {
      return stringToAny(
        std::get<string_t>(variant)
      );
    }
    case ResponseIdType::NULL_TYPE: {
      return nullToAny(
        std::get<null_t>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported ResponseIdType: " +
         ResponseIdTypeNames.at(static_cast<ResponseIdType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToDefinition(
    const LSPAny &any
  ) const -> Definition {
    Definition value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::OBJECT_TYPE: {
      try {
        value = anyToLocation(any);
      } catch (LspException &e) {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          "Failed to transform LSPAny to Definition"
        );
      }
      break;
    }
    case LSPAnyType::ARRAY_TYPE: {
      try {
        std::vector<std::unique_ptr<Location>> values;
        for (const std::unique_ptr<LSPAny> &elem
            : std::get<LSPArray>(any)) {
          values.push_back(anyToLocation(*elem));
        }
        value = std::move(values);
      } catch (LspException &e) {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          "Failed to transform LSPAny to array"
        );
      }
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) Definition: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::definitionToAny(
    const Definition &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<DefinitionType>(variant.index())) {
    case DefinitionType::LOCATION: {
      return locationToAny(
        *std::get<std::unique_ptr<Location>>(variant)
      );
    }
    case DefinitionType::LOCATION_ARRAY: {
      LSPArray array;
      for (const std::unique_ptr<Location> &elem
          : std::get<std::vector<std::unique_ptr<Location>>>(variant)) {
        array.push_back(locationToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      return any;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported DefinitionType: " +
         DefinitionTypeNames.at(static_cast<DefinitionType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToDefinitionLink(
    const LSPAny &any
  ) const -> std::unique_ptr<LocationLink> {
    return anyToLocationLink(any);
  }

  auto LspTransformer::definitionLinkToAny(
    const DefinitionLink &alias
  ) const -> std::unique_ptr<LSPAny> {
    return locationLinkToAny(alias);
  }

  auto LspTransformer::anyToDeclaration(
    const LSPAny &any
  ) const -> Declaration {
    Declaration value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::OBJECT_TYPE: {
      try {
        value = anyToLocation(any);
      } catch (LspException &e) {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          "Failed to transform LSPAny to Declaration"
        );
      }
      break;
    }
    case LSPAnyType::ARRAY_TYPE: {
      try {
        std::vector<std::unique_ptr<Location>> values;
        for (const std::unique_ptr<LSPAny> &elem
            : std::get<LSPArray>(any)) {
          values.push_back(anyToLocation(*elem));
        }
        value = std::move(values);
      } catch (LspException &e) {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          "Failed to transform LSPAny to array"
        );
      }
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) Declaration: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::declarationToAny(
    const Declaration &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<DeclarationType>(variant.index())) {
    case DeclarationType::LOCATION: {
      return locationToAny(
        *std::get<std::unique_ptr<Location>>(variant)
      );
    }
    case DeclarationType::LOCATION_ARRAY: {
      LSPArray array;
      for (const std::unique_ptr<Location> &elem
          : std::get<std::vector<std::unique_ptr<Location>>>(variant)) {
        array.push_back(locationToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      return any;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported DeclarationType: " +
         DeclarationTypeNames.at(static_cast<DeclarationType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToDeclarationLink(
    const LSPAny &any
  ) const -> std::unique_ptr<LocationLink> {
    return anyToLocationLink(any);
  }

  auto LspTransformer::declarationLinkToAny(
    const DeclarationLink &alias
  ) const -> std::unique_ptr<LSPAny> {
    return locationLinkToAny(alias);
  }

  auto LspTransformer::anyToInlineValue(
    const LSPAny &any
  ) const -> InlineValue {
    InlineValue value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::OBJECT_TYPE: {
      try {
        value = anyToInlineValueText(any);
      } catch (LspException &e) {
        try {
          value = anyToInlineValueVariableLookup(any);
        } catch (LspException &e) {
          try {
            value = anyToInlineValueEvaluatableExpression(any);
          } catch (LspException &e) {
            throw LSP_EXCEPTION(
              ErrorCodes::INVALID_PARAMS,
              "Failed to transform LSPAny to InlineValue"
            );
          }
        }
      }
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) InlineValue: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::inlineValueToAny(
    const InlineValue &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<InlineValueType>(variant.index())) {
    case InlineValueType::INLINE_VALUE_TEXT: {
      return inlineValueTextToAny(
        *std::get<std::unique_ptr<InlineValueText>>(variant)
      );
    }
    case InlineValueType::INLINE_VALUE_VARIABLE_LOOKUP: {
      return inlineValueVariableLookupToAny(
        *std::get<std::unique_ptr<InlineValueVariableLookup>>(variant)
      );
    }
    case InlineValueType::INLINE_VALUE_EVALUATABLE_EXPRESSION: {
      return inlineValueEvaluatableExpressionToAny(
        *std::get<std::unique_ptr<InlineValueEvaluatableExpression>>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported InlineValueType: " +
         InlineValueTypeNames.at(static_cast<InlineValueType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToDocumentDiagnosticReport(
    const LSPAny &any
  ) const -> DocumentDiagnosticReport {
    DocumentDiagnosticReport value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::OBJECT_TYPE: {
      try {
        value = anyToRelatedFullDocumentDiagnosticReport(any);
      } catch (LspException &e) {
        try {
          value = anyToRelatedUnchangedDocumentDiagnosticReport(any);
        } catch (LspException &e) {
          throw LSP_EXCEPTION(
            ErrorCodes::INVALID_PARAMS,
            "Failed to transform LSPAny to DocumentDiagnosticReport"
          );
        }
      }
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) DocumentDiagnosticReport: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::documentDiagnosticReportToAny(
    const DocumentDiagnosticReport &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<DocumentDiagnosticReportType>(variant.index())) {
    case DocumentDiagnosticReportType::RELATED_FULL_DOCUMENT_DIAGNOSTIC_REPORT: {
      return relatedFullDocumentDiagnosticReportToAny(
        *std::get<std::unique_ptr<RelatedFullDocumentDiagnosticReport>>(variant)
      );
    }
    case DocumentDiagnosticReportType::RELATED_UNCHANGED_DOCUMENT_DIAGNOSTIC_REPORT: {
      return relatedUnchangedDocumentDiagnosticReportToAny(
        *std::get<std::unique_ptr<RelatedUnchangedDocumentDiagnosticReport>>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported DocumentDiagnosticReportType: " +
         DocumentDiagnosticReportTypeNames.at(static_cast<DocumentDiagnosticReportType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToPrepareRenameResult_2(
    const LSPAny &any
  ) const -> std::unique_ptr<PrepareRenameResult_2> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) PrepareRenameResult_2 must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<PrepareRenameResult_2> value =
      std::make_unique<PrepareRenameResult_2>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) PrepareRenameResult_2: " + std::to_string(object.size())
      );
    }

    iter = object.find("defaultBehavior");
    if (iter != object.end()) {
      value->defaultBehavior = anyToBoolean(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required PrepareRenameResult_2 attribute: defaultBehavior"
      );
    }

    return value;
  }

  auto LspTransformer::prepareRenameResult_2ToAny(
    const PrepareRenameResult_2 &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("defaultBehavior", booleanToAny(structure.defaultBehavior));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToPrepareRenameResult_1(
    const LSPAny &any
  ) const -> std::unique_ptr<PrepareRenameResult_1> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) PrepareRenameResult_1 must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<PrepareRenameResult_1> value =
      std::make_unique<PrepareRenameResult_1>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) PrepareRenameResult_1: " + std::to_string(object.size())
      );
    }

    iter = object.find("range");
    if (iter != object.end()) {
      value->range = anyToRange(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required PrepareRenameResult_1 attribute: range"
      );
    }

    iter = object.find("placeholder");
    if (iter != object.end()) {
      value->placeholder = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required PrepareRenameResult_1 attribute: placeholder"
      );
    }

    return value;
  }

  auto LspTransformer::prepareRenameResult_1ToAny(
    const PrepareRenameResult_1 &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("range", rangeToAny(*structure.range));
    object.emplace("placeholder", stringToAny(structure.placeholder));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToPrepareRenameResult(
    const LSPAny &any
  ) const -> PrepareRenameResult {
    PrepareRenameResult value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::OBJECT_TYPE: {
      try {
        value = anyToRange(any);
      } catch (LspException &e) {
        try {
          value = anyToPrepareRenameResult_1(any);
        } catch (LspException &e) {
          try {
            value = anyToPrepareRenameResult_2(any);
          } catch (LspException &e) {
            throw LSP_EXCEPTION(
              ErrorCodes::INVALID_PARAMS,
              "Failed to transform LSPAny to PrepareRenameResult"
            );
          }
        }
      }
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) PrepareRenameResult: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::prepareRenameResultToAny(
    const PrepareRenameResult &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<PrepareRenameResultType>(variant.index())) {
    case PrepareRenameResultType::RANGE: {
      return rangeToAny(
        *std::get<std::unique_ptr<Range>>(variant)
      );
    }
    case PrepareRenameResultType::PREPARE_RENAME_RESULT_1: {
      return prepareRenameResult_1ToAny(
        *std::get<std::unique_ptr<PrepareRenameResult_1>>(variant)
      );
    }
    case PrepareRenameResultType::PREPARE_RENAME_RESULT_2: {
      return prepareRenameResult_2ToAny(
        *std::get<std::unique_ptr<PrepareRenameResult_2>>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported PrepareRenameResultType: " +
         PrepareRenameResultTypeNames.at(static_cast<PrepareRenameResultType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToDocumentSelector(
    const LSPAny &any
  ) const -> std::vector<DocumentFilter> {
    const LSPArray &array = std::get<LSPArray>(any);
    std::vector<DocumentFilter> values;
    for (const std::unique_ptr<LSPAny> &elem : array) {
      values.push_back(anyToDocumentFilter(*elem));
    }
    return values;
  }

  auto LspTransformer::documentSelectorToAny(
    const DocumentSelector &alias
  ) const -> std::unique_ptr<LSPAny> {
    LSPArray array;
    for (const DocumentFilter &elem : alias) {
      array.push_back(documentFilterToAny(elem));
    }
    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(array);
    return any;
  }

  auto LspTransformer::anyToProgressToken(
    const LSPAny &any
  ) const -> ProgressToken {
    ProgressToken value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::STRING_TYPE: {
      value = anyToString(any);
      break;
    }
    case LSPAnyType::INTEGER_TYPE: {
      value = anyToInteger(any);
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) ProgressToken: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::progressTokenToAny(
    const ProgressToken &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<ProgressTokenType>(variant.index())) {
    case ProgressTokenType::INTEGER_TYPE: {
      return integerToAny(
        std::get<integer_t>(variant)
      );
    }
    case ProgressTokenType::STRING_TYPE: {
      return stringToAny(
        std::get<string_t>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported ProgressTokenType: " +
         ProgressTokenTypeNames.at(static_cast<ProgressTokenType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToChangeAnnotationIdentifier(
    const LSPAny &any
  ) const -> string_t {
    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::OBJECT_TYPE: {
      return std::get<ChangeAnnotationIdentifier>(any);
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Cannot transform LSPAny of type LSPAnyType::" +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())) +
         " to type ChangeAnnotationIdentifier")
      );
    }
    }
  }

  auto LspTransformer::changeAnnotationIdentifierToAny(
    const ChangeAnnotationIdentifier &alias
  ) const -> std::unique_ptr<LSPAny> {
    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = alias;
    return any;
  }

  auto LspTransformer::anyToWorkspaceDocumentDiagnosticReport(
    const LSPAny &any
  ) const -> WorkspaceDocumentDiagnosticReport {
    WorkspaceDocumentDiagnosticReport value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::OBJECT_TYPE: {
      try {
        value = anyToWorkspaceFullDocumentDiagnosticReport(any);
      } catch (LspException &e) {
        try {
          value = anyToWorkspaceUnchangedDocumentDiagnosticReport(any);
        } catch (LspException &e) {
          throw LSP_EXCEPTION(
            ErrorCodes::INVALID_PARAMS,
            "Failed to transform LSPAny to WorkspaceDocumentDiagnosticReport"
          );
        }
      }
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) WorkspaceDocumentDiagnosticReport: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::workspaceDocumentDiagnosticReportToAny(
    const WorkspaceDocumentDiagnosticReport &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<WorkspaceDocumentDiagnosticReportType>(variant.index())) {
    case WorkspaceDocumentDiagnosticReportType::WORKSPACE_FULL_DOCUMENT_DIAGNOSTIC_REPORT: {
      return workspaceFullDocumentDiagnosticReportToAny(
        *std::get<std::unique_ptr<WorkspaceFullDocumentDiagnosticReport>>(variant)
      );
    }
    case WorkspaceDocumentDiagnosticReportType::WORKSPACE_UNCHANGED_DOCUMENT_DIAGNOSTIC_REPORT: {
      return workspaceUnchangedDocumentDiagnosticReportToAny(
        *std::get<std::unique_ptr<WorkspaceUnchangedDocumentDiagnosticReport>>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported WorkspaceDocumentDiagnosticReportType: " +
         WorkspaceDocumentDiagnosticReportTypeNames.at(static_cast<WorkspaceDocumentDiagnosticReportType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToTextDocumentContentChangeEvent_1(
    const LSPAny &any
  ) const -> std::unique_ptr<TextDocumentContentChangeEvent_1> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) TextDocumentContentChangeEvent_1 must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<TextDocumentContentChangeEvent_1> value =
      std::make_unique<TextDocumentContentChangeEvent_1>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 1) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) TextDocumentContentChangeEvent_1: " + std::to_string(object.size())
      );
    }

    iter = object.find("text");
    if (iter != object.end()) {
      value->text = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required TextDocumentContentChangeEvent_1 attribute: text"
      );
    }

    return value;
  }

  auto LspTransformer::textDocumentContentChangeEvent_1ToAny(
    const TextDocumentContentChangeEvent_1 &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("text", stringToAny(structure.text));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToTextDocumentContentChangeEvent_0(
    const LSPAny &any
  ) const -> std::unique_ptr<TextDocumentContentChangeEvent_0> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) TextDocumentContentChangeEvent_0 must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<TextDocumentContentChangeEvent_0> value =
      std::make_unique<TextDocumentContentChangeEvent_0>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) TextDocumentContentChangeEvent_0: " + std::to_string(object.size())
      );
    }

    iter = object.find("range");
    if (iter != object.end()) {
      value->range = anyToRange(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required TextDocumentContentChangeEvent_0 attribute: range"
      );
    }

    iter = object.find("rangeLength");
    if (iter != object.end()) {
      value->rangeLength = anyToUInteger(*iter->second);
    }

    iter = object.find("text");
    if (iter != object.end()) {
      value->text = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required TextDocumentContentChangeEvent_0 attribute: text"
      );
    }

    return value;
  }

  auto LspTransformer::textDocumentContentChangeEvent_0ToAny(
    const TextDocumentContentChangeEvent_0 &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("range", rangeToAny(*structure.range));
    if (structure.rangeLength.has_value()) {
      object.emplace("rangeLength", uintegerToAny(structure.rangeLength.value()));
    }
    object.emplace("text", stringToAny(structure.text));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToTextDocumentContentChangeEvent(
    const LSPAny &any
  ) const -> TextDocumentContentChangeEvent {
    TextDocumentContentChangeEvent value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::OBJECT_TYPE: {
      try {
        value = anyToTextDocumentContentChangeEvent_0(any);
      } catch (LspException &e) {
        try {
          value = anyToTextDocumentContentChangeEvent_1(any);
        } catch (LspException &e) {
          throw LSP_EXCEPTION(
            ErrorCodes::INVALID_PARAMS,
            "Failed to transform LSPAny to TextDocumentContentChangeEvent"
          );
        }
      }
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) TextDocumentContentChangeEvent: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::textDocumentContentChangeEventToAny(
    const TextDocumentContentChangeEvent &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<TextDocumentContentChangeEventType>(variant.index())) {
    case TextDocumentContentChangeEventType::TEXT_DOCUMENT_CONTENT_CHANGE_EVENT_0: {
      return textDocumentContentChangeEvent_0ToAny(
        *std::get<std::unique_ptr<TextDocumentContentChangeEvent_0>>(variant)
      );
    }
    case TextDocumentContentChangeEventType::TEXT_DOCUMENT_CONTENT_CHANGE_EVENT_1: {
      return textDocumentContentChangeEvent_1ToAny(
        *std::get<std::unique_ptr<TextDocumentContentChangeEvent_1>>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported TextDocumentContentChangeEventType: " +
         TextDocumentContentChangeEventTypeNames.at(static_cast<TextDocumentContentChangeEventType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToMarkedString_1(
    const LSPAny &any
  ) const -> std::unique_ptr<MarkedString_1> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) MarkedString_1 must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<MarkedString_1> value =
      std::make_unique<MarkedString_1>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 2) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) MarkedString_1: " + std::to_string(object.size())
      );
    }

    iter = object.find("language");
    if (iter != object.end()) {
      value->language = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required MarkedString_1 attribute: language"
      );
    }

    iter = object.find("value");
    if (iter != object.end()) {
      value->value = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required MarkedString_1 attribute: value"
      );
    }

    return value;
  }

  auto LspTransformer::markedString_1ToAny(
    const MarkedString_1 &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("language", stringToAny(structure.language));
    object.emplace("value", stringToAny(structure.value));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToMarkedString(
    const LSPAny &any
  ) const -> MarkedString {
    MarkedString value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::OBJECT_TYPE: {
      try {
        value = anyToMarkedString_1(any);
      } catch (LspException &e) {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          "Failed to transform LSPAny to MarkedString"
        );
      }
      break;
    }
    case LSPAnyType::STRING_TYPE: {
      value = anyToString(any);
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) MarkedString: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::markedStringToAny(
    const MarkedString &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<MarkedStringType>(variant.index())) {
    case MarkedStringType::STRING_TYPE: {
      return stringToAny(
        std::get<string_t>(variant)
      );
    }
    case MarkedStringType::MARKED_STRING_1: {
      return markedString_1ToAny(
        *std::get<std::unique_ptr<MarkedString_1>>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported MarkedStringType: " +
         MarkedStringTypeNames.at(static_cast<MarkedStringType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToDocumentFilter(
    const LSPAny &any
  ) const -> DocumentFilter {
    DocumentFilter value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::OBJECT_TYPE: {
      try {
        value = anyToNotebookCellTextDocumentFilter(any);
      } catch (LspException &e) {
        try {
          value = anyToTextDocumentFilter(any);
        } catch (LspException &e) {
          throw LSP_EXCEPTION(
            ErrorCodes::INVALID_PARAMS,
            "Failed to transform LSPAny to DocumentFilter"
          );
        }
      }
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) DocumentFilter: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::documentFilterToAny(
    const DocumentFilter &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<DocumentFilterType>(variant.index())) {
    case DocumentFilterType::TEXT_DOCUMENT_FILTER: {
      return textDocumentFilterToAny(
        std::get<TextDocumentFilter>(variant)
      );
    }
    case DocumentFilterType::NOTEBOOK_CELL_TEXT_DOCUMENT_FILTER: {
      return notebookCellTextDocumentFilterToAny(
        *std::get<std::unique_ptr<NotebookCellTextDocumentFilter>>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported DocumentFilterType: " +
         DocumentFilterTypeNames.at(static_cast<DocumentFilterType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToGlobPattern(
    const LSPAny &any
  ) const -> GlobPattern {
    GlobPattern value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::OBJECT_TYPE: {
      try {
        value = anyToRelativePattern(any);
      } catch (LspException &e) {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          "Failed to transform LSPAny to GlobPattern"
        );
      }
      break;
    }
    case LSPAnyType::STRING_TYPE: {
      value = anyToString(any);
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) GlobPattern: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::globPatternToAny(
    const GlobPattern &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<GlobPatternType>(variant.index())) {
    case GlobPatternType::PATTERN: {
      return patternToAny(
        std::get<Pattern>(variant)
      );
    }
    case GlobPatternType::RELATIVE_PATTERN: {
      return relativePatternToAny(
        *std::get<std::unique_ptr<RelativePattern>>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported GlobPatternType: " +
         GlobPatternTypeNames.at(static_cast<GlobPatternType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToTextDocumentFilter_2(
    const LSPAny &any
  ) const -> std::unique_ptr<TextDocumentFilter_2> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) TextDocumentFilter_2 must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<TextDocumentFilter_2> value =
      std::make_unique<TextDocumentFilter_2>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) TextDocumentFilter_2: " + std::to_string(object.size())
      );
    }

    iter = object.find("language");
    if (iter != object.end()) {
      value->language = anyToString(*iter->second);
    }

    iter = object.find("scheme");
    if (iter != object.end()) {
      value->scheme = anyToString(*iter->second);
    }

    iter = object.find("pattern");
    if (iter != object.end()) {
      value->pattern = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required TextDocumentFilter_2 attribute: pattern"
      );
    }

    return value;
  }

  auto LspTransformer::textDocumentFilter_2ToAny(
    const TextDocumentFilter_2 &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.language.has_value()) {
      object.emplace("language", stringToAny(structure.language.value()));
    }
    if (structure.scheme.has_value()) {
      object.emplace("scheme", stringToAny(structure.scheme.value()));
    }
    object.emplace("pattern", stringToAny(structure.pattern));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToTextDocumentFilter_1(
    const LSPAny &any
  ) const -> std::unique_ptr<TextDocumentFilter_1> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) TextDocumentFilter_1 must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<TextDocumentFilter_1> value =
      std::make_unique<TextDocumentFilter_1>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) TextDocumentFilter_1: " + std::to_string(object.size())
      );
    }

    iter = object.find("language");
    if (iter != object.end()) {
      value->language = anyToString(*iter->second);
    }

    iter = object.find("scheme");
    if (iter != object.end()) {
      value->scheme = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required TextDocumentFilter_1 attribute: scheme"
      );
    }

    iter = object.find("pattern");
    if (iter != object.end()) {
      value->pattern = anyToString(*iter->second);
    }

    return value;
  }

  auto LspTransformer::textDocumentFilter_1ToAny(
    const TextDocumentFilter_1 &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.language.has_value()) {
      object.emplace("language", stringToAny(structure.language.value()));
    }
    object.emplace("scheme", stringToAny(structure.scheme));
    if (structure.pattern.has_value()) {
      object.emplace("pattern", stringToAny(structure.pattern.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToTextDocumentFilter_0(
    const LSPAny &any
  ) const -> std::unique_ptr<TextDocumentFilter_0> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) TextDocumentFilter_0 must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<TextDocumentFilter_0> value =
      std::make_unique<TextDocumentFilter_0>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) TextDocumentFilter_0: " + std::to_string(object.size())
      );
    }

    iter = object.find("language");
    if (iter != object.end()) {
      value->language = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required TextDocumentFilter_0 attribute: language"
      );
    }

    iter = object.find("scheme");
    if (iter != object.end()) {
      value->scheme = anyToString(*iter->second);
    }

    iter = object.find("pattern");
    if (iter != object.end()) {
      value->pattern = anyToString(*iter->second);
    }

    return value;
  }

  auto LspTransformer::textDocumentFilter_0ToAny(
    const TextDocumentFilter_0 &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("language", stringToAny(structure.language));
    if (structure.scheme.has_value()) {
      object.emplace("scheme", stringToAny(structure.scheme.value()));
    }
    if (structure.pattern.has_value()) {
      object.emplace("pattern", stringToAny(structure.pattern.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToTextDocumentFilter(
    const LSPAny &any
  ) const -> TextDocumentFilter {
    TextDocumentFilter value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::OBJECT_TYPE: {
      try {
        value = anyToTextDocumentFilter_0(any);
      } catch (LspException &e) {
        try {
          value = anyToTextDocumentFilter_1(any);
        } catch (LspException &e) {
          try {
            value = anyToTextDocumentFilter_2(any);
          } catch (LspException &e) {
            throw LSP_EXCEPTION(
              ErrorCodes::INVALID_PARAMS,
              "Failed to transform LSPAny to TextDocumentFilter"
            );
          }
        }
      }
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) TextDocumentFilter: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::textDocumentFilterToAny(
    const TextDocumentFilter &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<TextDocumentFilterType>(variant.index())) {
    case TextDocumentFilterType::TEXT_DOCUMENT_FILTER_0: {
      return textDocumentFilter_0ToAny(
        *std::get<std::unique_ptr<TextDocumentFilter_0>>(variant)
      );
    }
    case TextDocumentFilterType::TEXT_DOCUMENT_FILTER_1: {
      return textDocumentFilter_1ToAny(
        *std::get<std::unique_ptr<TextDocumentFilter_1>>(variant)
      );
    }
    case TextDocumentFilterType::TEXT_DOCUMENT_FILTER_2: {
      return textDocumentFilter_2ToAny(
        *std::get<std::unique_ptr<TextDocumentFilter_2>>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported TextDocumentFilterType: " +
         TextDocumentFilterTypeNames.at(static_cast<TextDocumentFilterType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToNotebookDocumentFilter_2(
    const LSPAny &any
  ) const -> std::unique_ptr<NotebookDocumentFilter_2> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) NotebookDocumentFilter_2 must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<NotebookDocumentFilter_2> value =
      std::make_unique<NotebookDocumentFilter_2>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) NotebookDocumentFilter_2: " + std::to_string(object.size())
      );
    }

    iter = object.find("notebookType");
    if (iter != object.end()) {
      value->notebookType = anyToString(*iter->second);
    }

    iter = object.find("scheme");
    if (iter != object.end()) {
      value->scheme = anyToString(*iter->second);
    }

    iter = object.find("pattern");
    if (iter != object.end()) {
      value->pattern = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required NotebookDocumentFilter_2 attribute: pattern"
      );
    }

    return value;
  }

  auto LspTransformer::notebookDocumentFilter_2ToAny(
    const NotebookDocumentFilter_2 &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.notebookType.has_value()) {
      object.emplace("notebookType", stringToAny(structure.notebookType.value()));
    }
    if (structure.scheme.has_value()) {
      object.emplace("scheme", stringToAny(structure.scheme.value()));
    }
    object.emplace("pattern", stringToAny(structure.pattern));

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToNotebookDocumentFilter_1(
    const LSPAny &any
  ) const -> std::unique_ptr<NotebookDocumentFilter_1> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) NotebookDocumentFilter_1 must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<NotebookDocumentFilter_1> value =
      std::make_unique<NotebookDocumentFilter_1>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) NotebookDocumentFilter_1: " + std::to_string(object.size())
      );
    }

    iter = object.find("notebookType");
    if (iter != object.end()) {
      value->notebookType = anyToString(*iter->second);
    }

    iter = object.find("scheme");
    if (iter != object.end()) {
      value->scheme = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required NotebookDocumentFilter_1 attribute: scheme"
      );
    }

    iter = object.find("pattern");
    if (iter != object.end()) {
      value->pattern = anyToString(*iter->second);
    }

    return value;
  }

  auto LspTransformer::notebookDocumentFilter_1ToAny(
    const NotebookDocumentFilter_1 &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    if (structure.notebookType.has_value()) {
      object.emplace("notebookType", stringToAny(structure.notebookType.value()));
    }
    object.emplace("scheme", stringToAny(structure.scheme));
    if (structure.pattern.has_value()) {
      object.emplace("pattern", stringToAny(structure.pattern.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToNotebookDocumentFilter_0(
    const LSPAny &any
  ) const -> std::unique_ptr<NotebookDocumentFilter_0> {
    if (static_cast<LSPAnyType>(any.index()) != LSPAnyType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("LSPAnyType for a(n) NotebookDocumentFilter_0 must be of type LSPAnyType::OBJECT_TYPE but received type " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }

    std::unique_ptr<NotebookDocumentFilter_0> value =
      std::make_unique<NotebookDocumentFilter_0>();

    const LSPObject &object = std::get<LSPObject>(any);
    LSPObject::const_iterator iter;

    if (object.size() > 3) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Too many attributes to transform to a(n) NotebookDocumentFilter_0: " + std::to_string(object.size())
      );
    }

    iter = object.find("notebookType");
    if (iter != object.end()) {
      value->notebookType = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required NotebookDocumentFilter_0 attribute: notebookType"
      );
    }

    iter = object.find("scheme");
    if (iter != object.end()) {
      value->scheme = anyToString(*iter->second);
    }

    iter = object.find("pattern");
    if (iter != object.end()) {
      value->pattern = anyToString(*iter->second);
    }

    return value;
  }

  auto LspTransformer::notebookDocumentFilter_0ToAny(
    const NotebookDocumentFilter_0 &structure
  ) const -> std::unique_ptr<LSPAny> {
    LSPObject object;

    object.emplace("notebookType", stringToAny(structure.notebookType));
    if (structure.scheme.has_value()) {
      object.emplace("scheme", stringToAny(structure.scheme.value()));
    }
    if (structure.pattern.has_value()) {
      object.emplace("pattern", stringToAny(structure.pattern.value()));
    }

    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(object);
    return any;
  }

  auto LspTransformer::anyToNotebookDocumentFilter(
    const LSPAny &any
  ) const -> NotebookDocumentFilter {
    NotebookDocumentFilter value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::OBJECT_TYPE: {
      try {
        value = anyToNotebookDocumentFilter_0(any);
      } catch (LspException &e) {
        try {
          value = anyToNotebookDocumentFilter_1(any);
        } catch (LspException &e) {
          try {
            value = anyToNotebookDocumentFilter_2(any);
          } catch (LspException &e) {
            throw LSP_EXCEPTION(
              ErrorCodes::INVALID_PARAMS,
              "Failed to transform LSPAny to NotebookDocumentFilter"
            );
          }
        }
      }
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) NotebookDocumentFilter: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::notebookDocumentFilterToAny(
    const NotebookDocumentFilter &variant
  ) const -> std::unique_ptr<LSPAny> {
    switch (static_cast<NotebookDocumentFilterType>(variant.index())) {
    case NotebookDocumentFilterType::NOTEBOOK_DOCUMENT_FILTER_0: {
      return notebookDocumentFilter_0ToAny(
        *std::get<std::unique_ptr<NotebookDocumentFilter_0>>(variant)
      );
    }
    case NotebookDocumentFilterType::NOTEBOOK_DOCUMENT_FILTER_1: {
      return notebookDocumentFilter_1ToAny(
        *std::get<std::unique_ptr<NotebookDocumentFilter_1>>(variant)
      );
    }
    case NotebookDocumentFilterType::NOTEBOOK_DOCUMENT_FILTER_2: {
      return notebookDocumentFilter_2ToAny(
        *std::get<std::unique_ptr<NotebookDocumentFilter_2>>(variant)
      );
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Unsupported NotebookDocumentFilterType: " +
         NotebookDocumentFilterTypeNames.at(static_cast<NotebookDocumentFilterType>(variant.index())))
      );
    }
    }
  }

  auto LspTransformer::anyToPattern(
    const LSPAny &any
  ) const -> string_t {
    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::OBJECT_TYPE: {
      return std::get<Pattern>(any);
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Cannot transform LSPAny of type LSPAnyType::" +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())) +
         " to type Pattern")
      );
    }
    }
  }

  auto LspTransformer::patternToAny(
    const Pattern &alias
  ) const -> std::unique_ptr<LSPAny> {
    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = alias;
    return any;
  }

  // ================= //
  // Incoming Requests //
  // ================= //

  auto LspTransformer::asTextDocumentImplementationParams(
    const MessageParams &requestParams
  ) const -> std::unique_ptr<ImplementationParams> {
    if (static_cast<MessageParamsType>(requestParams.index()) != MessageParamsType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Message parameter type must be MessageParamsType::" +
         MessageParamsTypeNames.at(MessageParamsType::OBJECT_TYPE) +
         " for method=\"textDocument/implementation\" but received type " +
         "MessageParamsType::" + MessageParamsTypeNames.at(static_cast<MessageParamsType>(requestParams.index())))
      );
    }

    const LSPObject &object = std::get<LSPObject>(requestParams);
    LSPObject::const_iterator iter;

    std::unique_ptr<ImplementationParams> implementationParams =
      std::make_unique<ImplementationParams>();

    iter = object.find("textDocument");
    if (iter != object.end()) {
      implementationParams->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required ImplementationParams attribute: textDocument"
      );
    }

    iter = object.find("position");
    if (iter != object.end()) {
      implementationParams->position = anyToPosition(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required ImplementationParams attribute: position"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      implementationParams->workDoneToken = anyToProgressToken(*iter->second);
    }

    iter = object.find("partialResultToken");
    if (iter != object.end()) {
      implementationParams->partialResultToken = anyToProgressToken(*iter->second);
    }

    return implementationParams;
  }

  auto LspTransformer::textDocumentImplementationResultToAny(
    const TextDocumentImplementationResult &result
  ) -> std::unique_ptr<LSPAny> {
    switch (static_cast<TextDocumentImplementationResultType>(result.index())) {
    case TextDocumentImplementationResultType::DEFINITION: {
      return definitionToAny(std::get<Definition>(result));
    }
    case TextDocumentImplementationResultType::DEFINITION_LINK_ARRAY: {
      LSPArray array;
      for (const std::unique_ptr<DefinitionLink> &elem
          : std::get<std::vector<std::unique_ptr<DefinitionLink>>>(result)) {
        array.push_back(definitionLinkToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      return any;
    }
    case TextDocumentImplementationResultType::NULL_TYPE: {
      return nullToAny(std::get<null_t>(result));
    }
    case TextDocumentImplementationResultType::LOCATION_ARRAY: {
      LSPArray array;
      for (const std::unique_ptr<Location> &elem
          : std::get<std::vector<std::unique_ptr<Location>>>(result)) {
        array.push_back(locationToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      return any;
    }
    }
    throw LSP_EXCEPTION(
      ErrorCodes::INTERNAL_ERROR,
      "Should be unreachable."
    );
  }

  auto LspTransformer::asTextDocumentTypeDefinitionParams(
    const MessageParams &requestParams
  ) const -> std::unique_ptr<TypeDefinitionParams> {
    if (static_cast<MessageParamsType>(requestParams.index()) != MessageParamsType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Message parameter type must be MessageParamsType::" +
         MessageParamsTypeNames.at(MessageParamsType::OBJECT_TYPE) +
         " for method=\"textDocument/typeDefinition\" but received type " +
         "MessageParamsType::" + MessageParamsTypeNames.at(static_cast<MessageParamsType>(requestParams.index())))
      );
    }

    const LSPObject &object = std::get<LSPObject>(requestParams);
    LSPObject::const_iterator iter;

    std::unique_ptr<TypeDefinitionParams> typeDefinitionParams =
      std::make_unique<TypeDefinitionParams>();

    iter = object.find("textDocument");
    if (iter != object.end()) {
      typeDefinitionParams->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required TypeDefinitionParams attribute: textDocument"
      );
    }

    iter = object.find("position");
    if (iter != object.end()) {
      typeDefinitionParams->position = anyToPosition(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required TypeDefinitionParams attribute: position"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      typeDefinitionParams->workDoneToken = anyToProgressToken(*iter->second);
    }

    iter = object.find("partialResultToken");
    if (iter != object.end()) {
      typeDefinitionParams->partialResultToken = anyToProgressToken(*iter->second);
    }

    return typeDefinitionParams;
  }

  auto LspTransformer::textDocumentTypeDefinitionResultToAny(
    const TextDocumentTypeDefinitionResult &result
  ) -> std::unique_ptr<LSPAny> {
    switch (static_cast<TextDocumentTypeDefinitionResultType>(result.index())) {
    case TextDocumentTypeDefinitionResultType::DEFINITION: {
      return definitionToAny(std::get<Definition>(result));
    }
    case TextDocumentTypeDefinitionResultType::DEFINITION_LINK_ARRAY: {
      LSPArray array;
      for (const std::unique_ptr<DefinitionLink> &elem
          : std::get<std::vector<std::unique_ptr<DefinitionLink>>>(result)) {
        array.push_back(definitionLinkToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      return any;
    }
    case TextDocumentTypeDefinitionResultType::NULL_TYPE: {
      return nullToAny(std::get<null_t>(result));
    }
    case TextDocumentTypeDefinitionResultType::LOCATION_ARRAY: {
      LSPArray array;
      for (const std::unique_ptr<Location> &elem
          : std::get<std::vector<std::unique_ptr<Location>>>(result)) {
        array.push_back(locationToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      return any;
    }
    }
    throw LSP_EXCEPTION(
      ErrorCodes::INTERNAL_ERROR,
      "Should be unreachable."
    );
  }

  auto LspTransformer::asTextDocumentDocumentColorParams(
    const MessageParams &requestParams
  ) const -> std::unique_ptr<DocumentColorParams> {
    if (static_cast<MessageParamsType>(requestParams.index()) != MessageParamsType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Message parameter type must be MessageParamsType::" +
         MessageParamsTypeNames.at(MessageParamsType::OBJECT_TYPE) +
         " for method=\"textDocument/documentColor\" but received type " +
         "MessageParamsType::" + MessageParamsTypeNames.at(static_cast<MessageParamsType>(requestParams.index())))
      );
    }

    const LSPObject &object = std::get<LSPObject>(requestParams);
    LSPObject::const_iterator iter;

    std::unique_ptr<DocumentColorParams> documentColorParams =
      std::make_unique<DocumentColorParams>();

    iter = object.find("textDocument");
    if (iter != object.end()) {
      documentColorParams->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DocumentColorParams attribute: textDocument"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      documentColorParams->workDoneToken = anyToProgressToken(*iter->second);
    }

    iter = object.find("partialResultToken");
    if (iter != object.end()) {
      documentColorParams->partialResultToken = anyToProgressToken(*iter->second);
    }

    return documentColorParams;
  }

  auto LspTransformer::textDocumentDocumentColorResultToAny(
    const TextDocumentDocumentColorResult &result
  ) -> std::unique_ptr<LSPAny> {
    LSPArray array;
    for (const std::unique_ptr<ColorInformation> &elem : result) {
      array.push_back(colorInformationToAny(*elem));    }
    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(array);
    return any;
  }

  auto LspTransformer::asTextDocumentColorPresentationParams(
    const MessageParams &requestParams
  ) const -> std::unique_ptr<ColorPresentationParams> {
    if (static_cast<MessageParamsType>(requestParams.index()) != MessageParamsType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Message parameter type must be MessageParamsType::" +
         MessageParamsTypeNames.at(MessageParamsType::OBJECT_TYPE) +
         " for method=\"textDocument/colorPresentation\" but received type " +
         "MessageParamsType::" + MessageParamsTypeNames.at(static_cast<MessageParamsType>(requestParams.index())))
      );
    }

    const LSPObject &object = std::get<LSPObject>(requestParams);
    LSPObject::const_iterator iter;

    std::unique_ptr<ColorPresentationParams> colorPresentationParams =
      std::make_unique<ColorPresentationParams>();

    iter = object.find("textDocument");
    if (iter != object.end()) {
      colorPresentationParams->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required ColorPresentationParams attribute: textDocument"
      );
    }

    iter = object.find("color");
    if (iter != object.end()) {
      colorPresentationParams->color = anyToColor(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required ColorPresentationParams attribute: color"
      );
    }

    iter = object.find("range");
    if (iter != object.end()) {
      colorPresentationParams->range = anyToRange(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required ColorPresentationParams attribute: range"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      colorPresentationParams->workDoneToken = anyToProgressToken(*iter->second);
    }

    iter = object.find("partialResultToken");
    if (iter != object.end()) {
      colorPresentationParams->partialResultToken = anyToProgressToken(*iter->second);
    }

    return colorPresentationParams;
  }

  auto LspTransformer::textDocumentColorPresentationResultToAny(
    const TextDocumentColorPresentationResult &result
  ) -> std::unique_ptr<LSPAny> {
    LSPArray array;
    for (const std::unique_ptr<ColorPresentation> &elem : result) {
      array.push_back(colorPresentationToAny(*elem));    }
    std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
    (*any) = std::move(array);
    return any;
  }

  auto LspTransformer::asTextDocumentFoldingRangeParams(
    const MessageParams &requestParams
  ) const -> std::unique_ptr<FoldingRangeParams> {
    if (static_cast<MessageParamsType>(requestParams.index()) != MessageParamsType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Message parameter type must be MessageParamsType::" +
         MessageParamsTypeNames.at(MessageParamsType::OBJECT_TYPE) +
         " for method=\"textDocument/foldingRange\" but received type " +
         "MessageParamsType::" + MessageParamsTypeNames.at(static_cast<MessageParamsType>(requestParams.index())))
      );
    }

    const LSPObject &object = std::get<LSPObject>(requestParams);
    LSPObject::const_iterator iter;

    std::unique_ptr<FoldingRangeParams> foldingRangeParams =
      std::make_unique<FoldingRangeParams>();

    iter = object.find("textDocument");
    if (iter != object.end()) {
      foldingRangeParams->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required FoldingRangeParams attribute: textDocument"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      foldingRangeParams->workDoneToken = anyToProgressToken(*iter->second);
    }

    iter = object.find("partialResultToken");
    if (iter != object.end()) {
      foldingRangeParams->partialResultToken = anyToProgressToken(*iter->second);
    }

    return foldingRangeParams;
  }

  auto LspTransformer::textDocumentFoldingRangeResultToAny(
    const TextDocumentFoldingRangeResult &result
  ) -> std::unique_ptr<LSPAny> {
    switch (static_cast<TextDocumentFoldingRangeResultType>(result.index())) {
    case TextDocumentFoldingRangeResultType::FOLDING_RANGE_ARRAY: {
      LSPArray array;
      for (const std::unique_ptr<FoldingRange> &elem
          : std::get<std::vector<std::unique_ptr<FoldingRange>>>(result)) {
        array.push_back(foldingRangeToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      return any;
    }
    case TextDocumentFoldingRangeResultType::NULL_TYPE: {
      return nullToAny(std::get<null_t>(result));
    }
    }
    throw LSP_EXCEPTION(
      ErrorCodes::INTERNAL_ERROR,
      "Should be unreachable."
    );
  }

  auto LspTransformer::asTextDocumentDeclarationParams(
    const MessageParams &requestParams
  ) const -> std::unique_ptr<DeclarationParams> {
    if (static_cast<MessageParamsType>(requestParams.index()) != MessageParamsType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Message parameter type must be MessageParamsType::" +
         MessageParamsTypeNames.at(MessageParamsType::OBJECT_TYPE) +
         " for method=\"textDocument/declaration\" but received type " +
         "MessageParamsType::" + MessageParamsTypeNames.at(static_cast<MessageParamsType>(requestParams.index())))
      );
    }

    const LSPObject &object = std::get<LSPObject>(requestParams);
    LSPObject::const_iterator iter;

    std::unique_ptr<DeclarationParams> declarationParams =
      std::make_unique<DeclarationParams>();

    iter = object.find("textDocument");
    if (iter != object.end()) {
      declarationParams->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DeclarationParams attribute: textDocument"
      );
    }

    iter = object.find("position");
    if (iter != object.end()) {
      declarationParams->position = anyToPosition(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DeclarationParams attribute: position"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      declarationParams->workDoneToken = anyToProgressToken(*iter->second);
    }

    iter = object.find("partialResultToken");
    if (iter != object.end()) {
      declarationParams->partialResultToken = anyToProgressToken(*iter->second);
    }

    return declarationParams;
  }

  auto LspTransformer::textDocumentDeclarationResultToAny(
    const TextDocumentDeclarationResult &result
  ) -> std::unique_ptr<LSPAny> {
    switch (static_cast<TextDocumentDeclarationResultType>(result.index())) {
    case TextDocumentDeclarationResultType::DECLARATION: {
      return declarationToAny(std::get<Declaration>(result));
    }
    case TextDocumentDeclarationResultType::DECLARATION_LINK_ARRAY: {
      LSPArray array;
      for (const std::unique_ptr<DeclarationLink> &elem
          : std::get<std::vector<std::unique_ptr<DeclarationLink>>>(result)) {
        array.push_back(declarationLinkToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      return any;
    }
    case TextDocumentDeclarationResultType::NULL_TYPE: {
      return nullToAny(std::get<null_t>(result));
    }
    case TextDocumentDeclarationResultType::LOCATION_ARRAY: {
      LSPArray array;
      for (const std::unique_ptr<Location> &elem
          : std::get<std::vector<std::unique_ptr<Location>>>(result)) {
        array.push_back(locationToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      return any;
    }
    }
    throw LSP_EXCEPTION(
      ErrorCodes::INTERNAL_ERROR,
      "Should be unreachable."
    );
  }

  auto LspTransformer::asTextDocumentSelectionRangeParams(
    const MessageParams &requestParams
  ) const -> std::unique_ptr<SelectionRangeParams> {
    if (static_cast<MessageParamsType>(requestParams.index()) != MessageParamsType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Message parameter type must be MessageParamsType::" +
         MessageParamsTypeNames.at(MessageParamsType::OBJECT_TYPE) +
         " for method=\"textDocument/selectionRange\" but received type " +
         "MessageParamsType::" + MessageParamsTypeNames.at(static_cast<MessageParamsType>(requestParams.index())))
      );
    }

    const LSPObject &object = std::get<LSPObject>(requestParams);
    LSPObject::const_iterator iter;

    std::unique_ptr<SelectionRangeParams> selectionRangeParams =
      std::make_unique<SelectionRangeParams>();

    iter = object.find("textDocument");
    if (iter != object.end()) {
      selectionRangeParams->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required SelectionRangeParams attribute: textDocument"
      );
    }

    iter = object.find("positions");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<std::unique_ptr<Position>> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToPosition(*elem));
      }
      selectionRangeParams->positions = std::move(values);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required SelectionRangeParams attribute: positions"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      selectionRangeParams->workDoneToken = anyToProgressToken(*iter->second);
    }

    iter = object.find("partialResultToken");
    if (iter != object.end()) {
      selectionRangeParams->partialResultToken = anyToProgressToken(*iter->second);
    }

    return selectionRangeParams;
  }

  auto LspTransformer::textDocumentSelectionRangeResultToAny(
    const TextDocumentSelectionRangeResult &result
  ) -> std::unique_ptr<LSPAny> {
    switch (static_cast<TextDocumentSelectionRangeResultType>(result.index())) {
    case TextDocumentSelectionRangeResultType::SELECTION_RANGE_ARRAY: {
      LSPArray array;
      for (const std::unique_ptr<SelectionRange> &elem
          : std::get<std::vector<std::unique_ptr<SelectionRange>>>(result)) {
        array.push_back(selectionRangeToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      return any;
    }
    case TextDocumentSelectionRangeResultType::NULL_TYPE: {
      return nullToAny(std::get<null_t>(result));
    }
    }
    throw LSP_EXCEPTION(
      ErrorCodes::INTERNAL_ERROR,
      "Should be unreachable."
    );
  }

  auto LspTransformer::asTextDocumentPrepareCallHierarchyParams(
    const MessageParams &requestParams
  ) const -> std::unique_ptr<CallHierarchyPrepareParams> {
    if (static_cast<MessageParamsType>(requestParams.index()) != MessageParamsType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Message parameter type must be MessageParamsType::" +
         MessageParamsTypeNames.at(MessageParamsType::OBJECT_TYPE) +
         " for method=\"textDocument/prepareCallHierarchy\" but received type " +
         "MessageParamsType::" + MessageParamsTypeNames.at(static_cast<MessageParamsType>(requestParams.index())))
      );
    }

    const LSPObject &object = std::get<LSPObject>(requestParams);
    LSPObject::const_iterator iter;

    std::unique_ptr<CallHierarchyPrepareParams> callHierarchyPrepareParams =
      std::make_unique<CallHierarchyPrepareParams>();

    iter = object.find("textDocument");
    if (iter != object.end()) {
      callHierarchyPrepareParams->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required CallHierarchyPrepareParams attribute: textDocument"
      );
    }

    iter = object.find("position");
    if (iter != object.end()) {
      callHierarchyPrepareParams->position = anyToPosition(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required CallHierarchyPrepareParams attribute: position"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      callHierarchyPrepareParams->workDoneToken = anyToProgressToken(*iter->second);
    }

    return callHierarchyPrepareParams;
  }

  auto LspTransformer::textDocumentPrepareCallHierarchyResultToAny(
    const TextDocumentPrepareCallHierarchyResult &result
  ) -> std::unique_ptr<LSPAny> {
    switch (static_cast<TextDocumentPrepareCallHierarchyResultType>(result.index())) {
    case TextDocumentPrepareCallHierarchyResultType::CALL_HIERARCHY_ITEM_ARRAY: {
      LSPArray array;
      for (const std::unique_ptr<CallHierarchyItem> &elem
          : std::get<std::vector<std::unique_ptr<CallHierarchyItem>>>(result)) {
        array.push_back(callHierarchyItemToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      return any;
    }
    case TextDocumentPrepareCallHierarchyResultType::NULL_TYPE: {
      return nullToAny(std::get<null_t>(result));
    }
    }
    throw LSP_EXCEPTION(
      ErrorCodes::INTERNAL_ERROR,
      "Should be unreachable."
    );
  }

  auto LspTransformer::asCallHierarchyIncomingCallsParams(
    const MessageParams &requestParams
  ) const -> std::unique_ptr<CallHierarchyIncomingCallsParams> {
    if (static_cast<MessageParamsType>(requestParams.index()) != MessageParamsType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Message parameter type must be MessageParamsType::" +
         MessageParamsTypeNames.at(MessageParamsType::OBJECT_TYPE) +
         " for method=\"callHierarchy/incomingCalls\" but received type " +
         "MessageParamsType::" + MessageParamsTypeNames.at(static_cast<MessageParamsType>(requestParams.index())))
      );
    }

    const LSPObject &object = std::get<LSPObject>(requestParams);
    LSPObject::const_iterator iter;

    std::unique_ptr<CallHierarchyIncomingCallsParams> callHierarchyIncomingCallsParams =
      std::make_unique<CallHierarchyIncomingCallsParams>();

    iter = object.find("item");
    if (iter != object.end()) {
      callHierarchyIncomingCallsParams->item = anyToCallHierarchyItem(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required CallHierarchyIncomingCallsParams attribute: item"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      callHierarchyIncomingCallsParams->workDoneToken = anyToProgressToken(*iter->second);
    }

    iter = object.find("partialResultToken");
    if (iter != object.end()) {
      callHierarchyIncomingCallsParams->partialResultToken = anyToProgressToken(*iter->second);
    }

    return callHierarchyIncomingCallsParams;
  }

  auto LspTransformer::callHierarchyIncomingCallsResultToAny(
    const CallHierarchyIncomingCallsResult &result
  ) -> std::unique_ptr<LSPAny> {
    switch (static_cast<CallHierarchyIncomingCallsResultType>(result.index())) {
    case CallHierarchyIncomingCallsResultType::CALL_HIERARCHY_INCOMING_CALL_ARRAY: {
      LSPArray array;
      for (const std::unique_ptr<CallHierarchyIncomingCall> &elem
          : std::get<std::vector<std::unique_ptr<CallHierarchyIncomingCall>>>(result)) {
        array.push_back(callHierarchyIncomingCallToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      return any;
    }
    case CallHierarchyIncomingCallsResultType::NULL_TYPE: {
      return nullToAny(std::get<null_t>(result));
    }
    }
    throw LSP_EXCEPTION(
      ErrorCodes::INTERNAL_ERROR,
      "Should be unreachable."
    );
  }

  auto LspTransformer::asCallHierarchyOutgoingCallsParams(
    const MessageParams &requestParams
  ) const -> std::unique_ptr<CallHierarchyOutgoingCallsParams> {
    if (static_cast<MessageParamsType>(requestParams.index()) != MessageParamsType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Message parameter type must be MessageParamsType::" +
         MessageParamsTypeNames.at(MessageParamsType::OBJECT_TYPE) +
         " for method=\"callHierarchy/outgoingCalls\" but received type " +
         "MessageParamsType::" + MessageParamsTypeNames.at(static_cast<MessageParamsType>(requestParams.index())))
      );
    }

    const LSPObject &object = std::get<LSPObject>(requestParams);
    LSPObject::const_iterator iter;

    std::unique_ptr<CallHierarchyOutgoingCallsParams> callHierarchyOutgoingCallsParams =
      std::make_unique<CallHierarchyOutgoingCallsParams>();

    iter = object.find("item");
    if (iter != object.end()) {
      callHierarchyOutgoingCallsParams->item = anyToCallHierarchyItem(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required CallHierarchyOutgoingCallsParams attribute: item"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      callHierarchyOutgoingCallsParams->workDoneToken = anyToProgressToken(*iter->second);
    }

    iter = object.find("partialResultToken");
    if (iter != object.end()) {
      callHierarchyOutgoingCallsParams->partialResultToken = anyToProgressToken(*iter->second);
    }

    return callHierarchyOutgoingCallsParams;
  }

  auto LspTransformer::callHierarchyOutgoingCallsResultToAny(
    const CallHierarchyOutgoingCallsResult &result
  ) -> std::unique_ptr<LSPAny> {
    switch (static_cast<CallHierarchyOutgoingCallsResultType>(result.index())) {
    case CallHierarchyOutgoingCallsResultType::CALL_HIERARCHY_OUTGOING_CALL_ARRAY: {
      LSPArray array;
      for (const std::unique_ptr<CallHierarchyOutgoingCall> &elem
          : std::get<std::vector<std::unique_ptr<CallHierarchyOutgoingCall>>>(result)) {
        array.push_back(callHierarchyOutgoingCallToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      return any;
    }
    case CallHierarchyOutgoingCallsResultType::NULL_TYPE: {
      return nullToAny(std::get<null_t>(result));
    }
    }
    throw LSP_EXCEPTION(
      ErrorCodes::INTERNAL_ERROR,
      "Should be unreachable."
    );
  }

  auto LspTransformer::asTextDocumentSemanticTokensFullParams(
    const MessageParams &requestParams
  ) const -> std::unique_ptr<SemanticTokensParams> {
    if (static_cast<MessageParamsType>(requestParams.index()) != MessageParamsType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Message parameter type must be MessageParamsType::" +
         MessageParamsTypeNames.at(MessageParamsType::OBJECT_TYPE) +
         " for method=\"textDocument/semanticTokens/full\" but received type " +
         "MessageParamsType::" + MessageParamsTypeNames.at(static_cast<MessageParamsType>(requestParams.index())))
      );
    }

    const LSPObject &object = std::get<LSPObject>(requestParams);
    LSPObject::const_iterator iter;

    std::unique_ptr<SemanticTokensParams> semanticTokensParams =
      std::make_unique<SemanticTokensParams>();

    iter = object.find("textDocument");
    if (iter != object.end()) {
      semanticTokensParams->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required SemanticTokensParams attribute: textDocument"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      semanticTokensParams->workDoneToken = anyToProgressToken(*iter->second);
    }

    iter = object.find("partialResultToken");
    if (iter != object.end()) {
      semanticTokensParams->partialResultToken = anyToProgressToken(*iter->second);
    }

    return semanticTokensParams;
  }

  auto LspTransformer::textDocumentSemanticTokensFullResultToAny(
    const TextDocumentSemanticTokensFullResult &result
  ) -> std::unique_ptr<LSPAny> {
    switch (static_cast<TextDocumentSemanticTokensFullResultType>(result.index())) {
    case TextDocumentSemanticTokensFullResultType::SEMANTIC_TOKENS: {
      return semanticTokensToAny(*std::get<std::unique_ptr<SemanticTokens>>(result));
    }
    case TextDocumentSemanticTokensFullResultType::NULL_TYPE: {
      return nullToAny(std::get<null_t>(result));
    }
    case TextDocumentSemanticTokensFullResultType::SEMANTIC_TOKENS_PARTIAL_RESULT: {
      return semanticTokensPartialResultToAny(*std::get<std::unique_ptr<SemanticTokensPartialResult>>(result));
    }
    }
    throw LSP_EXCEPTION(
      ErrorCodes::INTERNAL_ERROR,
      "Should be unreachable."
    );
  }

  auto LspTransformer::asTextDocumentSemanticTokensFullDeltaParams(
    const MessageParams &requestParams
  ) const -> std::unique_ptr<SemanticTokensDeltaParams> {
    if (static_cast<MessageParamsType>(requestParams.index()) != MessageParamsType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Message parameter type must be MessageParamsType::" +
         MessageParamsTypeNames.at(MessageParamsType::OBJECT_TYPE) +
         " for method=\"textDocument/semanticTokens/full/delta\" but received type " +
         "MessageParamsType::" + MessageParamsTypeNames.at(static_cast<MessageParamsType>(requestParams.index())))
      );
    }

    const LSPObject &object = std::get<LSPObject>(requestParams);
    LSPObject::const_iterator iter;

    std::unique_ptr<SemanticTokensDeltaParams> semanticTokensDeltaParams =
      std::make_unique<SemanticTokensDeltaParams>();

    iter = object.find("textDocument");
    if (iter != object.end()) {
      semanticTokensDeltaParams->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required SemanticTokensDeltaParams attribute: textDocument"
      );
    }

    iter = object.find("previousResultId");
    if (iter != object.end()) {
      semanticTokensDeltaParams->previousResultId = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required SemanticTokensDeltaParams attribute: previousResultId"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      semanticTokensDeltaParams->workDoneToken = anyToProgressToken(*iter->second);
    }

    iter = object.find("partialResultToken");
    if (iter != object.end()) {
      semanticTokensDeltaParams->partialResultToken = anyToProgressToken(*iter->second);
    }

    return semanticTokensDeltaParams;
  }

  auto LspTransformer::textDocumentSemanticTokensFullDeltaResultToAny(
    const TextDocumentSemanticTokensFullDeltaResult &result
  ) -> std::unique_ptr<LSPAny> {
    switch (static_cast<TextDocumentSemanticTokensFullDeltaResultType>(result.index())) {
    case TextDocumentSemanticTokensFullDeltaResultType::SEMANTIC_TOKENS: {
      return semanticTokensToAny(*std::get<std::unique_ptr<SemanticTokens>>(result));
    }
    case TextDocumentSemanticTokensFullDeltaResultType::SEMANTIC_TOKENS_DELTA: {
      return semanticTokensDeltaToAny(*std::get<std::unique_ptr<SemanticTokensDelta>>(result));
    }
    case TextDocumentSemanticTokensFullDeltaResultType::NULL_TYPE: {
      return nullToAny(std::get<null_t>(result));
    }
    case TextDocumentSemanticTokensFullDeltaResultType::SEMANTIC_TOKENS_PARTIAL_RESULT: {
      return semanticTokensPartialResultToAny(*std::get<std::unique_ptr<SemanticTokensPartialResult>>(result));
    }
    case TextDocumentSemanticTokensFullDeltaResultType::SEMANTIC_TOKENS_DELTA_PARTIAL_RESULT: {
      return semanticTokensDeltaPartialResultToAny(*std::get<std::unique_ptr<SemanticTokensDeltaPartialResult>>(result));
    }
    }
    throw LSP_EXCEPTION(
      ErrorCodes::INTERNAL_ERROR,
      "Should be unreachable."
    );
  }

  auto LspTransformer::asTextDocumentSemanticTokensRangeParams(
    const MessageParams &requestParams
  ) const -> std::unique_ptr<SemanticTokensRangeParams> {
    if (static_cast<MessageParamsType>(requestParams.index()) != MessageParamsType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Message parameter type must be MessageParamsType::" +
         MessageParamsTypeNames.at(MessageParamsType::OBJECT_TYPE) +
         " for method=\"textDocument/semanticTokens/range\" but received type " +
         "MessageParamsType::" + MessageParamsTypeNames.at(static_cast<MessageParamsType>(requestParams.index())))
      );
    }

    const LSPObject &object = std::get<LSPObject>(requestParams);
    LSPObject::const_iterator iter;

    std::unique_ptr<SemanticTokensRangeParams> semanticTokensRangeParams =
      std::make_unique<SemanticTokensRangeParams>();

    iter = object.find("textDocument");
    if (iter != object.end()) {
      semanticTokensRangeParams->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required SemanticTokensRangeParams attribute: textDocument"
      );
    }

    iter = object.find("range");
    if (iter != object.end()) {
      semanticTokensRangeParams->range = anyToRange(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required SemanticTokensRangeParams attribute: range"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      semanticTokensRangeParams->workDoneToken = anyToProgressToken(*iter->second);
    }

    iter = object.find("partialResultToken");
    if (iter != object.end()) {
      semanticTokensRangeParams->partialResultToken = anyToProgressToken(*iter->second);
    }

    return semanticTokensRangeParams;
  }

  auto LspTransformer::textDocumentSemanticTokensRangeResultToAny(
    const TextDocumentSemanticTokensRangeResult &result
  ) -> std::unique_ptr<LSPAny> {
    switch (static_cast<TextDocumentSemanticTokensRangeResultType>(result.index())) {
    case TextDocumentSemanticTokensRangeResultType::SEMANTIC_TOKENS: {
      return semanticTokensToAny(*std::get<std::unique_ptr<SemanticTokens>>(result));
    }
    case TextDocumentSemanticTokensRangeResultType::NULL_TYPE: {
      return nullToAny(std::get<null_t>(result));
    }
    case TextDocumentSemanticTokensRangeResultType::SEMANTIC_TOKENS_PARTIAL_RESULT: {
      return semanticTokensPartialResultToAny(*std::get<std::unique_ptr<SemanticTokensPartialResult>>(result));
    }
    }
    throw LSP_EXCEPTION(
      ErrorCodes::INTERNAL_ERROR,
      "Should be unreachable."
    );
  }

  auto LspTransformer::asTextDocumentLinkedEditingRangeParams(
    const MessageParams &requestParams
  ) const -> std::unique_ptr<LinkedEditingRangeParams> {
    if (static_cast<MessageParamsType>(requestParams.index()) != MessageParamsType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Message parameter type must be MessageParamsType::" +
         MessageParamsTypeNames.at(MessageParamsType::OBJECT_TYPE) +
         " for method=\"textDocument/linkedEditingRange\" but received type " +
         "MessageParamsType::" + MessageParamsTypeNames.at(static_cast<MessageParamsType>(requestParams.index())))
      );
    }

    const LSPObject &object = std::get<LSPObject>(requestParams);
    LSPObject::const_iterator iter;

    std::unique_ptr<LinkedEditingRangeParams> linkedEditingRangeParams =
      std::make_unique<LinkedEditingRangeParams>();

    iter = object.find("textDocument");
    if (iter != object.end()) {
      linkedEditingRangeParams->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required LinkedEditingRangeParams attribute: textDocument"
      );
    }

    iter = object.find("position");
    if (iter != object.end()) {
      linkedEditingRangeParams->position = anyToPosition(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required LinkedEditingRangeParams attribute: position"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      linkedEditingRangeParams->workDoneToken = anyToProgressToken(*iter->second);
    }

    return linkedEditingRangeParams;
  }

  auto LspTransformer::textDocumentLinkedEditingRangeResultToAny(
    const TextDocumentLinkedEditingRangeResult &result
  ) -> std::unique_ptr<LSPAny> {
    switch (static_cast<TextDocumentLinkedEditingRangeResultType>(result.index())) {
    case TextDocumentLinkedEditingRangeResultType::LINKED_EDITING_RANGES: {
      return linkedEditingRangesToAny(*std::get<std::unique_ptr<LinkedEditingRanges>>(result));
    }
    case TextDocumentLinkedEditingRangeResultType::NULL_TYPE: {
      return nullToAny(std::get<null_t>(result));
    }
    }
    throw LSP_EXCEPTION(
      ErrorCodes::INTERNAL_ERROR,
      "Should be unreachable."
    );
  }

  auto LspTransformer::asWorkspaceWillCreateFilesParams(
    const MessageParams &requestParams
  ) const -> std::unique_ptr<CreateFilesParams> {
    if (static_cast<MessageParamsType>(requestParams.index()) != MessageParamsType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Message parameter type must be MessageParamsType::" +
         MessageParamsTypeNames.at(MessageParamsType::OBJECT_TYPE) +
         " for method=\"workspace/willCreateFiles\" but received type " +
         "MessageParamsType::" + MessageParamsTypeNames.at(static_cast<MessageParamsType>(requestParams.index())))
      );
    }

    const LSPObject &object = std::get<LSPObject>(requestParams);
    LSPObject::const_iterator iter;

    std::unique_ptr<CreateFilesParams> createFilesParams =
      std::make_unique<CreateFilesParams>();

    iter = object.find("files");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<std::unique_ptr<FileCreate>> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToFileCreate(*elem));
      }
      createFilesParams->files = std::move(values);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required CreateFilesParams attribute: files"
      );
    }

    return createFilesParams;
  }

  auto LspTransformer::workspaceWillCreateFilesResultToAny(
    const WorkspaceWillCreateFilesResult &result
  ) -> std::unique_ptr<LSPAny> {
    switch (static_cast<WorkspaceWillCreateFilesResultType>(result.index())) {
    case WorkspaceWillCreateFilesResultType::WORKSPACE_EDIT: {
      return workspaceEditToAny(*std::get<std::unique_ptr<WorkspaceEdit>>(result));
    }
    case WorkspaceWillCreateFilesResultType::NULL_TYPE: {
      return nullToAny(std::get<null_t>(result));
    }
    }
    throw LSP_EXCEPTION(
      ErrorCodes::INTERNAL_ERROR,
      "Should be unreachable."
    );
  }

  auto LspTransformer::asWorkspaceWillRenameFilesParams(
    const MessageParams &requestParams
  ) const -> std::unique_ptr<RenameFilesParams> {
    if (static_cast<MessageParamsType>(requestParams.index()) != MessageParamsType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Message parameter type must be MessageParamsType::" +
         MessageParamsTypeNames.at(MessageParamsType::OBJECT_TYPE) +
         " for method=\"workspace/willRenameFiles\" but received type " +
         "MessageParamsType::" + MessageParamsTypeNames.at(static_cast<MessageParamsType>(requestParams.index())))
      );
    }

    const LSPObject &object = std::get<LSPObject>(requestParams);
    LSPObject::const_iterator iter;

    std::unique_ptr<RenameFilesParams> renameFilesParams =
      std::make_unique<RenameFilesParams>();

    iter = object.find("files");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<std::unique_ptr<FileRename>> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToFileRename(*elem));
      }
      renameFilesParams->files = std::move(values);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required RenameFilesParams attribute: files"
      );
    }

    return renameFilesParams;
  }

  auto LspTransformer::workspaceWillRenameFilesResultToAny(
    const WorkspaceWillRenameFilesResult &result
  ) -> std::unique_ptr<LSPAny> {
    switch (static_cast<WorkspaceWillRenameFilesResultType>(result.index())) {
    case WorkspaceWillRenameFilesResultType::WORKSPACE_EDIT: {
      return workspaceEditToAny(*std::get<std::unique_ptr<WorkspaceEdit>>(result));
    }
    case WorkspaceWillRenameFilesResultType::NULL_TYPE: {
      return nullToAny(std::get<null_t>(result));
    }
    }
    throw LSP_EXCEPTION(
      ErrorCodes::INTERNAL_ERROR,
      "Should be unreachable."
    );
  }

  auto LspTransformer::asWorkspaceWillDeleteFilesParams(
    const MessageParams &requestParams
  ) const -> std::unique_ptr<DeleteFilesParams> {
    if (static_cast<MessageParamsType>(requestParams.index()) != MessageParamsType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Message parameter type must be MessageParamsType::" +
         MessageParamsTypeNames.at(MessageParamsType::OBJECT_TYPE) +
         " for method=\"workspace/willDeleteFiles\" but received type " +
         "MessageParamsType::" + MessageParamsTypeNames.at(static_cast<MessageParamsType>(requestParams.index())))
      );
    }

    const LSPObject &object = std::get<LSPObject>(requestParams);
    LSPObject::const_iterator iter;

    std::unique_ptr<DeleteFilesParams> deleteFilesParams =
      std::make_unique<DeleteFilesParams>();

    iter = object.find("files");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<std::unique_ptr<FileDelete>> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToFileDelete(*elem));
      }
      deleteFilesParams->files = std::move(values);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DeleteFilesParams attribute: files"
      );
    }

    return deleteFilesParams;
  }

  auto LspTransformer::workspaceWillDeleteFilesResultToAny(
    const WorkspaceWillDeleteFilesResult &result
  ) -> std::unique_ptr<LSPAny> {
    switch (static_cast<WorkspaceWillDeleteFilesResultType>(result.index())) {
    case WorkspaceWillDeleteFilesResultType::WORKSPACE_EDIT: {
      return workspaceEditToAny(*std::get<std::unique_ptr<WorkspaceEdit>>(result));
    }
    case WorkspaceWillDeleteFilesResultType::NULL_TYPE: {
      return nullToAny(std::get<null_t>(result));
    }
    }
    throw LSP_EXCEPTION(
      ErrorCodes::INTERNAL_ERROR,
      "Should be unreachable."
    );
  }

  auto LspTransformer::asTextDocumentMonikerParams(
    const MessageParams &requestParams
  ) const -> std::unique_ptr<MonikerParams> {
    if (static_cast<MessageParamsType>(requestParams.index()) != MessageParamsType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Message parameter type must be MessageParamsType::" +
         MessageParamsTypeNames.at(MessageParamsType::OBJECT_TYPE) +
         " for method=\"textDocument/moniker\" but received type " +
         "MessageParamsType::" + MessageParamsTypeNames.at(static_cast<MessageParamsType>(requestParams.index())))
      );
    }

    const LSPObject &object = std::get<LSPObject>(requestParams);
    LSPObject::const_iterator iter;

    std::unique_ptr<MonikerParams> monikerParams =
      std::make_unique<MonikerParams>();

    iter = object.find("textDocument");
    if (iter != object.end()) {
      monikerParams->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required MonikerParams attribute: textDocument"
      );
    }

    iter = object.find("position");
    if (iter != object.end()) {
      monikerParams->position = anyToPosition(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required MonikerParams attribute: position"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      monikerParams->workDoneToken = anyToProgressToken(*iter->second);
    }

    iter = object.find("partialResultToken");
    if (iter != object.end()) {
      monikerParams->partialResultToken = anyToProgressToken(*iter->second);
    }

    return monikerParams;
  }

  auto LspTransformer::textDocumentMonikerResultToAny(
    const TextDocumentMonikerResult &result
  ) -> std::unique_ptr<LSPAny> {
    switch (static_cast<TextDocumentMonikerResultType>(result.index())) {
    case TextDocumentMonikerResultType::MONIKER_ARRAY: {
      LSPArray array;
      for (const std::unique_ptr<Moniker> &elem
          : std::get<std::vector<std::unique_ptr<Moniker>>>(result)) {
        array.push_back(monikerToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      return any;
    }
    case TextDocumentMonikerResultType::NULL_TYPE: {
      return nullToAny(std::get<null_t>(result));
    }
    }
    throw LSP_EXCEPTION(
      ErrorCodes::INTERNAL_ERROR,
      "Should be unreachable."
    );
  }

  auto LspTransformer::asTextDocumentPrepareTypeHierarchyParams(
    const MessageParams &requestParams
  ) const -> std::unique_ptr<TypeHierarchyPrepareParams> {
    if (static_cast<MessageParamsType>(requestParams.index()) != MessageParamsType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Message parameter type must be MessageParamsType::" +
         MessageParamsTypeNames.at(MessageParamsType::OBJECT_TYPE) +
         " for method=\"textDocument/prepareTypeHierarchy\" but received type " +
         "MessageParamsType::" + MessageParamsTypeNames.at(static_cast<MessageParamsType>(requestParams.index())))
      );
    }

    const LSPObject &object = std::get<LSPObject>(requestParams);
    LSPObject::const_iterator iter;

    std::unique_ptr<TypeHierarchyPrepareParams> typeHierarchyPrepareParams =
      std::make_unique<TypeHierarchyPrepareParams>();

    iter = object.find("textDocument");
    if (iter != object.end()) {
      typeHierarchyPrepareParams->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required TypeHierarchyPrepareParams attribute: textDocument"
      );
    }

    iter = object.find("position");
    if (iter != object.end()) {
      typeHierarchyPrepareParams->position = anyToPosition(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required TypeHierarchyPrepareParams attribute: position"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      typeHierarchyPrepareParams->workDoneToken = anyToProgressToken(*iter->second);
    }

    return typeHierarchyPrepareParams;
  }

  auto LspTransformer::textDocumentPrepareTypeHierarchyResultToAny(
    const TextDocumentPrepareTypeHierarchyResult &result
  ) -> std::unique_ptr<LSPAny> {
    switch (static_cast<TextDocumentPrepareTypeHierarchyResultType>(result.index())) {
    case TextDocumentPrepareTypeHierarchyResultType::TYPE_HIERARCHY_ITEM_ARRAY: {
      LSPArray array;
      for (const std::unique_ptr<TypeHierarchyItem> &elem
          : std::get<std::vector<std::unique_ptr<TypeHierarchyItem>>>(result)) {
        array.push_back(typeHierarchyItemToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      return any;
    }
    case TextDocumentPrepareTypeHierarchyResultType::NULL_TYPE: {
      return nullToAny(std::get<null_t>(result));
    }
    }
    throw LSP_EXCEPTION(
      ErrorCodes::INTERNAL_ERROR,
      "Should be unreachable."
    );
  }

  auto LspTransformer::asTypeHierarchySupertypesParams(
    const MessageParams &requestParams
  ) const -> std::unique_ptr<TypeHierarchySupertypesParams> {
    if (static_cast<MessageParamsType>(requestParams.index()) != MessageParamsType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Message parameter type must be MessageParamsType::" +
         MessageParamsTypeNames.at(MessageParamsType::OBJECT_TYPE) +
         " for method=\"typeHierarchy/supertypes\" but received type " +
         "MessageParamsType::" + MessageParamsTypeNames.at(static_cast<MessageParamsType>(requestParams.index())))
      );
    }

    const LSPObject &object = std::get<LSPObject>(requestParams);
    LSPObject::const_iterator iter;

    std::unique_ptr<TypeHierarchySupertypesParams> typeHierarchySupertypesParams =
      std::make_unique<TypeHierarchySupertypesParams>();

    iter = object.find("item");
    if (iter != object.end()) {
      typeHierarchySupertypesParams->item = anyToTypeHierarchyItem(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required TypeHierarchySupertypesParams attribute: item"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      typeHierarchySupertypesParams->workDoneToken = anyToProgressToken(*iter->second);
    }

    iter = object.find("partialResultToken");
    if (iter != object.end()) {
      typeHierarchySupertypesParams->partialResultToken = anyToProgressToken(*iter->second);
    }

    return typeHierarchySupertypesParams;
  }

  auto LspTransformer::typeHierarchySupertypesResultToAny(
    const TypeHierarchySupertypesResult &result
  ) -> std::unique_ptr<LSPAny> {
    switch (static_cast<TypeHierarchySupertypesResultType>(result.index())) {
    case TypeHierarchySupertypesResultType::TYPE_HIERARCHY_ITEM_ARRAY: {
      LSPArray array;
      for (const std::unique_ptr<TypeHierarchyItem> &elem
          : std::get<std::vector<std::unique_ptr<TypeHierarchyItem>>>(result)) {
        array.push_back(typeHierarchyItemToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      return any;
    }
    case TypeHierarchySupertypesResultType::NULL_TYPE: {
      return nullToAny(std::get<null_t>(result));
    }
    }
    throw LSP_EXCEPTION(
      ErrorCodes::INTERNAL_ERROR,
      "Should be unreachable."
    );
  }

  auto LspTransformer::asTypeHierarchySubtypesParams(
    const MessageParams &requestParams
  ) const -> std::unique_ptr<TypeHierarchySubtypesParams> {
    if (static_cast<MessageParamsType>(requestParams.index()) != MessageParamsType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Message parameter type must be MessageParamsType::" +
         MessageParamsTypeNames.at(MessageParamsType::OBJECT_TYPE) +
         " for method=\"typeHierarchy/subtypes\" but received type " +
         "MessageParamsType::" + MessageParamsTypeNames.at(static_cast<MessageParamsType>(requestParams.index())))
      );
    }

    const LSPObject &object = std::get<LSPObject>(requestParams);
    LSPObject::const_iterator iter;

    std::unique_ptr<TypeHierarchySubtypesParams> typeHierarchySubtypesParams =
      std::make_unique<TypeHierarchySubtypesParams>();

    iter = object.find("item");
    if (iter != object.end()) {
      typeHierarchySubtypesParams->item = anyToTypeHierarchyItem(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required TypeHierarchySubtypesParams attribute: item"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      typeHierarchySubtypesParams->workDoneToken = anyToProgressToken(*iter->second);
    }

    iter = object.find("partialResultToken");
    if (iter != object.end()) {
      typeHierarchySubtypesParams->partialResultToken = anyToProgressToken(*iter->second);
    }

    return typeHierarchySubtypesParams;
  }

  auto LspTransformer::typeHierarchySubtypesResultToAny(
    const TypeHierarchySubtypesResult &result
  ) -> std::unique_ptr<LSPAny> {
    switch (static_cast<TypeHierarchySubtypesResultType>(result.index())) {
    case TypeHierarchySubtypesResultType::TYPE_HIERARCHY_ITEM_ARRAY: {
      LSPArray array;
      for (const std::unique_ptr<TypeHierarchyItem> &elem
          : std::get<std::vector<std::unique_ptr<TypeHierarchyItem>>>(result)) {
        array.push_back(typeHierarchyItemToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      return any;
    }
    case TypeHierarchySubtypesResultType::NULL_TYPE: {
      return nullToAny(std::get<null_t>(result));
    }
    }
    throw LSP_EXCEPTION(
      ErrorCodes::INTERNAL_ERROR,
      "Should be unreachable."
    );
  }

  auto LspTransformer::asTextDocumentInlineValueParams(
    const MessageParams &requestParams
  ) const -> std::unique_ptr<InlineValueParams> {
    if (static_cast<MessageParamsType>(requestParams.index()) != MessageParamsType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Message parameter type must be MessageParamsType::" +
         MessageParamsTypeNames.at(MessageParamsType::OBJECT_TYPE) +
         " for method=\"textDocument/inlineValue\" but received type " +
         "MessageParamsType::" + MessageParamsTypeNames.at(static_cast<MessageParamsType>(requestParams.index())))
      );
    }

    const LSPObject &object = std::get<LSPObject>(requestParams);
    LSPObject::const_iterator iter;

    std::unique_ptr<InlineValueParams> inlineValueParams =
      std::make_unique<InlineValueParams>();

    iter = object.find("textDocument");
    if (iter != object.end()) {
      inlineValueParams->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required InlineValueParams attribute: textDocument"
      );
    }

    iter = object.find("range");
    if (iter != object.end()) {
      inlineValueParams->range = anyToRange(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required InlineValueParams attribute: range"
      );
    }

    iter = object.find("context");
    if (iter != object.end()) {
      inlineValueParams->context = anyToInlineValueContext(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required InlineValueParams attribute: context"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      inlineValueParams->workDoneToken = anyToProgressToken(*iter->second);
    }

    return inlineValueParams;
  }

  auto LspTransformer::textDocumentInlineValueResultToAny(
    const TextDocumentInlineValueResult &result
  ) -> std::unique_ptr<LSPAny> {
    switch (static_cast<TextDocumentInlineValueResultType>(result.index())) {
    case TextDocumentInlineValueResultType::INLINE_VALUE_ARRAY: {
      LSPArray array;
      for (const InlineValue &elem
          : std::get<std::vector<InlineValue>>(result)) {
        array.push_back(inlineValueToAny(elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      return any;
    }
    case TextDocumentInlineValueResultType::NULL_TYPE: {
      return nullToAny(std::get<null_t>(result));
    }
    }
    throw LSP_EXCEPTION(
      ErrorCodes::INTERNAL_ERROR,
      "Should be unreachable."
    );
  }

  auto LspTransformer::asTextDocumentInlayHintParams(
    const MessageParams &requestParams
  ) const -> std::unique_ptr<InlayHintParams> {
    if (static_cast<MessageParamsType>(requestParams.index()) != MessageParamsType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Message parameter type must be MessageParamsType::" +
         MessageParamsTypeNames.at(MessageParamsType::OBJECT_TYPE) +
         " for method=\"textDocument/inlayHint\" but received type " +
         "MessageParamsType::" + MessageParamsTypeNames.at(static_cast<MessageParamsType>(requestParams.index())))
      );
    }

    const LSPObject &object = std::get<LSPObject>(requestParams);
    LSPObject::const_iterator iter;

    std::unique_ptr<InlayHintParams> inlayHintParams =
      std::make_unique<InlayHintParams>();

    iter = object.find("textDocument");
    if (iter != object.end()) {
      inlayHintParams->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required InlayHintParams attribute: textDocument"
      );
    }

    iter = object.find("range");
    if (iter != object.end()) {
      inlayHintParams->range = anyToRange(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required InlayHintParams attribute: range"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      inlayHintParams->workDoneToken = anyToProgressToken(*iter->second);
    }

    return inlayHintParams;
  }

  auto LspTransformer::textDocumentInlayHintResultToAny(
    const TextDocumentInlayHintResult &result
  ) -> std::unique_ptr<LSPAny> {
    switch (static_cast<TextDocumentInlayHintResultType>(result.index())) {
    case TextDocumentInlayHintResultType::INLAY_HINT_ARRAY: {
      LSPArray array;
      for (const std::unique_ptr<InlayHint> &elem
          : std::get<std::vector<std::unique_ptr<InlayHint>>>(result)) {
        array.push_back(inlayHintToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      return any;
    }
    case TextDocumentInlayHintResultType::NULL_TYPE: {
      return nullToAny(std::get<null_t>(result));
    }
    }
    throw LSP_EXCEPTION(
      ErrorCodes::INTERNAL_ERROR,
      "Should be unreachable."
    );
  }

  auto LspTransformer::asInlayHintResolveParams(
    const MessageParams &requestParams
  ) const -> std::unique_ptr<InlayHint> {
    if (static_cast<MessageParamsType>(requestParams.index()) != MessageParamsType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Message parameter type must be MessageParamsType::" +
         MessageParamsTypeNames.at(MessageParamsType::OBJECT_TYPE) +
         " for method=\"inlayHint/resolve\" but received type " +
         "MessageParamsType::" + MessageParamsTypeNames.at(static_cast<MessageParamsType>(requestParams.index())))
      );
    }

    const LSPObject &object = std::get<LSPObject>(requestParams);
    LSPObject::const_iterator iter;

    std::unique_ptr<InlayHint> inlayHint =
      std::make_unique<InlayHint>();

    iter = object.find("position");
    if (iter != object.end()) {
      inlayHint->position = anyToPosition(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required InlayHint attribute: position"
      );
    }

    iter = object.find("label");
    if (iter != object.end()) {
      inlayHint->label = anyToInlayHint_label(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required InlayHint attribute: label"
      );
    }

    iter = object.find("kind");
    if (iter != object.end()) {
      inlayHint->kind = anyToInlayHintKind(*iter->second);
    }

    iter = object.find("textEdits");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<std::unique_ptr<TextEdit>> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToTextEdit(*elem));
      }
      inlayHint->textEdits = std::move(values);
    }

    iter = object.find("tooltip");
    if (iter != object.end()) {
      inlayHint->tooltip = anyToInlayHint_tooltip(*iter->second);
    }

    iter = object.find("paddingLeft");
    if (iter != object.end()) {
      inlayHint->paddingLeft = anyToBoolean(*iter->second);
    }

    iter = object.find("paddingRight");
    if (iter != object.end()) {
      inlayHint->paddingRight = anyToBoolean(*iter->second);
    }

    iter = object.find("data");
    if (iter != object.end()) {
      inlayHint->data = copy(iter->second);
    }

    return inlayHint;
  }

  auto LspTransformer::inlayHintResolveResultToAny(
    const InlayHintResolveResult &result
  ) -> std::unique_ptr<LSPAny> {
    return inlayHintToAny(result);
  }

  auto LspTransformer::asTextDocumentDiagnosticParams(
    const MessageParams &requestParams
  ) const -> std::unique_ptr<DocumentDiagnosticParams> {
    if (static_cast<MessageParamsType>(requestParams.index()) != MessageParamsType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Message parameter type must be MessageParamsType::" +
         MessageParamsTypeNames.at(MessageParamsType::OBJECT_TYPE) +
         " for method=\"textDocument/diagnostic\" but received type " +
         "MessageParamsType::" + MessageParamsTypeNames.at(static_cast<MessageParamsType>(requestParams.index())))
      );
    }

    const LSPObject &object = std::get<LSPObject>(requestParams);
    LSPObject::const_iterator iter;

    std::unique_ptr<DocumentDiagnosticParams> documentDiagnosticParams =
      std::make_unique<DocumentDiagnosticParams>();

    iter = object.find("textDocument");
    if (iter != object.end()) {
      documentDiagnosticParams->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DocumentDiagnosticParams attribute: textDocument"
      );
    }

    iter = object.find("identifier");
    if (iter != object.end()) {
      documentDiagnosticParams->identifier = anyToString(*iter->second);
    }

    iter = object.find("previousResultId");
    if (iter != object.end()) {
      documentDiagnosticParams->previousResultId = anyToString(*iter->second);
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      documentDiagnosticParams->workDoneToken = anyToProgressToken(*iter->second);
    }

    iter = object.find("partialResultToken");
    if (iter != object.end()) {
      documentDiagnosticParams->partialResultToken = anyToProgressToken(*iter->second);
    }

    return documentDiagnosticParams;
  }

  auto LspTransformer::textDocumentDiagnosticResultToAny(
    const TextDocumentDiagnosticResult &result
  ) -> std::unique_ptr<LSPAny> {
    switch (static_cast<TextDocumentDiagnosticResultType>(result.index())) {
    case TextDocumentDiagnosticResultType::DOCUMENT_DIAGNOSTIC_REPORT: {
      return documentDiagnosticReportToAny(std::get<DocumentDiagnosticReport>(result));
    }
    case TextDocumentDiagnosticResultType::DOCUMENT_DIAGNOSTIC_REPORT_PARTIAL_RESULT: {
      return documentDiagnosticReportPartialResultToAny(*std::get<std::unique_ptr<DocumentDiagnosticReportPartialResult>>(result));
    }
    }
    throw LSP_EXCEPTION(
      ErrorCodes::INTERNAL_ERROR,
      "Should be unreachable."
    );
  }

  auto LspTransformer::asWorkspaceDiagnosticParams(
    const MessageParams &requestParams
  ) const -> std::unique_ptr<WorkspaceDiagnosticParams> {
    if (static_cast<MessageParamsType>(requestParams.index()) != MessageParamsType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Message parameter type must be MessageParamsType::" +
         MessageParamsTypeNames.at(MessageParamsType::OBJECT_TYPE) +
         " for method=\"workspace/diagnostic\" but received type " +
         "MessageParamsType::" + MessageParamsTypeNames.at(static_cast<MessageParamsType>(requestParams.index())))
      );
    }

    const LSPObject &object = std::get<LSPObject>(requestParams);
    LSPObject::const_iterator iter;

    std::unique_ptr<WorkspaceDiagnosticParams> workspaceDiagnosticParams =
      std::make_unique<WorkspaceDiagnosticParams>();

    iter = object.find("identifier");
    if (iter != object.end()) {
      workspaceDiagnosticParams->identifier = anyToString(*iter->second);
    }

    iter = object.find("previousResultIds");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<std::unique_ptr<PreviousResultId>> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToPreviousResultId(*elem));
      }
      workspaceDiagnosticParams->previousResultIds = std::move(values);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required WorkspaceDiagnosticParams attribute: previousResultIds"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      workspaceDiagnosticParams->workDoneToken = anyToProgressToken(*iter->second);
    }

    iter = object.find("partialResultToken");
    if (iter != object.end()) {
      workspaceDiagnosticParams->partialResultToken = anyToProgressToken(*iter->second);
    }

    return workspaceDiagnosticParams;
  }

  auto LspTransformer::workspaceDiagnosticResultToAny(
    const WorkspaceDiagnosticResult &result
  ) -> std::unique_ptr<LSPAny> {
    switch (static_cast<WorkspaceDiagnosticResultType>(result.index())) {
    case WorkspaceDiagnosticResultType::WORKSPACE_DIAGNOSTIC_REPORT: {
      return workspaceDiagnosticReportToAny(*std::get<std::unique_ptr<WorkspaceDiagnosticReport>>(result));
    }
    case WorkspaceDiagnosticResultType::WORKSPACE_DIAGNOSTIC_REPORT_PARTIAL_RESULT: {
      return workspaceDiagnosticReportPartialResultToAny(*std::get<std::unique_ptr<WorkspaceDiagnosticReportPartialResult>>(result));
    }
    }
    throw LSP_EXCEPTION(
      ErrorCodes::INTERNAL_ERROR,
      "Should be unreachable."
    );
  }

  auto LspTransformer::asTextDocumentInlineCompletionParams(
    const MessageParams &requestParams
  ) const -> std::unique_ptr<InlineCompletionParams> {
    if (static_cast<MessageParamsType>(requestParams.index()) != MessageParamsType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Message parameter type must be MessageParamsType::" +
         MessageParamsTypeNames.at(MessageParamsType::OBJECT_TYPE) +
         " for method=\"textDocument/inlineCompletion\" but received type " +
         "MessageParamsType::" + MessageParamsTypeNames.at(static_cast<MessageParamsType>(requestParams.index())))
      );
    }

    const LSPObject &object = std::get<LSPObject>(requestParams);
    LSPObject::const_iterator iter;

    std::unique_ptr<InlineCompletionParams> inlineCompletionParams =
      std::make_unique<InlineCompletionParams>();

    iter = object.find("context");
    if (iter != object.end()) {
      inlineCompletionParams->context = anyToInlineCompletionContext(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required InlineCompletionParams attribute: context"
      );
    }

    iter = object.find("textDocument");
    if (iter != object.end()) {
      inlineCompletionParams->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required InlineCompletionParams attribute: textDocument"
      );
    }

    iter = object.find("position");
    if (iter != object.end()) {
      inlineCompletionParams->position = anyToPosition(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required InlineCompletionParams attribute: position"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      inlineCompletionParams->workDoneToken = anyToProgressToken(*iter->second);
    }

    return inlineCompletionParams;
  }

  auto LspTransformer::textDocumentInlineCompletionResultToAny(
    const TextDocumentInlineCompletionResult &result
  ) -> std::unique_ptr<LSPAny> {
    switch (static_cast<TextDocumentInlineCompletionResultType>(result.index())) {
    case TextDocumentInlineCompletionResultType::INLINE_COMPLETION_LIST: {
      return inlineCompletionListToAny(*std::get<std::unique_ptr<InlineCompletionList>>(result));
    }
    case TextDocumentInlineCompletionResultType::INLINE_COMPLETION_ITEM_ARRAY: {
      LSPArray array;
      for (const std::unique_ptr<InlineCompletionItem> &elem
          : std::get<std::vector<std::unique_ptr<InlineCompletionItem>>>(result)) {
        array.push_back(inlineCompletionItemToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      return any;
    }
    case TextDocumentInlineCompletionResultType::NULL_TYPE: {
      return nullToAny(std::get<null_t>(result));
    }
    }
    throw LSP_EXCEPTION(
      ErrorCodes::INTERNAL_ERROR,
      "Should be unreachable."
    );
  }

  auto LspTransformer::asInitializeParams(
    const MessageParams &requestParams
  ) const -> std::unique_ptr<InitializeParams> {
    if (static_cast<MessageParamsType>(requestParams.index()) != MessageParamsType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Message parameter type must be MessageParamsType::" +
         MessageParamsTypeNames.at(MessageParamsType::OBJECT_TYPE) +
         " for method=\"initialize\" but received type " +
         "MessageParamsType::" + MessageParamsTypeNames.at(static_cast<MessageParamsType>(requestParams.index())))
      );
    }

    const LSPObject &object = std::get<LSPObject>(requestParams);
    LSPObject::const_iterator iter;

    std::unique_ptr<InitializeParams> initializeParams =
      std::make_unique<InitializeParams>();

    iter = object.find("processId");
    if (iter != object.end()) {
      initializeParams->processId = anyTo_InitializeParams_processId(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required InitializeParams attribute: processId"
      );
    }

    iter = object.find("clientInfo");
    if (iter != object.end()) {
      initializeParams->clientInfo = anyTo_InitializeParams_clientInfo(*iter->second);
    }

    iter = object.find("locale");
    if (iter != object.end()) {
      initializeParams->locale = anyToString(*iter->second);
    }

    iter = object.find("rootPath");
    if (iter != object.end()) {
      initializeParams->rootPath = anyTo_InitializeParams_rootPath(*iter->second);
    }

    iter = object.find("rootUri");
    if (iter != object.end()) {
      initializeParams->rootUri = anyTo_InitializeParams_rootUri(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required InitializeParams attribute: rootUri"
      );
    }

    iter = object.find("capabilities");
    if (iter != object.end()) {
      initializeParams->capabilities = anyToClientCapabilities(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required InitializeParams attribute: capabilities"
      );
    }

    iter = object.find("initializationOptions");
    if (iter != object.end()) {
      initializeParams->initializationOptions = copy(iter->second);
    }

    iter = object.find("trace");
    if (iter != object.end()) {
      initializeParams->trace = anyToTraceValues(*iter->second);
    }

    iter = object.find("workspaceFolders");
    if (iter != object.end()) {
      initializeParams->workspaceFolders = anyToWorkspaceFoldersInitializeParams_workspaceFolders(*iter->second);
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      initializeParams->workDoneToken = anyToProgressToken(*iter->second);
    }

    return initializeParams;
  }

  auto LspTransformer::shutdownResultToAny(
    const ShutdownResult &result
  ) -> std::unique_ptr<LSPAny> {
    return nullToAny(result);
  }

  auto LspTransformer::asTextDocumentWillSaveWaitUntilParams(
    const MessageParams &requestParams
  ) const -> std::unique_ptr<WillSaveTextDocumentParams> {
    if (static_cast<MessageParamsType>(requestParams.index()) != MessageParamsType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Message parameter type must be MessageParamsType::" +
         MessageParamsTypeNames.at(MessageParamsType::OBJECT_TYPE) +
         " for method=\"textDocument/willSaveWaitUntil\" but received type " +
         "MessageParamsType::" + MessageParamsTypeNames.at(static_cast<MessageParamsType>(requestParams.index())))
      );
    }

    const LSPObject &object = std::get<LSPObject>(requestParams);
    LSPObject::const_iterator iter;

    std::unique_ptr<WillSaveTextDocumentParams> willSaveTextDocumentParams =
      std::make_unique<WillSaveTextDocumentParams>();

    iter = object.find("textDocument");
    if (iter != object.end()) {
      willSaveTextDocumentParams->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required WillSaveTextDocumentParams attribute: textDocument"
      );
    }

    iter = object.find("reason");
    if (iter != object.end()) {
      willSaveTextDocumentParams->reason = anyToTextDocumentSaveReason(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required WillSaveTextDocumentParams attribute: reason"
      );
    }

    return willSaveTextDocumentParams;
  }

  auto LspTransformer::textDocumentWillSaveWaitUntilResultToAny(
    const TextDocumentWillSaveWaitUntilResult &result
  ) -> std::unique_ptr<LSPAny> {
    switch (static_cast<TextDocumentWillSaveWaitUntilResultType>(result.index())) {
    case TextDocumentWillSaveWaitUntilResultType::TEXT_EDIT_ARRAY: {
      LSPArray array;
      for (const std::unique_ptr<TextEdit> &elem
          : std::get<std::vector<std::unique_ptr<TextEdit>>>(result)) {
        array.push_back(textEditToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      return any;
    }
    case TextDocumentWillSaveWaitUntilResultType::NULL_TYPE: {
      return nullToAny(std::get<null_t>(result));
    }
    }
    throw LSP_EXCEPTION(
      ErrorCodes::INTERNAL_ERROR,
      "Should be unreachable."
    );
  }

  auto LspTransformer::asTextDocumentCompletionParams(
    const MessageParams &requestParams
  ) const -> std::unique_ptr<CompletionParams> {
    if (static_cast<MessageParamsType>(requestParams.index()) != MessageParamsType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Message parameter type must be MessageParamsType::" +
         MessageParamsTypeNames.at(MessageParamsType::OBJECT_TYPE) +
         " for method=\"textDocument/completion\" but received type " +
         "MessageParamsType::" + MessageParamsTypeNames.at(static_cast<MessageParamsType>(requestParams.index())))
      );
    }

    const LSPObject &object = std::get<LSPObject>(requestParams);
    LSPObject::const_iterator iter;

    std::unique_ptr<CompletionParams> completionParams =
      std::make_unique<CompletionParams>();

    iter = object.find("context");
    if (iter != object.end()) {
      completionParams->context = anyToCompletionContext(*iter->second);
    }

    iter = object.find("textDocument");
    if (iter != object.end()) {
      completionParams->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required CompletionParams attribute: textDocument"
      );
    }

    iter = object.find("position");
    if (iter != object.end()) {
      completionParams->position = anyToPosition(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required CompletionParams attribute: position"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      completionParams->workDoneToken = anyToProgressToken(*iter->second);
    }

    iter = object.find("partialResultToken");
    if (iter != object.end()) {
      completionParams->partialResultToken = anyToProgressToken(*iter->second);
    }

    return completionParams;
  }

  auto LspTransformer::textDocumentCompletionResultToAny(
    const TextDocumentCompletionResult &result
  ) -> std::unique_ptr<LSPAny> {
    switch (static_cast<TextDocumentCompletionResultType>(result.index())) {
    case TextDocumentCompletionResultType::COMPLETION_ITEM_ARRAY: {
      LSPArray array;
      for (const std::unique_ptr<CompletionItem> &elem
          : std::get<std::vector<std::unique_ptr<CompletionItem>>>(result)) {
        array.push_back(completionItemToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      return any;
    }
    case TextDocumentCompletionResultType::COMPLETION_LIST: {
      return completionListToAny(*std::get<std::unique_ptr<CompletionList>>(result));
    }
    case TextDocumentCompletionResultType::NULL_TYPE: {
      return nullToAny(std::get<null_t>(result));
    }
    }
    throw LSP_EXCEPTION(
      ErrorCodes::INTERNAL_ERROR,
      "Should be unreachable."
    );
  }

  auto LspTransformer::asCompletionItemResolveParams(
    const MessageParams &requestParams
  ) const -> std::unique_ptr<CompletionItem> {
    if (static_cast<MessageParamsType>(requestParams.index()) != MessageParamsType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Message parameter type must be MessageParamsType::" +
         MessageParamsTypeNames.at(MessageParamsType::OBJECT_TYPE) +
         " for method=\"completionItem/resolve\" but received type " +
         "MessageParamsType::" + MessageParamsTypeNames.at(static_cast<MessageParamsType>(requestParams.index())))
      );
    }

    const LSPObject &object = std::get<LSPObject>(requestParams);
    LSPObject::const_iterator iter;

    std::unique_ptr<CompletionItem> completionItem =
      std::make_unique<CompletionItem>();

    iter = object.find("label");
    if (iter != object.end()) {
      completionItem->label = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required CompletionItem attribute: label"
      );
    }

    iter = object.find("labelDetails");
    if (iter != object.end()) {
      completionItem->labelDetails = anyToCompletionItemLabelDetails(*iter->second);
    }

    iter = object.find("kind");
    if (iter != object.end()) {
      completionItem->kind = anyToCompletionItemKind(*iter->second);
    }

    iter = object.find("tags");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<CompletionItemTag> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToCompletionItemTag(*elem));
      }
      completionItem->tags = std::move(values);
    }

    iter = object.find("detail");
    if (iter != object.end()) {
      completionItem->detail = anyToString(*iter->second);
    }

    iter = object.find("documentation");
    if (iter != object.end()) {
      completionItem->documentation = anyToCompletionItem_documentation(*iter->second);
    }

    iter = object.find("deprecated");
    if (iter != object.end()) {
      completionItem->deprecated = anyToBoolean(*iter->second);
    }

    iter = object.find("preselect");
    if (iter != object.end()) {
      completionItem->preselect = anyToBoolean(*iter->second);
    }

    iter = object.find("sortText");
    if (iter != object.end()) {
      completionItem->sortText = anyToString(*iter->second);
    }

    iter = object.find("filterText");
    if (iter != object.end()) {
      completionItem->filterText = anyToString(*iter->second);
    }

    iter = object.find("insertText");
    if (iter != object.end()) {
      completionItem->insertText = anyToString(*iter->second);
    }

    iter = object.find("insertTextFormat");
    if (iter != object.end()) {
      completionItem->insertTextFormat = anyToInsertTextFormat(*iter->second);
    }

    iter = object.find("insertTextMode");
    if (iter != object.end()) {
      completionItem->insertTextMode = anyToInsertTextMode(*iter->second);
    }

    iter = object.find("textEdit");
    if (iter != object.end()) {
      completionItem->textEdit = anyToCompletionItem_textEdit(*iter->second);
    }

    iter = object.find("textEditText");
    if (iter != object.end()) {
      completionItem->textEditText = anyToString(*iter->second);
    }

    iter = object.find("additionalTextEdits");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<std::unique_ptr<TextEdit>> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToTextEdit(*elem));
      }
      completionItem->additionalTextEdits = std::move(values);
    }

    iter = object.find("commitCharacters");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<string_t> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToString(*elem));
      }
      completionItem->commitCharacters = std::move(values);
    }

    iter = object.find("command");
    if (iter != object.end()) {
      completionItem->command = anyToCommand(*iter->second);
    }

    iter = object.find("data");
    if (iter != object.end()) {
      completionItem->data = copy(iter->second);
    }

    return completionItem;
  }

  auto LspTransformer::completionItemResolveResultToAny(
    const CompletionItemResolveResult &result
  ) -> std::unique_ptr<LSPAny> {
    return completionItemToAny(result);
  }

  auto LspTransformer::asTextDocumentHoverParams(
    const MessageParams &requestParams
  ) const -> std::unique_ptr<HoverParams> {
    if (static_cast<MessageParamsType>(requestParams.index()) != MessageParamsType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Message parameter type must be MessageParamsType::" +
         MessageParamsTypeNames.at(MessageParamsType::OBJECT_TYPE) +
         " for method=\"textDocument/hover\" but received type " +
         "MessageParamsType::" + MessageParamsTypeNames.at(static_cast<MessageParamsType>(requestParams.index())))
      );
    }

    const LSPObject &object = std::get<LSPObject>(requestParams);
    LSPObject::const_iterator iter;

    std::unique_ptr<HoverParams> hoverParams =
      std::make_unique<HoverParams>();

    iter = object.find("textDocument");
    if (iter != object.end()) {
      hoverParams->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required HoverParams attribute: textDocument"
      );
    }

    iter = object.find("position");
    if (iter != object.end()) {
      hoverParams->position = anyToPosition(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required HoverParams attribute: position"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      hoverParams->workDoneToken = anyToProgressToken(*iter->second);
    }

    return hoverParams;
  }

  auto LspTransformer::textDocumentHoverResultToAny(
    const TextDocumentHoverResult &result
  ) -> std::unique_ptr<LSPAny> {
    switch (static_cast<TextDocumentHoverResultType>(result.index())) {
    case TextDocumentHoverResultType::HOVER: {
      return hoverToAny(*std::get<std::unique_ptr<Hover>>(result));
    }
    case TextDocumentHoverResultType::NULL_TYPE: {
      return nullToAny(std::get<null_t>(result));
    }
    }
    throw LSP_EXCEPTION(
      ErrorCodes::INTERNAL_ERROR,
      "Should be unreachable."
    );
  }

  auto LspTransformer::asTextDocumentSignatureHelpParams(
    const MessageParams &requestParams
  ) const -> std::unique_ptr<SignatureHelpParams> {
    if (static_cast<MessageParamsType>(requestParams.index()) != MessageParamsType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Message parameter type must be MessageParamsType::" +
         MessageParamsTypeNames.at(MessageParamsType::OBJECT_TYPE) +
         " for method=\"textDocument/signatureHelp\" but received type " +
         "MessageParamsType::" + MessageParamsTypeNames.at(static_cast<MessageParamsType>(requestParams.index())))
      );
    }

    const LSPObject &object = std::get<LSPObject>(requestParams);
    LSPObject::const_iterator iter;

    std::unique_ptr<SignatureHelpParams> signatureHelpParams =
      std::make_unique<SignatureHelpParams>();

    iter = object.find("context");
    if (iter != object.end()) {
      signatureHelpParams->context = anyToSignatureHelpContext(*iter->second);
    }

    iter = object.find("textDocument");
    if (iter != object.end()) {
      signatureHelpParams->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required SignatureHelpParams attribute: textDocument"
      );
    }

    iter = object.find("position");
    if (iter != object.end()) {
      signatureHelpParams->position = anyToPosition(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required SignatureHelpParams attribute: position"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      signatureHelpParams->workDoneToken = anyToProgressToken(*iter->second);
    }

    return signatureHelpParams;
  }

  auto LspTransformer::textDocumentSignatureHelpResultToAny(
    const TextDocumentSignatureHelpResult &result
  ) -> std::unique_ptr<LSPAny> {
    switch (static_cast<TextDocumentSignatureHelpResultType>(result.index())) {
    case TextDocumentSignatureHelpResultType::SIGNATURE_HELP: {
      return signatureHelpToAny(*std::get<std::unique_ptr<SignatureHelp>>(result));
    }
    case TextDocumentSignatureHelpResultType::NULL_TYPE: {
      return nullToAny(std::get<null_t>(result));
    }
    }
    throw LSP_EXCEPTION(
      ErrorCodes::INTERNAL_ERROR,
      "Should be unreachable."
    );
  }

  auto LspTransformer::asTextDocumentDefinitionParams(
    const MessageParams &requestParams
  ) const -> std::unique_ptr<DefinitionParams> {
    if (static_cast<MessageParamsType>(requestParams.index()) != MessageParamsType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Message parameter type must be MessageParamsType::" +
         MessageParamsTypeNames.at(MessageParamsType::OBJECT_TYPE) +
         " for method=\"textDocument/definition\" but received type " +
         "MessageParamsType::" + MessageParamsTypeNames.at(static_cast<MessageParamsType>(requestParams.index())))
      );
    }

    const LSPObject &object = std::get<LSPObject>(requestParams);
    LSPObject::const_iterator iter;

    std::unique_ptr<DefinitionParams> definitionParams =
      std::make_unique<DefinitionParams>();

    iter = object.find("textDocument");
    if (iter != object.end()) {
      definitionParams->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DefinitionParams attribute: textDocument"
      );
    }

    iter = object.find("position");
    if (iter != object.end()) {
      definitionParams->position = anyToPosition(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DefinitionParams attribute: position"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      definitionParams->workDoneToken = anyToProgressToken(*iter->second);
    }

    iter = object.find("partialResultToken");
    if (iter != object.end()) {
      definitionParams->partialResultToken = anyToProgressToken(*iter->second);
    }

    return definitionParams;
  }

  auto LspTransformer::textDocumentDefinitionResultToAny(
    const TextDocumentDefinitionResult &result
  ) -> std::unique_ptr<LSPAny> {
    switch (static_cast<TextDocumentDefinitionResultType>(result.index())) {
    case TextDocumentDefinitionResultType::DEFINITION: {
      return definitionToAny(std::get<Definition>(result));
    }
    case TextDocumentDefinitionResultType::DEFINITION_LINK_ARRAY: {
      LSPArray array;
      for (const std::unique_ptr<DefinitionLink> &elem
          : std::get<std::vector<std::unique_ptr<DefinitionLink>>>(result)) {
        array.push_back(definitionLinkToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      return any;
    }
    case TextDocumentDefinitionResultType::NULL_TYPE: {
      return nullToAny(std::get<null_t>(result));
    }
    case TextDocumentDefinitionResultType::LOCATION_ARRAY: {
      LSPArray array;
      for (const std::unique_ptr<Location> &elem
          : std::get<std::vector<std::unique_ptr<Location>>>(result)) {
        array.push_back(locationToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      return any;
    }
    }
    throw LSP_EXCEPTION(
      ErrorCodes::INTERNAL_ERROR,
      "Should be unreachable."
    );
  }

  auto LspTransformer::asTextDocumentReferencesParams(
    const MessageParams &requestParams
  ) const -> std::unique_ptr<ReferenceParams> {
    if (static_cast<MessageParamsType>(requestParams.index()) != MessageParamsType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Message parameter type must be MessageParamsType::" +
         MessageParamsTypeNames.at(MessageParamsType::OBJECT_TYPE) +
         " for method=\"textDocument/references\" but received type " +
         "MessageParamsType::" + MessageParamsTypeNames.at(static_cast<MessageParamsType>(requestParams.index())))
      );
    }

    const LSPObject &object = std::get<LSPObject>(requestParams);
    LSPObject::const_iterator iter;

    std::unique_ptr<ReferenceParams> referenceParams =
      std::make_unique<ReferenceParams>();

    iter = object.find("context");
    if (iter != object.end()) {
      referenceParams->context = anyToReferenceContext(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required ReferenceParams attribute: context"
      );
    }

    iter = object.find("textDocument");
    if (iter != object.end()) {
      referenceParams->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required ReferenceParams attribute: textDocument"
      );
    }

    iter = object.find("position");
    if (iter != object.end()) {
      referenceParams->position = anyToPosition(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required ReferenceParams attribute: position"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      referenceParams->workDoneToken = anyToProgressToken(*iter->second);
    }

    iter = object.find("partialResultToken");
    if (iter != object.end()) {
      referenceParams->partialResultToken = anyToProgressToken(*iter->second);
    }

    return referenceParams;
  }

  auto LspTransformer::textDocumentReferencesResultToAny(
    const TextDocumentReferencesResult &result
  ) -> std::unique_ptr<LSPAny> {
    switch (static_cast<TextDocumentReferencesResultType>(result.index())) {
    case TextDocumentReferencesResultType::LOCATION_ARRAY: {
      LSPArray array;
      for (const std::unique_ptr<Location> &elem
          : std::get<std::vector<std::unique_ptr<Location>>>(result)) {
        array.push_back(locationToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      return any;
    }
    case TextDocumentReferencesResultType::NULL_TYPE: {
      return nullToAny(std::get<null_t>(result));
    }
    }
    throw LSP_EXCEPTION(
      ErrorCodes::INTERNAL_ERROR,
      "Should be unreachable."
    );
  }

  auto LspTransformer::asTextDocumentDocumentHighlightParams(
    const MessageParams &requestParams
  ) const -> std::unique_ptr<DocumentHighlightParams> {
    if (static_cast<MessageParamsType>(requestParams.index()) != MessageParamsType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Message parameter type must be MessageParamsType::" +
         MessageParamsTypeNames.at(MessageParamsType::OBJECT_TYPE) +
         " for method=\"textDocument/documentHighlight\" but received type " +
         "MessageParamsType::" + MessageParamsTypeNames.at(static_cast<MessageParamsType>(requestParams.index())))
      );
    }

    const LSPObject &object = std::get<LSPObject>(requestParams);
    LSPObject::const_iterator iter;

    std::unique_ptr<DocumentHighlightParams> documentHighlightParams =
      std::make_unique<DocumentHighlightParams>();

    iter = object.find("textDocument");
    if (iter != object.end()) {
      documentHighlightParams->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DocumentHighlightParams attribute: textDocument"
      );
    }

    iter = object.find("position");
    if (iter != object.end()) {
      documentHighlightParams->position = anyToPosition(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DocumentHighlightParams attribute: position"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      documentHighlightParams->workDoneToken = anyToProgressToken(*iter->second);
    }

    iter = object.find("partialResultToken");
    if (iter != object.end()) {
      documentHighlightParams->partialResultToken = anyToProgressToken(*iter->second);
    }

    return documentHighlightParams;
  }

  auto LspTransformer::textDocumentDocumentHighlightResultToAny(
    const TextDocumentDocumentHighlightResult &result
  ) -> std::unique_ptr<LSPAny> {
    switch (static_cast<TextDocumentDocumentHighlightResultType>(result.index())) {
    case TextDocumentDocumentHighlightResultType::DOCUMENT_HIGHLIGHT_ARRAY: {
      LSPArray array;
      for (const std::unique_ptr<DocumentHighlight> &elem
          : std::get<std::vector<std::unique_ptr<DocumentHighlight>>>(result)) {
        array.push_back(documentHighlightToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      return any;
    }
    case TextDocumentDocumentHighlightResultType::NULL_TYPE: {
      return nullToAny(std::get<null_t>(result));
    }
    }
    throw LSP_EXCEPTION(
      ErrorCodes::INTERNAL_ERROR,
      "Should be unreachable."
    );
  }

  auto LspTransformer::asTextDocumentDocumentSymbolParams(
    const MessageParams &requestParams
  ) const -> std::unique_ptr<DocumentSymbolParams> {
    if (static_cast<MessageParamsType>(requestParams.index()) != MessageParamsType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Message parameter type must be MessageParamsType::" +
         MessageParamsTypeNames.at(MessageParamsType::OBJECT_TYPE) +
         " for method=\"textDocument/documentSymbol\" but received type " +
         "MessageParamsType::" + MessageParamsTypeNames.at(static_cast<MessageParamsType>(requestParams.index())))
      );
    }

    const LSPObject &object = std::get<LSPObject>(requestParams);
    LSPObject::const_iterator iter;

    std::unique_ptr<DocumentSymbolParams> documentSymbolParams =
      std::make_unique<DocumentSymbolParams>();

    iter = object.find("textDocument");
    if (iter != object.end()) {
      documentSymbolParams->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DocumentSymbolParams attribute: textDocument"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      documentSymbolParams->workDoneToken = anyToProgressToken(*iter->second);
    }

    iter = object.find("partialResultToken");
    if (iter != object.end()) {
      documentSymbolParams->partialResultToken = anyToProgressToken(*iter->second);
    }

    return documentSymbolParams;
  }

  auto LspTransformer::textDocumentDocumentSymbolResultToAny(
    const TextDocumentDocumentSymbolResult &result
  ) -> std::unique_ptr<LSPAny> {
    switch (static_cast<TextDocumentDocumentSymbolResultType>(result.index())) {
    case TextDocumentDocumentSymbolResultType::SYMBOL_INFORMATION_ARRAY: {
      LSPArray array;
      for (const std::unique_ptr<SymbolInformation> &elem
          : std::get<std::vector<std::unique_ptr<SymbolInformation>>>(result)) {
        array.push_back(symbolInformationToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      return any;
    }
    case TextDocumentDocumentSymbolResultType::DOCUMENT_SYMBOL_ARRAY: {
      LSPArray array;
      for (const std::unique_ptr<DocumentSymbol> &elem
          : std::get<std::vector<std::unique_ptr<DocumentSymbol>>>(result)) {
        array.push_back(documentSymbolToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      return any;
    }
    case TextDocumentDocumentSymbolResultType::NULL_TYPE: {
      return nullToAny(std::get<null_t>(result));
    }
    }
    throw LSP_EXCEPTION(
      ErrorCodes::INTERNAL_ERROR,
      "Should be unreachable."
    );
  }

  auto LspTransformer::asTextDocumentCodeActionParams(
    const MessageParams &requestParams
  ) const -> std::unique_ptr<CodeActionParams> {
    if (static_cast<MessageParamsType>(requestParams.index()) != MessageParamsType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Message parameter type must be MessageParamsType::" +
         MessageParamsTypeNames.at(MessageParamsType::OBJECT_TYPE) +
         " for method=\"textDocument/codeAction\" but received type " +
         "MessageParamsType::" + MessageParamsTypeNames.at(static_cast<MessageParamsType>(requestParams.index())))
      );
    }

    const LSPObject &object = std::get<LSPObject>(requestParams);
    LSPObject::const_iterator iter;

    std::unique_ptr<CodeActionParams> codeActionParams =
      std::make_unique<CodeActionParams>();

    iter = object.find("textDocument");
    if (iter != object.end()) {
      codeActionParams->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required CodeActionParams attribute: textDocument"
      );
    }

    iter = object.find("range");
    if (iter != object.end()) {
      codeActionParams->range = anyToRange(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required CodeActionParams attribute: range"
      );
    }

    iter = object.find("context");
    if (iter != object.end()) {
      codeActionParams->context = anyToCodeActionContext(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required CodeActionParams attribute: context"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      codeActionParams->workDoneToken = anyToProgressToken(*iter->second);
    }

    iter = object.find("partialResultToken");
    if (iter != object.end()) {
      codeActionParams->partialResultToken = anyToProgressToken(*iter->second);
    }

    return codeActionParams;
  }

  auto LspTransformer::textDocumentCodeActionResultToAny(
    const TextDocumentCodeActionResult &result
  ) -> std::unique_ptr<LSPAny> {
    switch (static_cast<TextDocumentCodeActionResultType>(result.index())) {
    case TextDocumentCodeActionResultType::COMMAND_OR_CODE_ACTION_ARRAY: {
      LSPArray array;
      for (const TextDocumentCodeActionResult_0 &elem
          : std::get<std::vector<TextDocumentCodeActionResult_0>>(result)) {
        switch (static_cast<TextDocumentCodeActionResult_0Type>(elem.index())) {
        case TextDocumentCodeActionResult_0Type::COMMAND: {
          array.push_back(commandToAny(*std::get<std::unique_ptr<Command>>(elem)));
          break;
        }
        case TextDocumentCodeActionResult_0Type::CODE_ACTION: {
          array.push_back(codeActionToAny(*std::get<std::unique_ptr<CodeAction>>(elem)));
          break;
        }
        }
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      return any;
    }
    case TextDocumentCodeActionResultType::NULL_TYPE: {
      return nullToAny(std::get<null_t>(result));
    }
    }
    throw LSP_EXCEPTION(
      ErrorCodes::INTERNAL_ERROR,
      "Should be unreachable."
    );
  }

  auto LspTransformer::asCodeActionResolveParams(
    const MessageParams &requestParams
  ) const -> std::unique_ptr<CodeAction> {
    if (static_cast<MessageParamsType>(requestParams.index()) != MessageParamsType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Message parameter type must be MessageParamsType::" +
         MessageParamsTypeNames.at(MessageParamsType::OBJECT_TYPE) +
         " for method=\"codeAction/resolve\" but received type " +
         "MessageParamsType::" + MessageParamsTypeNames.at(static_cast<MessageParamsType>(requestParams.index())))
      );
    }

    const LSPObject &object = std::get<LSPObject>(requestParams);
    LSPObject::const_iterator iter;

    std::unique_ptr<CodeAction> codeAction =
      std::make_unique<CodeAction>();

    iter = object.find("title");
    if (iter != object.end()) {
      codeAction->title = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required CodeAction attribute: title"
      );
    }

    iter = object.find("kind");
    if (iter != object.end()) {
      codeAction->kind = anyToCodeActionKind(*iter->second);
    }

    iter = object.find("diagnostics");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<std::unique_ptr<Diagnostic>> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToDiagnostic(*elem));
      }
      codeAction->diagnostics = std::move(values);
    }

    iter = object.find("isPreferred");
    if (iter != object.end()) {
      codeAction->isPreferred = anyToBoolean(*iter->second);
    }

    iter = object.find("disabled");
    if (iter != object.end()) {
      codeAction->disabled = anyToCodeAction_disabled(*iter->second);
    }

    iter = object.find("edit");
    if (iter != object.end()) {
      codeAction->edit = anyToWorkspaceEdit(*iter->second);
    }

    iter = object.find("command");
    if (iter != object.end()) {
      codeAction->command = anyToCommand(*iter->second);
    }

    iter = object.find("data");
    if (iter != object.end()) {
      codeAction->data = copy(iter->second);
    }

    return codeAction;
  }

  auto LspTransformer::codeActionResolveResultToAny(
    const CodeActionResolveResult &result
  ) -> std::unique_ptr<LSPAny> {
    return codeActionToAny(result);
  }

  auto LspTransformer::asWorkspaceSymbolParams(
    const MessageParams &requestParams
  ) const -> std::unique_ptr<WorkspaceSymbolParams> {
    if (static_cast<MessageParamsType>(requestParams.index()) != MessageParamsType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Message parameter type must be MessageParamsType::" +
         MessageParamsTypeNames.at(MessageParamsType::OBJECT_TYPE) +
         " for method=\"workspace/symbol\" but received type " +
         "MessageParamsType::" + MessageParamsTypeNames.at(static_cast<MessageParamsType>(requestParams.index())))
      );
    }

    const LSPObject &object = std::get<LSPObject>(requestParams);
    LSPObject::const_iterator iter;

    std::unique_ptr<WorkspaceSymbolParams> workspaceSymbolParams =
      std::make_unique<WorkspaceSymbolParams>();

    iter = object.find("query");
    if (iter != object.end()) {
      workspaceSymbolParams->query = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required WorkspaceSymbolParams attribute: query"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      workspaceSymbolParams->workDoneToken = anyToProgressToken(*iter->second);
    }

    iter = object.find("partialResultToken");
    if (iter != object.end()) {
      workspaceSymbolParams->partialResultToken = anyToProgressToken(*iter->second);
    }

    return workspaceSymbolParams;
  }

  auto LspTransformer::workspaceSymbolResultToAny(
    const WorkspaceSymbolResult &result
  ) -> std::unique_ptr<LSPAny> {
    switch (static_cast<WorkspaceSymbolResultType>(result.index())) {
    case WorkspaceSymbolResultType::SYMBOL_INFORMATION_ARRAY: {
      LSPArray array;
      for (const std::unique_ptr<SymbolInformation> &elem
          : std::get<std::vector<std::unique_ptr<SymbolInformation>>>(result)) {
        array.push_back(symbolInformationToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      return any;
    }
    case WorkspaceSymbolResultType::WORKSPACE_SYMBOL_ARRAY: {
      LSPArray array;
      for (const std::unique_ptr<WorkspaceSymbol> &elem
          : std::get<std::vector<std::unique_ptr<WorkspaceSymbol>>>(result)) {
        array.push_back(workspaceSymbolToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      return any;
    }
    case WorkspaceSymbolResultType::NULL_TYPE: {
      return nullToAny(std::get<null_t>(result));
    }
    }
    throw LSP_EXCEPTION(
      ErrorCodes::INTERNAL_ERROR,
      "Should be unreachable."
    );
  }

  auto LspTransformer::asWorkspaceSymbolResolveParams(
    const MessageParams &requestParams
  ) const -> std::unique_ptr<WorkspaceSymbol> {
    if (static_cast<MessageParamsType>(requestParams.index()) != MessageParamsType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Message parameter type must be MessageParamsType::" +
         MessageParamsTypeNames.at(MessageParamsType::OBJECT_TYPE) +
         " for method=\"workspaceSymbol/resolve\" but received type " +
         "MessageParamsType::" + MessageParamsTypeNames.at(static_cast<MessageParamsType>(requestParams.index())))
      );
    }

    const LSPObject &object = std::get<LSPObject>(requestParams);
    LSPObject::const_iterator iter;

    std::unique_ptr<WorkspaceSymbol> workspaceSymbol =
      std::make_unique<WorkspaceSymbol>();

    iter = object.find("location");
    if (iter != object.end()) {
      workspaceSymbol->location = anyToWorkspaceSymbol_location(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required WorkspaceSymbol attribute: location"
      );
    }

    iter = object.find("data");
    if (iter != object.end()) {
      workspaceSymbol->data = copy(iter->second);
    }

    iter = object.find("name");
    if (iter != object.end()) {
      workspaceSymbol->name = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required WorkspaceSymbol attribute: name"
      );
    }

    iter = object.find("kind");
    if (iter != object.end()) {
      workspaceSymbol->kind = anyToSymbolKind(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required WorkspaceSymbol attribute: kind"
      );
    }

    iter = object.find("tags");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<SymbolTag> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToSymbolTag(*elem));
      }
      workspaceSymbol->tags = std::move(values);
    }

    iter = object.find("containerName");
    if (iter != object.end()) {
      workspaceSymbol->containerName = anyToString(*iter->second);
    }

    return workspaceSymbol;
  }

  auto LspTransformer::workspaceSymbolResolveResultToAny(
    const WorkspaceSymbolResolveResult &result
  ) -> std::unique_ptr<LSPAny> {
    return workspaceSymbolToAny(result);
  }

  auto LspTransformer::asTextDocumentCodeLensParams(
    const MessageParams &requestParams
  ) const -> std::unique_ptr<CodeLensParams> {
    if (static_cast<MessageParamsType>(requestParams.index()) != MessageParamsType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Message parameter type must be MessageParamsType::" +
         MessageParamsTypeNames.at(MessageParamsType::OBJECT_TYPE) +
         " for method=\"textDocument/codeLens\" but received type " +
         "MessageParamsType::" + MessageParamsTypeNames.at(static_cast<MessageParamsType>(requestParams.index())))
      );
    }

    const LSPObject &object = std::get<LSPObject>(requestParams);
    LSPObject::const_iterator iter;

    std::unique_ptr<CodeLensParams> codeLensParams =
      std::make_unique<CodeLensParams>();

    iter = object.find("textDocument");
    if (iter != object.end()) {
      codeLensParams->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required CodeLensParams attribute: textDocument"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      codeLensParams->workDoneToken = anyToProgressToken(*iter->second);
    }

    iter = object.find("partialResultToken");
    if (iter != object.end()) {
      codeLensParams->partialResultToken = anyToProgressToken(*iter->second);
    }

    return codeLensParams;
  }

  auto LspTransformer::textDocumentCodeLensResultToAny(
    const TextDocumentCodeLensResult &result
  ) -> std::unique_ptr<LSPAny> {
    switch (static_cast<TextDocumentCodeLensResultType>(result.index())) {
    case TextDocumentCodeLensResultType::CODE_LENS_ARRAY: {
      LSPArray array;
      for (const std::unique_ptr<CodeLens> &elem
          : std::get<std::vector<std::unique_ptr<CodeLens>>>(result)) {
        array.push_back(codeLensToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      return any;
    }
    case TextDocumentCodeLensResultType::NULL_TYPE: {
      return nullToAny(std::get<null_t>(result));
    }
    }
    throw LSP_EXCEPTION(
      ErrorCodes::INTERNAL_ERROR,
      "Should be unreachable."
    );
  }

  auto LspTransformer::asCodeLensResolveParams(
    const MessageParams &requestParams
  ) const -> std::unique_ptr<CodeLens> {
    if (static_cast<MessageParamsType>(requestParams.index()) != MessageParamsType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Message parameter type must be MessageParamsType::" +
         MessageParamsTypeNames.at(MessageParamsType::OBJECT_TYPE) +
         " for method=\"codeLens/resolve\" but received type " +
         "MessageParamsType::" + MessageParamsTypeNames.at(static_cast<MessageParamsType>(requestParams.index())))
      );
    }

    const LSPObject &object = std::get<LSPObject>(requestParams);
    LSPObject::const_iterator iter;

    std::unique_ptr<CodeLens> codeLens =
      std::make_unique<CodeLens>();

    iter = object.find("range");
    if (iter != object.end()) {
      codeLens->range = anyToRange(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required CodeLens attribute: range"
      );
    }

    iter = object.find("command");
    if (iter != object.end()) {
      codeLens->command = anyToCommand(*iter->second);
    }

    iter = object.find("data");
    if (iter != object.end()) {
      codeLens->data = copy(iter->second);
    }

    return codeLens;
  }

  auto LspTransformer::codeLensResolveResultToAny(
    const CodeLensResolveResult &result
  ) -> std::unique_ptr<LSPAny> {
    return codeLensToAny(result);
  }

  auto LspTransformer::asTextDocumentDocumentLinkParams(
    const MessageParams &requestParams
  ) const -> std::unique_ptr<DocumentLinkParams> {
    if (static_cast<MessageParamsType>(requestParams.index()) != MessageParamsType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Message parameter type must be MessageParamsType::" +
         MessageParamsTypeNames.at(MessageParamsType::OBJECT_TYPE) +
         " for method=\"textDocument/documentLink\" but received type " +
         "MessageParamsType::" + MessageParamsTypeNames.at(static_cast<MessageParamsType>(requestParams.index())))
      );
    }

    const LSPObject &object = std::get<LSPObject>(requestParams);
    LSPObject::const_iterator iter;

    std::unique_ptr<DocumentLinkParams> documentLinkParams =
      std::make_unique<DocumentLinkParams>();

    iter = object.find("textDocument");
    if (iter != object.end()) {
      documentLinkParams->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DocumentLinkParams attribute: textDocument"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      documentLinkParams->workDoneToken = anyToProgressToken(*iter->second);
    }

    iter = object.find("partialResultToken");
    if (iter != object.end()) {
      documentLinkParams->partialResultToken = anyToProgressToken(*iter->second);
    }

    return documentLinkParams;
  }

  auto LspTransformer::textDocumentDocumentLinkResultToAny(
    const TextDocumentDocumentLinkResult &result
  ) -> std::unique_ptr<LSPAny> {
    switch (static_cast<TextDocumentDocumentLinkResultType>(result.index())) {
    case TextDocumentDocumentLinkResultType::DOCUMENT_LINK_ARRAY: {
      LSPArray array;
      for (const std::unique_ptr<DocumentLink> &elem
          : std::get<std::vector<std::unique_ptr<DocumentLink>>>(result)) {
        array.push_back(documentLinkToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      return any;
    }
    case TextDocumentDocumentLinkResultType::NULL_TYPE: {
      return nullToAny(std::get<null_t>(result));
    }
    }
    throw LSP_EXCEPTION(
      ErrorCodes::INTERNAL_ERROR,
      "Should be unreachable."
    );
  }

  auto LspTransformer::asDocumentLinkResolveParams(
    const MessageParams &requestParams
  ) const -> std::unique_ptr<DocumentLink> {
    if (static_cast<MessageParamsType>(requestParams.index()) != MessageParamsType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Message parameter type must be MessageParamsType::" +
         MessageParamsTypeNames.at(MessageParamsType::OBJECT_TYPE) +
         " for method=\"documentLink/resolve\" but received type " +
         "MessageParamsType::" + MessageParamsTypeNames.at(static_cast<MessageParamsType>(requestParams.index())))
      );
    }

    const LSPObject &object = std::get<LSPObject>(requestParams);
    LSPObject::const_iterator iter;

    std::unique_ptr<DocumentLink> documentLink =
      std::make_unique<DocumentLink>();

    iter = object.find("range");
    if (iter != object.end()) {
      documentLink->range = anyToRange(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DocumentLink attribute: range"
      );
    }

    iter = object.find("target");
    if (iter != object.end()) {
      documentLink->target = anyToURI(*iter->second);
    }

    iter = object.find("tooltip");
    if (iter != object.end()) {
      documentLink->tooltip = anyToString(*iter->second);
    }

    iter = object.find("data");
    if (iter != object.end()) {
      documentLink->data = copy(iter->second);
    }

    return documentLink;
  }

  auto LspTransformer::documentLinkResolveResultToAny(
    const DocumentLinkResolveResult &result
  ) -> std::unique_ptr<LSPAny> {
    return documentLinkToAny(result);
  }

  auto LspTransformer::asTextDocumentFormattingParams(
    const MessageParams &requestParams
  ) const -> std::unique_ptr<DocumentFormattingParams> {
    if (static_cast<MessageParamsType>(requestParams.index()) != MessageParamsType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Message parameter type must be MessageParamsType::" +
         MessageParamsTypeNames.at(MessageParamsType::OBJECT_TYPE) +
         " for method=\"textDocument/formatting\" but received type " +
         "MessageParamsType::" + MessageParamsTypeNames.at(static_cast<MessageParamsType>(requestParams.index())))
      );
    }

    const LSPObject &object = std::get<LSPObject>(requestParams);
    LSPObject::const_iterator iter;

    std::unique_ptr<DocumentFormattingParams> documentFormattingParams =
      std::make_unique<DocumentFormattingParams>();

    iter = object.find("textDocument");
    if (iter != object.end()) {
      documentFormattingParams->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DocumentFormattingParams attribute: textDocument"
      );
    }

    iter = object.find("options");
    if (iter != object.end()) {
      documentFormattingParams->options = anyToFormattingOptions(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DocumentFormattingParams attribute: options"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      documentFormattingParams->workDoneToken = anyToProgressToken(*iter->second);
    }

    return documentFormattingParams;
  }

  auto LspTransformer::textDocumentFormattingResultToAny(
    const TextDocumentFormattingResult &result
  ) -> std::unique_ptr<LSPAny> {
    switch (static_cast<TextDocumentFormattingResultType>(result.index())) {
    case TextDocumentFormattingResultType::TEXT_EDIT_ARRAY: {
      LSPArray array;
      for (const std::unique_ptr<TextEdit> &elem
          : std::get<std::vector<std::unique_ptr<TextEdit>>>(result)) {
        array.push_back(textEditToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      return any;
    }
    case TextDocumentFormattingResultType::NULL_TYPE: {
      return nullToAny(std::get<null_t>(result));
    }
    }
    throw LSP_EXCEPTION(
      ErrorCodes::INTERNAL_ERROR,
      "Should be unreachable."
    );
  }

  auto LspTransformer::asTextDocumentRangeFormattingParams(
    const MessageParams &requestParams
  ) const -> std::unique_ptr<DocumentRangeFormattingParams> {
    if (static_cast<MessageParamsType>(requestParams.index()) != MessageParamsType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Message parameter type must be MessageParamsType::" +
         MessageParamsTypeNames.at(MessageParamsType::OBJECT_TYPE) +
         " for method=\"textDocument/rangeFormatting\" but received type " +
         "MessageParamsType::" + MessageParamsTypeNames.at(static_cast<MessageParamsType>(requestParams.index())))
      );
    }

    const LSPObject &object = std::get<LSPObject>(requestParams);
    LSPObject::const_iterator iter;

    std::unique_ptr<DocumentRangeFormattingParams> documentRangeFormattingParams =
      std::make_unique<DocumentRangeFormattingParams>();

    iter = object.find("textDocument");
    if (iter != object.end()) {
      documentRangeFormattingParams->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DocumentRangeFormattingParams attribute: textDocument"
      );
    }

    iter = object.find("range");
    if (iter != object.end()) {
      documentRangeFormattingParams->range = anyToRange(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DocumentRangeFormattingParams attribute: range"
      );
    }

    iter = object.find("options");
    if (iter != object.end()) {
      documentRangeFormattingParams->options = anyToFormattingOptions(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DocumentRangeFormattingParams attribute: options"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      documentRangeFormattingParams->workDoneToken = anyToProgressToken(*iter->second);
    }

    return documentRangeFormattingParams;
  }

  auto LspTransformer::textDocumentRangeFormattingResultToAny(
    const TextDocumentRangeFormattingResult &result
  ) -> std::unique_ptr<LSPAny> {
    switch (static_cast<TextDocumentRangeFormattingResultType>(result.index())) {
    case TextDocumentRangeFormattingResultType::TEXT_EDIT_ARRAY: {
      LSPArray array;
      for (const std::unique_ptr<TextEdit> &elem
          : std::get<std::vector<std::unique_ptr<TextEdit>>>(result)) {
        array.push_back(textEditToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      return any;
    }
    case TextDocumentRangeFormattingResultType::NULL_TYPE: {
      return nullToAny(std::get<null_t>(result));
    }
    }
    throw LSP_EXCEPTION(
      ErrorCodes::INTERNAL_ERROR,
      "Should be unreachable."
    );
  }

  auto LspTransformer::asTextDocumentRangesFormattingParams(
    const MessageParams &requestParams
  ) const -> std::unique_ptr<DocumentRangesFormattingParams> {
    if (static_cast<MessageParamsType>(requestParams.index()) != MessageParamsType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Message parameter type must be MessageParamsType::" +
         MessageParamsTypeNames.at(MessageParamsType::OBJECT_TYPE) +
         " for method=\"textDocument/rangesFormatting\" but received type " +
         "MessageParamsType::" + MessageParamsTypeNames.at(static_cast<MessageParamsType>(requestParams.index())))
      );
    }

    const LSPObject &object = std::get<LSPObject>(requestParams);
    LSPObject::const_iterator iter;

    std::unique_ptr<DocumentRangesFormattingParams> documentRangesFormattingParams =
      std::make_unique<DocumentRangesFormattingParams>();

    iter = object.find("textDocument");
    if (iter != object.end()) {
      documentRangesFormattingParams->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DocumentRangesFormattingParams attribute: textDocument"
      );
    }

    iter = object.find("ranges");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<std::unique_ptr<Range>> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToRange(*elem));
      }
      documentRangesFormattingParams->ranges = std::move(values);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DocumentRangesFormattingParams attribute: ranges"
      );
    }

    iter = object.find("options");
    if (iter != object.end()) {
      documentRangesFormattingParams->options = anyToFormattingOptions(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DocumentRangesFormattingParams attribute: options"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      documentRangesFormattingParams->workDoneToken = anyToProgressToken(*iter->second);
    }

    return documentRangesFormattingParams;
  }

  auto LspTransformer::textDocumentRangesFormattingResultToAny(
    const TextDocumentRangesFormattingResult &result
  ) -> std::unique_ptr<LSPAny> {
    switch (static_cast<TextDocumentRangesFormattingResultType>(result.index())) {
    case TextDocumentRangesFormattingResultType::TEXT_EDIT_ARRAY: {
      LSPArray array;
      for (const std::unique_ptr<TextEdit> &elem
          : std::get<std::vector<std::unique_ptr<TextEdit>>>(result)) {
        array.push_back(textEditToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      return any;
    }
    case TextDocumentRangesFormattingResultType::NULL_TYPE: {
      return nullToAny(std::get<null_t>(result));
    }
    }
    throw LSP_EXCEPTION(
      ErrorCodes::INTERNAL_ERROR,
      "Should be unreachable."
    );
  }

  auto LspTransformer::asTextDocumentOnTypeFormattingParams(
    const MessageParams &requestParams
  ) const -> std::unique_ptr<DocumentOnTypeFormattingParams> {
    if (static_cast<MessageParamsType>(requestParams.index()) != MessageParamsType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Message parameter type must be MessageParamsType::" +
         MessageParamsTypeNames.at(MessageParamsType::OBJECT_TYPE) +
         " for method=\"textDocument/onTypeFormatting\" but received type " +
         "MessageParamsType::" + MessageParamsTypeNames.at(static_cast<MessageParamsType>(requestParams.index())))
      );
    }

    const LSPObject &object = std::get<LSPObject>(requestParams);
    LSPObject::const_iterator iter;

    std::unique_ptr<DocumentOnTypeFormattingParams> documentOnTypeFormattingParams =
      std::make_unique<DocumentOnTypeFormattingParams>();

    iter = object.find("textDocument");
    if (iter != object.end()) {
      documentOnTypeFormattingParams->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DocumentOnTypeFormattingParams attribute: textDocument"
      );
    }

    iter = object.find("position");
    if (iter != object.end()) {
      documentOnTypeFormattingParams->position = anyToPosition(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DocumentOnTypeFormattingParams attribute: position"
      );
    }

    iter = object.find("ch");
    if (iter != object.end()) {
      documentOnTypeFormattingParams->ch = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DocumentOnTypeFormattingParams attribute: ch"
      );
    }

    iter = object.find("options");
    if (iter != object.end()) {
      documentOnTypeFormattingParams->options = anyToFormattingOptions(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DocumentOnTypeFormattingParams attribute: options"
      );
    }

    return documentOnTypeFormattingParams;
  }

  auto LspTransformer::textDocumentOnTypeFormattingResultToAny(
    const TextDocumentOnTypeFormattingResult &result
  ) -> std::unique_ptr<LSPAny> {
    switch (static_cast<TextDocumentOnTypeFormattingResultType>(result.index())) {
    case TextDocumentOnTypeFormattingResultType::TEXT_EDIT_ARRAY: {
      LSPArray array;
      for (const std::unique_ptr<TextEdit> &elem
          : std::get<std::vector<std::unique_ptr<TextEdit>>>(result)) {
        array.push_back(textEditToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      return any;
    }
    case TextDocumentOnTypeFormattingResultType::NULL_TYPE: {
      return nullToAny(std::get<null_t>(result));
    }
    }
    throw LSP_EXCEPTION(
      ErrorCodes::INTERNAL_ERROR,
      "Should be unreachable."
    );
  }

  auto LspTransformer::asTextDocumentRenameParams(
    const MessageParams &requestParams
  ) const -> std::unique_ptr<RenameParams> {
    if (static_cast<MessageParamsType>(requestParams.index()) != MessageParamsType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Message parameter type must be MessageParamsType::" +
         MessageParamsTypeNames.at(MessageParamsType::OBJECT_TYPE) +
         " for method=\"textDocument/rename\" but received type " +
         "MessageParamsType::" + MessageParamsTypeNames.at(static_cast<MessageParamsType>(requestParams.index())))
      );
    }

    const LSPObject &object = std::get<LSPObject>(requestParams);
    LSPObject::const_iterator iter;

    std::unique_ptr<RenameParams> renameParams =
      std::make_unique<RenameParams>();

    iter = object.find("textDocument");
    if (iter != object.end()) {
      renameParams->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required RenameParams attribute: textDocument"
      );
    }

    iter = object.find("position");
    if (iter != object.end()) {
      renameParams->position = anyToPosition(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required RenameParams attribute: position"
      );
    }

    iter = object.find("newName");
    if (iter != object.end()) {
      renameParams->newName = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required RenameParams attribute: newName"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      renameParams->workDoneToken = anyToProgressToken(*iter->second);
    }

    return renameParams;
  }

  auto LspTransformer::textDocumentRenameResultToAny(
    const TextDocumentRenameResult &result
  ) -> std::unique_ptr<LSPAny> {
    switch (static_cast<TextDocumentRenameResultType>(result.index())) {
    case TextDocumentRenameResultType::WORKSPACE_EDIT: {
      return workspaceEditToAny(*std::get<std::unique_ptr<WorkspaceEdit>>(result));
    }
    case TextDocumentRenameResultType::NULL_TYPE: {
      return nullToAny(std::get<null_t>(result));
    }
    }
    throw LSP_EXCEPTION(
      ErrorCodes::INTERNAL_ERROR,
      "Should be unreachable."
    );
  }

  auto LspTransformer::asTextDocumentPrepareRenameParams(
    const MessageParams &requestParams
  ) const -> std::unique_ptr<PrepareRenameParams> {
    if (static_cast<MessageParamsType>(requestParams.index()) != MessageParamsType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Message parameter type must be MessageParamsType::" +
         MessageParamsTypeNames.at(MessageParamsType::OBJECT_TYPE) +
         " for method=\"textDocument/prepareRename\" but received type " +
         "MessageParamsType::" + MessageParamsTypeNames.at(static_cast<MessageParamsType>(requestParams.index())))
      );
    }

    const LSPObject &object = std::get<LSPObject>(requestParams);
    LSPObject::const_iterator iter;

    std::unique_ptr<PrepareRenameParams> prepareRenameParams =
      std::make_unique<PrepareRenameParams>();

    iter = object.find("textDocument");
    if (iter != object.end()) {
      prepareRenameParams->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required PrepareRenameParams attribute: textDocument"
      );
    }

    iter = object.find("position");
    if (iter != object.end()) {
      prepareRenameParams->position = anyToPosition(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required PrepareRenameParams attribute: position"
      );
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      prepareRenameParams->workDoneToken = anyToProgressToken(*iter->second);
    }

    return prepareRenameParams;
  }

  auto LspTransformer::textDocumentPrepareRenameResultToAny(
    const TextDocumentPrepareRenameResult &result
  ) -> std::unique_ptr<LSPAny> {
    switch (static_cast<TextDocumentPrepareRenameResultType>(result.index())) {
    case TextDocumentPrepareRenameResultType::PREPARE_RENAME_RESULT: {
      return prepareRenameResultToAny(std::get<PrepareRenameResult>(result));
    }
    case TextDocumentPrepareRenameResultType::NULL_TYPE: {
      return nullToAny(std::get<null_t>(result));
    }
    }
    throw LSP_EXCEPTION(
      ErrorCodes::INTERNAL_ERROR,
      "Should be unreachable."
    );
  }

  auto LspTransformer::asWorkspaceExecuteCommandParams(
    const MessageParams &requestParams
  ) const -> std::unique_ptr<ExecuteCommandParams> {
    if (static_cast<MessageParamsType>(requestParams.index()) != MessageParamsType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Message parameter type must be MessageParamsType::" +
         MessageParamsTypeNames.at(MessageParamsType::OBJECT_TYPE) +
         " for method=\"workspace/executeCommand\" but received type " +
         "MessageParamsType::" + MessageParamsTypeNames.at(static_cast<MessageParamsType>(requestParams.index())))
      );
    }

    const LSPObject &object = std::get<LSPObject>(requestParams);
    LSPObject::const_iterator iter;

    std::unique_ptr<ExecuteCommandParams> executeCommandParams =
      std::make_unique<ExecuteCommandParams>();

    iter = object.find("command");
    if (iter != object.end()) {
      executeCommandParams->command = anyToString(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required ExecuteCommandParams attribute: command"
      );
    }

    iter = object.find("arguments");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<std::unique_ptr<LSPAny>> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(copy(elem));
      }
      executeCommandParams->arguments = std::move(values);
    }

    iter = object.find("workDoneToken");
    if (iter != object.end()) {
      executeCommandParams->workDoneToken = anyToProgressToken(*iter->second);
    }

    return executeCommandParams;
  }

  auto LspTransformer::workspaceExecuteCommandResultToAny(
    const WorkspaceExecuteCommandResult &result
  ) -> std::unique_ptr<LSPAny> {
    switch (static_cast<WorkspaceExecuteCommandResultType>(result.index())) {
    case WorkspaceExecuteCommandResultType::ANY_TYPE: {
      return copy(std::get<std::unique_ptr<LSPAny>>(result));
    }
    case WorkspaceExecuteCommandResultType::NULL_TYPE: {
      return nullToAny(std::get<null_t>(result));
    }
    }
    throw LSP_EXCEPTION(
      ErrorCodes::INTERNAL_ERROR,
      "Should be unreachable."
    );
  }

  // ====================== //
  // Incoming Notifications //
  // ====================== //

  auto LspTransformer::asWorkspaceDidChangeWorkspaceFoldersParams(
    const MessageParams &notificationParams
  ) const -> std::unique_ptr<DidChangeWorkspaceFoldersParams> {
    if (static_cast<MessageParamsType>(notificationParams.index()) != MessageParamsType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Message parameter type must be MessageParamsType::" +
         MessageParamsTypeNames.at(MessageParamsType::OBJECT_TYPE) +
         " for method=\"workspace/didChangeWorkspaceFolders\" but received type " +
         "MessageParamsType::" + MessageParamsTypeNames.at(static_cast<MessageParamsType>(notificationParams.index())))
      );
    }

    const LSPObject &object = std::get<LSPObject>(notificationParams);
    LSPObject::const_iterator iter;

    std::unique_ptr<DidChangeWorkspaceFoldersParams> didChangeWorkspaceFoldersParams =
      std::make_unique<DidChangeWorkspaceFoldersParams>();

    iter = object.find("event");
    if (iter != object.end()) {
      didChangeWorkspaceFoldersParams->event = anyToWorkspaceFoldersChangeEvent(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DidChangeWorkspaceFoldersParams attribute: event"
      );
    }

    return didChangeWorkspaceFoldersParams;
  }

  auto LspTransformer::asWindowWorkDoneProgressCancelParams(
    const MessageParams &notificationParams
  ) const -> std::unique_ptr<WorkDoneProgressCancelParams> {
    if (static_cast<MessageParamsType>(notificationParams.index()) != MessageParamsType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Message parameter type must be MessageParamsType::" +
         MessageParamsTypeNames.at(MessageParamsType::OBJECT_TYPE) +
         " for method=\"window/workDoneProgress/cancel\" but received type " +
         "MessageParamsType::" + MessageParamsTypeNames.at(static_cast<MessageParamsType>(notificationParams.index())))
      );
    }

    const LSPObject &object = std::get<LSPObject>(notificationParams);
    LSPObject::const_iterator iter;

    std::unique_ptr<WorkDoneProgressCancelParams> workDoneProgressCancelParams =
      std::make_unique<WorkDoneProgressCancelParams>();

    iter = object.find("token");
    if (iter != object.end()) {
      workDoneProgressCancelParams->token = anyToProgressToken(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required WorkDoneProgressCancelParams attribute: token"
      );
    }

    return workDoneProgressCancelParams;
  }

  auto LspTransformer::asWorkspaceDidCreateFilesParams(
    const MessageParams &notificationParams
  ) const -> std::unique_ptr<CreateFilesParams> {
    if (static_cast<MessageParamsType>(notificationParams.index()) != MessageParamsType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Message parameter type must be MessageParamsType::" +
         MessageParamsTypeNames.at(MessageParamsType::OBJECT_TYPE) +
         " for method=\"workspace/didCreateFiles\" but received type " +
         "MessageParamsType::" + MessageParamsTypeNames.at(static_cast<MessageParamsType>(notificationParams.index())))
      );
    }

    const LSPObject &object = std::get<LSPObject>(notificationParams);
    LSPObject::const_iterator iter;

    std::unique_ptr<CreateFilesParams> createFilesParams =
      std::make_unique<CreateFilesParams>();

    iter = object.find("files");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<std::unique_ptr<FileCreate>> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToFileCreate(*elem));
      }
      createFilesParams->files = std::move(values);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required CreateFilesParams attribute: files"
      );
    }

    return createFilesParams;
  }

  auto LspTransformer::asWorkspaceDidRenameFilesParams(
    const MessageParams &notificationParams
  ) const -> std::unique_ptr<RenameFilesParams> {
    if (static_cast<MessageParamsType>(notificationParams.index()) != MessageParamsType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Message parameter type must be MessageParamsType::" +
         MessageParamsTypeNames.at(MessageParamsType::OBJECT_TYPE) +
         " for method=\"workspace/didRenameFiles\" but received type " +
         "MessageParamsType::" + MessageParamsTypeNames.at(static_cast<MessageParamsType>(notificationParams.index())))
      );
    }

    const LSPObject &object = std::get<LSPObject>(notificationParams);
    LSPObject::const_iterator iter;

    std::unique_ptr<RenameFilesParams> renameFilesParams =
      std::make_unique<RenameFilesParams>();

    iter = object.find("files");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<std::unique_ptr<FileRename>> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToFileRename(*elem));
      }
      renameFilesParams->files = std::move(values);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required RenameFilesParams attribute: files"
      );
    }

    return renameFilesParams;
  }

  auto LspTransformer::asWorkspaceDidDeleteFilesParams(
    const MessageParams &notificationParams
  ) const -> std::unique_ptr<DeleteFilesParams> {
    if (static_cast<MessageParamsType>(notificationParams.index()) != MessageParamsType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Message parameter type must be MessageParamsType::" +
         MessageParamsTypeNames.at(MessageParamsType::OBJECT_TYPE) +
         " for method=\"workspace/didDeleteFiles\" but received type " +
         "MessageParamsType::" + MessageParamsTypeNames.at(static_cast<MessageParamsType>(notificationParams.index())))
      );
    }

    const LSPObject &object = std::get<LSPObject>(notificationParams);
    LSPObject::const_iterator iter;

    std::unique_ptr<DeleteFilesParams> deleteFilesParams =
      std::make_unique<DeleteFilesParams>();

    iter = object.find("files");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<std::unique_ptr<FileDelete>> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToFileDelete(*elem));
      }
      deleteFilesParams->files = std::move(values);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DeleteFilesParams attribute: files"
      );
    }

    return deleteFilesParams;
  }

  auto LspTransformer::asNotebookDocumentDidOpenParams(
    const MessageParams &notificationParams
  ) const -> std::unique_ptr<DidOpenNotebookDocumentParams> {
    if (static_cast<MessageParamsType>(notificationParams.index()) != MessageParamsType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Message parameter type must be MessageParamsType::" +
         MessageParamsTypeNames.at(MessageParamsType::OBJECT_TYPE) +
         " for method=\"notebookDocument/didOpen\" but received type " +
         "MessageParamsType::" + MessageParamsTypeNames.at(static_cast<MessageParamsType>(notificationParams.index())))
      );
    }

    const LSPObject &object = std::get<LSPObject>(notificationParams);
    LSPObject::const_iterator iter;

    std::unique_ptr<DidOpenNotebookDocumentParams> didOpenNotebookDocumentParams =
      std::make_unique<DidOpenNotebookDocumentParams>();

    iter = object.find("notebookDocument");
    if (iter != object.end()) {
      didOpenNotebookDocumentParams->notebookDocument = anyToNotebookDocument(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DidOpenNotebookDocumentParams attribute: notebookDocument"
      );
    }

    iter = object.find("cellTextDocuments");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<std::unique_ptr<TextDocumentItem>> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToTextDocumentItem(*elem));
      }
      didOpenNotebookDocumentParams->cellTextDocuments = std::move(values);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DidOpenNotebookDocumentParams attribute: cellTextDocuments"
      );
    }

    return didOpenNotebookDocumentParams;
  }

  auto LspTransformer::asNotebookDocumentDidChangeParams(
    const MessageParams &notificationParams
  ) const -> std::unique_ptr<DidChangeNotebookDocumentParams> {
    if (static_cast<MessageParamsType>(notificationParams.index()) != MessageParamsType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Message parameter type must be MessageParamsType::" +
         MessageParamsTypeNames.at(MessageParamsType::OBJECT_TYPE) +
         " for method=\"notebookDocument/didChange\" but received type " +
         "MessageParamsType::" + MessageParamsTypeNames.at(static_cast<MessageParamsType>(notificationParams.index())))
      );
    }

    const LSPObject &object = std::get<LSPObject>(notificationParams);
    LSPObject::const_iterator iter;

    std::unique_ptr<DidChangeNotebookDocumentParams> didChangeNotebookDocumentParams =
      std::make_unique<DidChangeNotebookDocumentParams>();

    iter = object.find("notebookDocument");
    if (iter != object.end()) {
      didChangeNotebookDocumentParams->notebookDocument = anyToVersionedNotebookDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DidChangeNotebookDocumentParams attribute: notebookDocument"
      );
    }

    iter = object.find("change");
    if (iter != object.end()) {
      didChangeNotebookDocumentParams->change = anyToNotebookDocumentChangeEvent(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DidChangeNotebookDocumentParams attribute: change"
      );
    }

    return didChangeNotebookDocumentParams;
  }

  auto LspTransformer::asNotebookDocumentDidSaveParams(
    const MessageParams &notificationParams
  ) const -> std::unique_ptr<DidSaveNotebookDocumentParams> {
    if (static_cast<MessageParamsType>(notificationParams.index()) != MessageParamsType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Message parameter type must be MessageParamsType::" +
         MessageParamsTypeNames.at(MessageParamsType::OBJECT_TYPE) +
         " for method=\"notebookDocument/didSave\" but received type " +
         "MessageParamsType::" + MessageParamsTypeNames.at(static_cast<MessageParamsType>(notificationParams.index())))
      );
    }

    const LSPObject &object = std::get<LSPObject>(notificationParams);
    LSPObject::const_iterator iter;

    std::unique_ptr<DidSaveNotebookDocumentParams> didSaveNotebookDocumentParams =
      std::make_unique<DidSaveNotebookDocumentParams>();

    iter = object.find("notebookDocument");
    if (iter != object.end()) {
      didSaveNotebookDocumentParams->notebookDocument = anyToNotebookDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DidSaveNotebookDocumentParams attribute: notebookDocument"
      );
    }

    return didSaveNotebookDocumentParams;
  }

  auto LspTransformer::asNotebookDocumentDidCloseParams(
    const MessageParams &notificationParams
  ) const -> std::unique_ptr<DidCloseNotebookDocumentParams> {
    if (static_cast<MessageParamsType>(notificationParams.index()) != MessageParamsType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Message parameter type must be MessageParamsType::" +
         MessageParamsTypeNames.at(MessageParamsType::OBJECT_TYPE) +
         " for method=\"notebookDocument/didClose\" but received type " +
         "MessageParamsType::" + MessageParamsTypeNames.at(static_cast<MessageParamsType>(notificationParams.index())))
      );
    }

    const LSPObject &object = std::get<LSPObject>(notificationParams);
    LSPObject::const_iterator iter;

    std::unique_ptr<DidCloseNotebookDocumentParams> didCloseNotebookDocumentParams =
      std::make_unique<DidCloseNotebookDocumentParams>();

    iter = object.find("notebookDocument");
    if (iter != object.end()) {
      didCloseNotebookDocumentParams->notebookDocument = anyToNotebookDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DidCloseNotebookDocumentParams attribute: notebookDocument"
      );
    }

    iter = object.find("cellTextDocuments");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<std::unique_ptr<TextDocumentIdentifier>> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToTextDocumentIdentifier(*elem));
      }
      didCloseNotebookDocumentParams->cellTextDocuments = std::move(values);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DidCloseNotebookDocumentParams attribute: cellTextDocuments"
      );
    }

    return didCloseNotebookDocumentParams;
  }

  auto LspTransformer::asInitializedParams(
    const MessageParams &notificationParams
  ) const -> std::unique_ptr<InitializedParams> {
    if (static_cast<MessageParamsType>(notificationParams.index()) != MessageParamsType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Message parameter type must be MessageParamsType::" +
         MessageParamsTypeNames.at(MessageParamsType::OBJECT_TYPE) +
         " for method=\"initialized\" but received type " +
         "MessageParamsType::" + MessageParamsTypeNames.at(static_cast<MessageParamsType>(notificationParams.index())))
      );
    }

    std::unique_ptr<InitializedParams> initializedParams =
      std::make_unique<InitializedParams>();

    return initializedParams;
  }

  auto LspTransformer::asWorkspaceDidChangeConfigurationParams(
    const MessageParams &notificationParams
  ) const -> std::unique_ptr<DidChangeConfigurationParams> {
    if (static_cast<MessageParamsType>(notificationParams.index()) != MessageParamsType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Message parameter type must be MessageParamsType::" +
         MessageParamsTypeNames.at(MessageParamsType::OBJECT_TYPE) +
         " for method=\"workspace/didChangeConfiguration\" but received type " +
         "MessageParamsType::" + MessageParamsTypeNames.at(static_cast<MessageParamsType>(notificationParams.index())))
      );
    }

    const LSPObject &object = std::get<LSPObject>(notificationParams);
    LSPObject::const_iterator iter;

    std::unique_ptr<DidChangeConfigurationParams> didChangeConfigurationParams =
      std::make_unique<DidChangeConfigurationParams>();

    iter = object.find("settings");
    if (iter != object.end()) {
      didChangeConfigurationParams->settings = copy(iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DidChangeConfigurationParams attribute: settings"
      );
    }

    return didChangeConfigurationParams;
  }

  auto LspTransformer::asTextDocumentDidOpenParams(
    const MessageParams &notificationParams
  ) const -> std::unique_ptr<DidOpenTextDocumentParams> {
    if (static_cast<MessageParamsType>(notificationParams.index()) != MessageParamsType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Message parameter type must be MessageParamsType::" +
         MessageParamsTypeNames.at(MessageParamsType::OBJECT_TYPE) +
         " for method=\"textDocument/didOpen\" but received type " +
         "MessageParamsType::" + MessageParamsTypeNames.at(static_cast<MessageParamsType>(notificationParams.index())))
      );
    }

    const LSPObject &object = std::get<LSPObject>(notificationParams);
    LSPObject::const_iterator iter;

    std::unique_ptr<DidOpenTextDocumentParams> didOpenTextDocumentParams =
      std::make_unique<DidOpenTextDocumentParams>();

    iter = object.find("textDocument");
    if (iter != object.end()) {
      didOpenTextDocumentParams->textDocument = anyToTextDocumentItem(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DidOpenTextDocumentParams attribute: textDocument"
      );
    }

    return didOpenTextDocumentParams;
  }

  auto LspTransformer::asTextDocumentDidChangeParams(
    const MessageParams &notificationParams
  ) const -> std::unique_ptr<DidChangeTextDocumentParams> {
    if (static_cast<MessageParamsType>(notificationParams.index()) != MessageParamsType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Message parameter type must be MessageParamsType::" +
         MessageParamsTypeNames.at(MessageParamsType::OBJECT_TYPE) +
         " for method=\"textDocument/didChange\" but received type " +
         "MessageParamsType::" + MessageParamsTypeNames.at(static_cast<MessageParamsType>(notificationParams.index())))
      );
    }

    const LSPObject &object = std::get<LSPObject>(notificationParams);
    LSPObject::const_iterator iter;

    std::unique_ptr<DidChangeTextDocumentParams> didChangeTextDocumentParams =
      std::make_unique<DidChangeTextDocumentParams>();

    iter = object.find("textDocument");
    if (iter != object.end()) {
      didChangeTextDocumentParams->textDocument = anyToVersionedTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DidChangeTextDocumentParams attribute: textDocument"
      );
    }

    iter = object.find("contentChanges");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<TextDocumentContentChangeEvent> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToTextDocumentContentChangeEvent(*elem));
      }
      didChangeTextDocumentParams->contentChanges = std::move(values);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DidChangeTextDocumentParams attribute: contentChanges"
      );
    }

    return didChangeTextDocumentParams;
  }

  auto LspTransformer::asTextDocumentDidCloseParams(
    const MessageParams &notificationParams
  ) const -> std::unique_ptr<DidCloseTextDocumentParams> {
    if (static_cast<MessageParamsType>(notificationParams.index()) != MessageParamsType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Message parameter type must be MessageParamsType::" +
         MessageParamsTypeNames.at(MessageParamsType::OBJECT_TYPE) +
         " for method=\"textDocument/didClose\" but received type " +
         "MessageParamsType::" + MessageParamsTypeNames.at(static_cast<MessageParamsType>(notificationParams.index())))
      );
    }

    const LSPObject &object = std::get<LSPObject>(notificationParams);
    LSPObject::const_iterator iter;

    std::unique_ptr<DidCloseTextDocumentParams> didCloseTextDocumentParams =
      std::make_unique<DidCloseTextDocumentParams>();

    iter = object.find("textDocument");
    if (iter != object.end()) {
      didCloseTextDocumentParams->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DidCloseTextDocumentParams attribute: textDocument"
      );
    }

    return didCloseTextDocumentParams;
  }

  auto LspTransformer::asTextDocumentDidSaveParams(
    const MessageParams &notificationParams
  ) const -> std::unique_ptr<DidSaveTextDocumentParams> {
    if (static_cast<MessageParamsType>(notificationParams.index()) != MessageParamsType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Message parameter type must be MessageParamsType::" +
         MessageParamsTypeNames.at(MessageParamsType::OBJECT_TYPE) +
         " for method=\"textDocument/didSave\" but received type " +
         "MessageParamsType::" + MessageParamsTypeNames.at(static_cast<MessageParamsType>(notificationParams.index())))
      );
    }

    const LSPObject &object = std::get<LSPObject>(notificationParams);
    LSPObject::const_iterator iter;

    std::unique_ptr<DidSaveTextDocumentParams> didSaveTextDocumentParams =
      std::make_unique<DidSaveTextDocumentParams>();

    iter = object.find("textDocument");
    if (iter != object.end()) {
      didSaveTextDocumentParams->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DidSaveTextDocumentParams attribute: textDocument"
      );
    }

    iter = object.find("text");
    if (iter != object.end()) {
      didSaveTextDocumentParams->text = anyToString(*iter->second);
    }

    return didSaveTextDocumentParams;
  }

  auto LspTransformer::asTextDocumentWillSaveParams(
    const MessageParams &notificationParams
  ) const -> std::unique_ptr<WillSaveTextDocumentParams> {
    if (static_cast<MessageParamsType>(notificationParams.index()) != MessageParamsType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Message parameter type must be MessageParamsType::" +
         MessageParamsTypeNames.at(MessageParamsType::OBJECT_TYPE) +
         " for method=\"textDocument/willSave\" but received type " +
         "MessageParamsType::" + MessageParamsTypeNames.at(static_cast<MessageParamsType>(notificationParams.index())))
      );
    }

    const LSPObject &object = std::get<LSPObject>(notificationParams);
    LSPObject::const_iterator iter;

    std::unique_ptr<WillSaveTextDocumentParams> willSaveTextDocumentParams =
      std::make_unique<WillSaveTextDocumentParams>();

    iter = object.find("textDocument");
    if (iter != object.end()) {
      willSaveTextDocumentParams->textDocument = anyToTextDocumentIdentifier(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required WillSaveTextDocumentParams attribute: textDocument"
      );
    }

    iter = object.find("reason");
    if (iter != object.end()) {
      willSaveTextDocumentParams->reason = anyToTextDocumentSaveReason(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required WillSaveTextDocumentParams attribute: reason"
      );
    }

    return willSaveTextDocumentParams;
  }

  auto LspTransformer::asWorkspaceDidChangeWatchedFilesParams(
    const MessageParams &notificationParams
  ) const -> std::unique_ptr<DidChangeWatchedFilesParams> {
    if (static_cast<MessageParamsType>(notificationParams.index()) != MessageParamsType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Message parameter type must be MessageParamsType::" +
         MessageParamsTypeNames.at(MessageParamsType::OBJECT_TYPE) +
         " for method=\"workspace/didChangeWatchedFiles\" but received type " +
         "MessageParamsType::" + MessageParamsTypeNames.at(static_cast<MessageParamsType>(notificationParams.index())))
      );
    }

    const LSPObject &object = std::get<LSPObject>(notificationParams);
    LSPObject::const_iterator iter;

    std::unique_ptr<DidChangeWatchedFilesParams> didChangeWatchedFilesParams =
      std::make_unique<DidChangeWatchedFilesParams>();

    iter = object.find("changes");
    if (iter != object.end()) {
      const LSPArray &array = std::get<LSPArray>(*iter->second);
      std::vector<std::unique_ptr<FileEvent>> values;
      for (const std::unique_ptr<LSPAny> &elem : array) {
        values.push_back(anyToFileEvent(*elem));
      }
      didChangeWatchedFilesParams->changes = std::move(values);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required DidChangeWatchedFilesParams attribute: changes"
      );
    }

    return didChangeWatchedFilesParams;
  }

  auto LspTransformer::asSetTraceParams(
    const MessageParams &notificationParams
  ) const -> std::unique_ptr<SetTraceParams> {
    if (static_cast<MessageParamsType>(notificationParams.index()) != MessageParamsType::OBJECT_TYPE) {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Message parameter type must be MessageParamsType::" +
         MessageParamsTypeNames.at(MessageParamsType::OBJECT_TYPE) +
         " for method=\"$/setTrace\" but received type " +
         "MessageParamsType::" + MessageParamsTypeNames.at(static_cast<MessageParamsType>(notificationParams.index())))
      );
    }

    const LSPObject &object = std::get<LSPObject>(notificationParams);
    LSPObject::const_iterator iter;

    std::unique_ptr<SetTraceParams> setTraceParams =
      std::make_unique<SetTraceParams>();

    iter = object.find("value");
    if (iter != object.end()) {
      setTraceParams->value = anyToTraceValues(*iter->second);
    } else {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        "Missing required SetTraceParams attribute: value"
      );
    }

    return setTraceParams;
  }

  // ================= //
  // Outgoing Requests //
  // ================= //

  auto LspTransformer::anyToWorkspaceWorkspaceFoldersResult(
    const LSPAny &any
  ) const -> WorkspaceWorkspaceFoldersResult {
    WorkspaceWorkspaceFoldersResult value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::ARRAY_TYPE: {
      try {
        std::vector<std::unique_ptr<WorkspaceFolder>> values;
        for (const std::unique_ptr<LSPAny> &elem
            : std::get<LSPArray>(any)) {
          values.push_back(anyToWorkspaceFolder(*elem));
        }
        value = std::move(values);
      } catch (LspException &e) {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          "Failed to transform LSPAny to array"
        );
      }
      break;
    }
    case LSPAnyType::NULL_TYPE: {
      value = anyToNull(any);
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) WorkspaceWorkspaceFoldersResult: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::asMessageParams(
    const ConfigurationParams &requestParams
  ) const -> MessageParams {
    MessageParams messageParams;
    LSPObject object;

    {
      LSPArray array;
      for (const std::unique_ptr<ConfigurationItem> &elem : requestParams.items) {
        array.push_back(configurationItemToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("items", std::move(any));
    }

    messageParams = std::move(object);
    return messageParams;
  }

  auto LspTransformer::anyToWorkspaceConfigurationResult(
    const LSPAny &any
  ) const -> WorkspaceConfigurationResult {
    WorkspaceConfigurationResult value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::ARRAY_TYPE: {
      try {
        std::vector<std::unique_ptr<LSPAny>> values;
        for (const std::unique_ptr<LSPAny> &elem
            : std::get<LSPArray>(any)) {
          values.push_back(copy(elem));
        }
        value = std::move(values);
      } catch (LspException &e) {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          "Failed to transform LSPAny to array"
        );
      }
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) WorkspaceConfigurationResult: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::anyToWorkspaceFoldingRangeRefreshResult(
    const LSPAny &any
  ) const -> WorkspaceFoldingRangeRefreshResult {
    WorkspaceFoldingRangeRefreshResult value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::NULL_TYPE: {
      value = anyToNull(any);
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) WorkspaceFoldingRangeRefreshResult: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::asMessageParams(
    const WorkDoneProgressCreateParams &requestParams
  ) const -> MessageParams {
    MessageParams messageParams;
    LSPObject object;

    object.emplace("token", progressTokenToAny(requestParams.token));

    messageParams = std::move(object);
    return messageParams;
  }

  auto LspTransformer::anyToWindowWorkDoneProgressCreateResult(
    const LSPAny &any
  ) const -> WindowWorkDoneProgressCreateResult {
    WindowWorkDoneProgressCreateResult value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::NULL_TYPE: {
      value = anyToNull(any);
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) WindowWorkDoneProgressCreateResult: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::anyToWorkspaceSemanticTokensRefreshResult(
    const LSPAny &any
  ) const -> WorkspaceSemanticTokensRefreshResult {
    WorkspaceSemanticTokensRefreshResult value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::NULL_TYPE: {
      value = anyToNull(any);
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) WorkspaceSemanticTokensRefreshResult: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::asMessageParams(
    const ShowDocumentParams &requestParams
  ) const -> MessageParams {
    MessageParams messageParams;
    LSPObject object;

    object.emplace("uri", uriToAny(requestParams.uri));
    if (requestParams.external.has_value()) {
      object.emplace("external", booleanToAny(requestParams.external.value()));
    }
    if (requestParams.takeFocus.has_value()) {
      object.emplace("takeFocus", booleanToAny(requestParams.takeFocus.value()));
    }
    if (requestParams.selection.has_value()) {
      object.emplace("selection", rangeToAny(*requestParams.selection.value()));
    }

    messageParams = std::move(object);
    return messageParams;
  }

  auto LspTransformer::anyToWindowShowDocumentResult(
    const LSPAny &any
  ) const -> std::unique_ptr<WindowShowDocumentResult> {
    std::unique_ptr<WindowShowDocumentResult> value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::OBJECT_TYPE: {
      try {
        value = anyToShowDocumentResult(any);
      } catch (LspException &e) {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          "Failed to transform LSPAny to WindowShowDocumentResult"
        );
      }
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) WindowShowDocumentResult: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::anyToWorkspaceInlineValueRefreshResult(
    const LSPAny &any
  ) const -> WorkspaceInlineValueRefreshResult {
    WorkspaceInlineValueRefreshResult value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::NULL_TYPE: {
      value = anyToNull(any);
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) WorkspaceInlineValueRefreshResult: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::anyToWorkspaceInlayHintRefreshResult(
    const LSPAny &any
  ) const -> WorkspaceInlayHintRefreshResult {
    WorkspaceInlayHintRefreshResult value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::NULL_TYPE: {
      value = anyToNull(any);
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) WorkspaceInlayHintRefreshResult: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::anyToWorkspaceDiagnosticRefreshResult(
    const LSPAny &any
  ) const -> WorkspaceDiagnosticRefreshResult {
    WorkspaceDiagnosticRefreshResult value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::NULL_TYPE: {
      value = anyToNull(any);
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) WorkspaceDiagnosticRefreshResult: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::asMessageParams(
    const RegistrationParams &requestParams
  ) const -> MessageParams {
    MessageParams messageParams;
    LSPObject object;

    {
      LSPArray array;
      for (const std::unique_ptr<Registration> &elem : requestParams.registrations) {
        array.push_back(registrationToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("registrations", std::move(any));
    }

    messageParams = std::move(object);
    return messageParams;
  }

  auto LspTransformer::anyToClientRegisterCapabilityResult(
    const LSPAny &any
  ) const -> ClientRegisterCapabilityResult {
    ClientRegisterCapabilityResult value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::NULL_TYPE: {
      value = anyToNull(any);
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) ClientRegisterCapabilityResult: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::asMessageParams(
    const UnregistrationParams &requestParams
  ) const -> MessageParams {
    MessageParams messageParams;
    LSPObject object;

    {
      LSPArray array;
      for (const std::unique_ptr<Unregistration> &elem : requestParams.unregisterations) {
        array.push_back(unregistrationToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("unregisterations", std::move(any));
    }

    messageParams = std::move(object);
    return messageParams;
  }

  auto LspTransformer::anyToClientUnregisterCapabilityResult(
    const LSPAny &any
  ) const -> ClientUnregisterCapabilityResult {
    ClientUnregisterCapabilityResult value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::NULL_TYPE: {
      value = anyToNull(any);
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) ClientUnregisterCapabilityResult: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::asMessageParams(
    const ShowMessageRequestParams &requestParams
  ) const -> MessageParams {
    MessageParams messageParams;
    LSPObject object;

    object.emplace("type", messageTypeToAny(requestParams.type));
    object.emplace("message", stringToAny(requestParams.message));
    if (requestParams.actions.has_value()) {
      {
        LSPArray array;
        for (const std::unique_ptr<MessageActionItem> &elem : requestParams.actions.value()) {
          array.push_back(messageActionItemToAny(*elem));
        }
        std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
        (*any) = std::move(array);
        object.emplace("actions", std::move(any));
      }
    }

    messageParams = std::move(object);
    return messageParams;
  }

  auto LspTransformer::anyToWindowShowMessageRequestResult(
    const LSPAny &any
  ) const -> WindowShowMessageRequestResult {
    WindowShowMessageRequestResult value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::OBJECT_TYPE: {
      try {
        value = anyToMessageActionItem(any);
      } catch (LspException &e) {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          "Failed to transform LSPAny to WindowShowMessageRequestResult"
        );
      }
      break;
    }
    case LSPAnyType::NULL_TYPE: {
      value = anyToNull(any);
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) WindowShowMessageRequestResult: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::anyToWorkspaceCodeLensRefreshResult(
    const LSPAny &any
  ) const -> WorkspaceCodeLensRefreshResult {
    WorkspaceCodeLensRefreshResult value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::NULL_TYPE: {
      value = anyToNull(any);
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) WorkspaceCodeLensRefreshResult: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  auto LspTransformer::asMessageParams(
    const ApplyWorkspaceEditParams &requestParams
  ) const -> MessageParams {
    MessageParams messageParams;
    LSPObject object;

    if (requestParams.label.has_value()) {
      object.emplace("label", stringToAny(requestParams.label.value()));
    }
    object.emplace("edit", workspaceEditToAny(*requestParams.edit));

    messageParams = std::move(object);
    return messageParams;
  }

  auto LspTransformer::anyToWorkspaceApplyEditResult(
    const LSPAny &any
  ) const -> std::unique_ptr<WorkspaceApplyEditResult> {
    std::unique_ptr<WorkspaceApplyEditResult> value;

    switch (static_cast<LSPAnyType>(any.index())) {
    case LSPAnyType::OBJECT_TYPE: {
      try {
        value = anyToApplyWorkspaceEditResult(any);
      } catch (LspException &e) {
        throw LSP_EXCEPTION(
          ErrorCodes::INVALID_PARAMS,
          "Failed to transform LSPAny to WorkspaceApplyEditResult"
        );
      }
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAnyType for a(n) WorkspaceApplyEditResult: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(any.index())))
      );
    }
    }

    return value;
  }

  // ====================== //
  // Outgoing Notifications //
  // ====================== //

  auto LspTransformer::asMessageParams(
    const ShowMessageParams &notificationParams
  ) const -> MessageParams {
    MessageParams messageParams;
    LSPObject object;

    object.emplace("type", messageTypeToAny(notificationParams.type));
    object.emplace("message", stringToAny(notificationParams.message));

    messageParams = std::move(object);
    return messageParams;
  }

  auto LspTransformer::asMessageParams(
    const LogMessageParams &notificationParams
  ) const -> MessageParams {
    MessageParams messageParams;
    LSPObject object;

    object.emplace("type", messageTypeToAny(notificationParams.type));
    object.emplace("message", stringToAny(notificationParams.message));

    messageParams = std::move(object);
    return messageParams;
  }

  auto LspTransformer::asMessageParams(
    const LSPAny &notificationParams
  ) const -> MessageParams {
    MessageParams messageParams;
    switch (static_cast<LSPAnyType>(notificationParams.index())) {
    case LSPAnyType::OBJECT_TYPE: {
      const LSPObject &object = std::get<LSPObject>(notificationParams);
      messageParams = copy(object);
      break;
    }
    case LSPAnyType::ARRAY_TYPE: {
      const LSPArray &array = std::get<LSPArray>(notificationParams);
      messageParams = copy(array);
      break;
    }
    default: {
      throw LSP_EXCEPTION(
        ErrorCodes::INVALID_PARAMS,
        ("Invalid LSPAny type for LSPAny: " +
         LSPAnyTypeNames.at(static_cast<LSPAnyType>(notificationParams.index())))
      );
    }
    }

    return messageParams;
  }

  auto LspTransformer::asMessageParams(
    const PublishDiagnosticsParams &notificationParams
  ) const -> MessageParams {
    MessageParams messageParams;
    LSPObject object;

    object.emplace("uri", documentUriToAny(notificationParams.uri));
    if (notificationParams.version.has_value()) {
      object.emplace("version", integerToAny(notificationParams.version.value()));
    }
    {
      LSPArray array;
      for (const std::unique_ptr<Diagnostic> &elem : notificationParams.diagnostics) {
        array.push_back(diagnosticToAny(*elem));
      }
      std::unique_ptr<LSPAny> any = std::make_unique<LSPAny>();
      (*any) = std::move(array);
      object.emplace("diagnostics", std::move(any));
    }

    messageParams = std::move(object);
    return messageParams;
  }

  auto LspTransformer::asMessageParams(
    const LogTraceParams &notificationParams
  ) const -> MessageParams {
    MessageParams messageParams;
    LSPObject object;

    object.emplace("message", stringToAny(notificationParams.message));
    if (notificationParams.verbose.has_value()) {
      object.emplace("verbose", stringToAny(notificationParams.verbose.value()));
    }

    messageParams = std::move(object);
    return messageParams;
  }

} // LCompilers::LanguageServerProtocol
